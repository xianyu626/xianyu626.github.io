<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>北咸&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/ef0d17ecf071d7c7318a42df36c1c8a1</icon>
  <subtitle>There is an Artificial Idiot...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.southe3n.cf/"/>
  <updated>2018-10-21T23:50:52.000Z</updated>
  <id>http://blog.southe3n.cf/</id>
  
  <author>
    <name>北咸</name>
    <email>qxq22255090@hotmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CF1072记录贴</title>
    <link href="http://blog.southe3n.cf/2018/10/21/cf1072jilutie/"/>
    <id>http://blog.southe3n.cf/2018/10/21/cf1072jilutie/</id>
    <published>2018-10-21T12:40:36.000Z</published>
    <updated>2018-10-21T23:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这场CF打完心态有点崩…记录一下</p><p><code>（T2卡一小时 ， T3 FST了解一下？）</code></p></blockquote><a id="more"></a><p><a href="http://codeforces.com/contest/1072" target="_blank" rel="noopener">先扔个比赛链接</a></p><p>T1不管</p><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p><strong>Description</strong></p><p>T2题意是给两个长度为 $n-1(n\leq 10^5)$ 的数列 $a,b$ ，<strong>值域 $0$~$3$</strong></p><p>要求构造一个数列 $t$ 满足：</p><ul><li><p>$a[i]=t[i]|t[i+1]$</p></li><li><p>$b[i]=t[i]\&amp;t[i+1]$</p></li></ul><p>若无解则输出$NO$</p><p><strong>Solution</strong></p><p>其实是一个挺简单的DP，<strong>注意值域只有两位二进制</strong></p><p>$f[i][j]$ 表示 $t$ 数组填到第 $i$ 个且 $t_i=j$ 是否可行，然后在转移的时候记录是从哪里转移过来的就好了。输出时从最后一位倒着找回去。</p><p><strong>Code</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">101000</span>],b[<span class="number">101000</span>],f[<span class="number">101000</span>][<span class="number">10</span>],fa[<span class="number">101000</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">101000</span>],res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=f[<span class="number">1</span>][<span class="number">1</span>]=f[<span class="number">1</span>][<span class="number">2</span>]=f[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                <span class="keyword">if</span>((a[i<span class="number">-1</span>]==(j|k))&amp;&amp;(b[i<span class="number">-1</span>]==(j&amp;k))) </span><br><span class="line">                    <span class="keyword">if</span>(f[i<span class="number">-1</span>][k]) f[i][j]=<span class="number">1</span>,fa[i][j]=k;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!f[n][res]&amp;&amp;res&lt;=<span class="number">3</span>) res++;</span><br><span class="line">    <span class="keyword">if</span>(res==<span class="number">4</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)</span><br><span class="line">        ans[i]=res,res=fa[i][res];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p><strong>Description</strong></p><p>给两个数 $a,b\le 10^9$ 要求构造两个数列，使其和分别<strong>小于等于</strong> $a,b$ 且数列中的数两两不相同</p><p>使两数列<strong>长度和最大</strong>，给出方案</p><p><strong>Solution</strong></p><p>贪心一下，先将  $a+b$ 拆成 $1+2+…+x$ + $y(x&lt;y)$的形式</p><p>后用贪心地思想先将 $a$ 填完，再用剩下的数去填 $b$ </p><p><strong>Attention：$b$ 是有可能填不满的！！</strong></p><blockquote><p>代码写的太乱，就不贴了</p></blockquote><h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><p><strong>Description</strong></p><p>给出一个 $n·n(n\leq 2000)$ 的字母矩阵，从 $(1,1)$ 走到 $(n,n)$ ，只能向下或向右走，有 $k$ 次机会将一个格子上的字母改成 <code>&#39;a&#39;</code> </p><p>求一种走法使得路径所经过的字母串的<strong>字典序最小</strong></p><p><strong>Input</strong></p><pre>4 2abcdbcdebcadbcde</pre><pre>5 3bwwwzhrhdhsepspsqfafajbvw</pre><p><strong>Output</strong></p><pre>aaabcde</pre><pre>aaaepfafw</pre><p><strong>Solution</strong></p><p>首先因为是字典序，所以改前面比改后面优秀，先DP求出所有能在改 $k$ 次及以内走到的点使得路径上全部都是<code>&#39;a&#39;</code></p><p>如下图，黑色的格子是改 $k$ 次能走到的最远的点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="\img\cf1072d.png" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure><p>显然，<strong>在红线以前的格子一定不是最优的</strong>，所以我们从红线上的黑格子开始<strong>平行于对角线</strong>向 $(n,n)$ 推进，以到<strong>当前斜线为止答案最优的点向右和下拓展</strong>，打上标记，然后从下一条斜线打了标记的点中选出字母最小的点继续进行标记。</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,K,line,f[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">int</span> able[<span class="number">2010</span>][<span class="number">2010</span>];  <span class="comment">//标记前面的路径是最优的</span></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="built_in">string</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,g[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=min(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>])+(g[i][j]!=<span class="string">'a'</span>);</span><br><span class="line">        <span class="comment">//求出到每个点的最小更改次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(f[i][j]&lt;=K)&#123;</span><br><span class="line">                line=max(i+j<span class="number">-1</span>,line); <span class="comment">//找到最远的一条斜线</span></span><br><span class="line">                able[i+<span class="number">1</span>][j]=able[i][j+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=line;i++) ans+=<span class="string">'a'</span>;</span><br><span class="line">    able[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    line++;</span><br><span class="line">    <span class="keyword">int</span> nowmin;</span><br><span class="line">    <span class="keyword">while</span>(line&lt;n*<span class="number">2</span>)&#123;</span><br><span class="line">        nowmin=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=n;i++)&#123;</span><br><span class="line">            j=line-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">1</span>||j&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(able[i][j]) nowmin=min(nowmin,(<span class="keyword">int</span>)g[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=nowmin; <span class="comment">//找出每条斜线中的最小合法字母，计入答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=n;i++)&#123;</span><br><span class="line">            j=line-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span>||j&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nowmin==g[i][j]&amp;&amp;able[i][j]) able[i+<span class="number">1</span>][j]=able[i][j+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        line++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><blockquote><p>T2刚看到没注意到值域只有两位二进制想了半天，看到了之后又想着贪心构造，一点都没想着要DP，菜菜菜</p><p>T3听同学讲的题意，不知道拆出来数列和可以不等于那个数，就挂了。。</p><p>T4最后二十多分钟其实应该要码的出来的，还是挂了，心有点乱</p><p>心态真的是个大问题，见的题也少，T2显然的DP愣是没看出来，后面心态就崩了</p><p><strong>总而言之，菜是原罪</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这场CF打完心态有点崩…记录一下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;（T2卡一小时 ， T3 FST了解一下？）&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://blog.southe3n.cf/categories/Codeforces/"/>
    
    
      <category term="贪心" scheme="http://blog.southe3n.cf/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="DP" scheme="http://blog.southe3n.cf/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CF1060E [上下DP]</title>
    <link href="http://blog.southe3n.cf/2018/10/04/cf1060eshangxiadp/"/>
    <id>http://blog.southe3n.cf/2018/10/04/cf1060eshangxiadp/</id>
    <published>2018-10-04T13:30:43.000Z</published>
    <updated>2018-10-19T12:57:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：树形DP  上下DP<br>相关题目：<a href="http://codeforces.com/contest/1060/problem/E" target="_blank" rel="noopener">$CF1060E$</a></div></blockquote><a id="more"></a><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>有一颗 $n(n\leq 200000)$ 个点的树,边权均为1</p><p>若两个点在树上具有一个相同的相邻点，则在新图上建立一条链接这两点的边<br>换句话说若$u$和$a$在树上有连边，$v$和$a$也有连边，则在新图上建立边$(u,v)$</p><p>求在新图上所有点对之间的最短距离之和</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>考虑每个点对<strong>*在原树和新图上的距离变化</strong>，设原树距离为$Len$</p><p>若$Len$为偶数，则在路径上每两点之间都有一条新边，新距离为$\frac{Len}{2}$<br>若$Len$为奇数，则在路径上多了一个点要使用原树上的边，新距离为$\frac{Len}{2}+1$</p><p>因此，<strong>若我们可以知道以每个点为起点的到所有点的路径长度和，以及其中长度为奇数的路径的条数就可以统计答案了</strong></p><p>考虑如何求这两个东西，想到树形DP<br>但是普通的树形DP是从叶节点到一个<strong>固定的根</strong>统计答案的，而这里我们需要知道的是<strong>以每个点为根的答案</strong></p><p>这时候就需要引入一个叫<strong>上下DP</strong>的东西</p><blockquote><p>似乎是机房特供？向机房大佬低头！</p></blockquote><p>对每个点记录三个值</p><ul><li>sum：以该点为起点的所有路径长度和</li><li>s1: 以该点为起点的长度为<strong>奇数</strong>的路径条数</li><li>s2: 以该点为起点的长度为<strong>偶数</strong>的路径条数</li></ul><p>然后我们现在需要从一个点 $u$ 将答案转移掉另一个点 $v$，且它们在原树中有连边<br>发现所有路径的长度变化都取决于边$(u,v)$是<strong>被包含进去了还是不再取了</strong></p><p>到$v$点及其子树的点的路径变短了，到其余点的路径变长了，而路径长度的奇偶性则对换了一下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum[v]=sum[u]+size[u]<span class="number">-2</span>*size[v];</span><br><span class="line">size[v]=size[u];</span><br><span class="line">s1[v]=s2[u];</span><br><span class="line">s2[v]=s1[u];</span><br></pre></td></tr></table></figure></p><p>那么事情就好办了<br>将以每个点为根的答案累加，由于所有路径都被算了两次，最后再除以2就好了</p><div class="note success">依我个人的理解，上下DP就是在树上将以不同点为根的答案进行转移<br>在转移过程中只用考虑转移的这条边对答案的影响就好了</div><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N],ans;</span><br><span class="line"><span class="keyword">int</span> s1[N],s2[N],size[N],n;</span><br><span class="line"><span class="keyword">int</span> to[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">to[++cnt]=v,nxt[cnt]=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">size[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line"><span class="keyword">if</span>(to[i]!=ff) &#123;</span><br><span class="line">dfs1(to[i],u);</span><br><span class="line">size[u]+=size[to[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">s2[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v=to[i];i;i=nxt[i],v=to[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==ff) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(v,u);</span><br><span class="line">sum[u]+=sum[v]+size[v];</span><br><span class="line">s1[u]+=s2[v];</span><br><span class="line">s2[u]+=s1[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">ans+=sum[u]+s1[u]; <span class="comment">//先直接累加原值，到输出时直接/4</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v=to[i];i;i=nxt[i],v=to[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==ff) <span class="keyword">continue</span>; </span><br><span class="line">sum[v]=sum[u]+size[u]<span class="number">-2</span>*size[v];</span><br><span class="line">size[v]=size[u];</span><br><span class="line">s1[v]=s2[u];</span><br><span class="line">s2[v]=s1[u];</span><br><span class="line">dfs3(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">add(x,y), add(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//处理出子树大小</span></span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//用树形DP算出以1为根时的答案</span></span><br><span class="line">dfs3(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//将答案转移到所有点上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans/<span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：树形DP  上下DP&lt;br&gt;
相关题目：&lt;a href=&quot;http://codeforces.com/contest/1060/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$CF1060E$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://blog.southe3n.cf/categories/Codeforces/"/>
    
    
      <category term="DP" scheme="http://blog.southe3n.cf/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CF1058E</title>
    <link href="http://blog.southe3n.cf/2018/09/25/cf1058e/"/>
    <id>http://blog.southe3n.cf/2018/09/25/cf1058e/</id>
    <published>2018-09-25T12:15:32.000Z</published>
    <updated>2018-10-21T05:53:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：二进制<br>相关题目：<a href="http://codeforces.com/contest/1058/problem/E" target="_blank" rel="noopener">$CF1058E$</a></div></blockquote><a id="more"></a><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定$n(n\leq 300000)$个数，<strong>值域 $1 \sim 1e18$</strong><br><strong>定义操作为，将一个数转换成二进制后，可以将其变为任何与其1个数相同的数（位数不限）</strong></p><p>求区间 $(l,r)$ 使区间内的数经任意操作后异或和为0的区间数</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>首先发现数的具体值对答案没有影响，所以先把数处理成1的个数</p><p><del>易得</del><br><span id="inline-toc">1.</span>一个区间内1个数和为偶数<br><span id="inline-toc">2.</span>且1的个数的最大值不大于1个数和的话</p><p>这个区间就是合法的</p><p>首先考虑如果只有第一个条件怎么办<br>维护三个前缀和：1的个数和，前缀和为奇数的个数和，前缀和为偶数的个数和</p><p>然后枚举一下左端点，用三个前缀和算一下当前左端点对答案的贡献就好了</p><p><strong>等等？！似乎还有个条件2？？</strong></p><p>冷静分析</p><div class="note success">发现一个数1的个数<strong>最大只有63个，最少也有1个</strong><br>似乎只要区间长度大于64，第二个条件就一定满足？<br>那<strong>对于每一个左端点向右枚举一下右端点，单独算一下</strong><br>直到区间长度大于64再用前面所说的前缀和算一下剩下的贡献就好了。</div><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">300100</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],sum[N],f[<span class="number">10</span>][N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(x) a[i]+=x&amp;<span class="number">1</span>,x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        f[sum[i]&amp;<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[<span class="number">0</span>][i]+=f[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        f[<span class="number">1</span>][i]+=f[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r,maxn;l&lt;=n;l++)&#123;</span><br><span class="line">        maxn=a[l];</span><br><span class="line">        <span class="keyword">for</span>(r=l+<span class="number">1</span>;r&lt;=n&amp;&amp;r-l+<span class="number">1</span>&lt;=<span class="number">64</span>;r++)&#123;</span><br><span class="line">            maxn=max(a[r],maxn);</span><br><span class="line">            <span class="keyword">if</span>((sum[r]-sum[l<span class="number">-1</span>])%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;maxn*<span class="number">2</span>&lt;=(sum[r]-sum[l<span class="number">-1</span>])) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=f[sum[l<span class="number">-1</span>]&amp;<span class="number">1</span>][n]-f[sum[l<span class="number">-1</span>]&amp;<span class="number">1</span>][r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：二进制&lt;br&gt;
相关题目：&lt;a href=&quot;http://codeforces.com/contest/1058/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$CF1058E$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://blog.southe3n.cf/categories/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>青蛙</title>
    <link href="http://blog.southe3n.cf/2018/09/24/qingwa/"/>
    <id>http://blog.southe3n.cf/2018/09/24/qingwa/</id>
    <published>2018-09-24T01:15:09.000Z</published>
    <updated>2018-10-21T05:54:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：数学期望  调和级数<br>相关题目：<a href="https://www.luogu.org/problemnew/show/U39825" target="_blank" rel="noopener">$Luogu39825$</a></div></blockquote><a id="more"></a><blockquote><p>同学私人题库里的一道题，数学期望入门题</p></blockquote><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>现在有一只青蛙（Called ZBY!） 在第$n$个荷叶上，每一次等概率地跳到第1格~当前所在荷叶上<br>求ZBY跳到第1个格子上的步数期望，保留8位小数</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>我们用 f[i] 表示第i格跳到第1格的数学期望，则易得</p><script type="math/tex; mode=display">f[i]=1+\Sigma_{j=1}^i f[j]*\frac{1}{i}</script><p>变一下形</p><script type="math/tex; mode=display">i*f[i]=i+\Sigma_{j=1}^{i-1}f[j]+f[i]</script><p>然后可得</p><script type="math/tex; mode=display">(i-1)*f[i]=i+\Sigma_{j=1}^{i-1}f[j]</script><script type="math/tex; mode=display">(i-1)*f[i-1]=i-1+\Sigma_{j=1}^{i-1}f[j]</script><p>上下两个式子相减,我们会惊喜的发现</p><script type="math/tex; mode=display">f[i]-f[i-1]=\frac{1}{i-1}</script><p>这样我们就得到了一个递推式</p><script type="math/tex; mode=display">f[n]=f[2]+\Sigma_{i=2}^{n-1}\frac{1}{i}</script><p>似乎后面这部分是个调和级数？<br>调和级数 $\Sigma_{i=1}^{n}\frac{1}{i}$ 虽然是发散的，但是当n较大时,可以用 $ln(n)+欧拉常数$ 来求其近似前缀和</p><blockquote><p>欧拉常数≈$0.5772156649015328606$<br>$f[2]=2$</p></blockquote><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a><span id="inline-green">Code</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1e6</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) ans+=<span class="number">1</span>/(<span class="keyword">double</span>)i;</span><br><span class="line">        <span class="keyword">else</span> ans=<span class="built_in">log</span>(n<span class="number">-1</span>)<span class="number">-1</span>+<span class="number">0.5772156649015328606</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>,<span class="number">2</span>+ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：数学期望  调和级数&lt;br&gt;
相关题目：&lt;a href=&quot;https://www.luogu.org/problemnew/show/U39825&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Luogu39825$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="数学期望" scheme="http://blog.southe3n.cf/tags/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】矩阵乘法</title>
    <link href="http://blog.southe3n.cf/2018/08/12/xuexibijijuzhenchengfa/"/>
    <id>http://blog.southe3n.cf/2018/08/12/xuexibijijuzhenchengfa/</id>
    <published>2018-08-11T16:00:00.000Z</published>
    <updated>2018-10-21T05:51:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实是看到的一个我认为还算优美的矩阵乘法板子，贴一下备忘</p></blockquote><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> m[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">    matrix(<span class="keyword">int</span> flg=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span> m);</span><br><span class="line">        <span class="keyword">if</span>(flg)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) m[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A;</span><br><span class="line"><span class="keyword">inline</span> matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix &amp;A,<span class="keyword">const</span> matrix &amp;B) &#123;</span><br><span class="line">    <span class="function">matrix <span class="title">C</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">                C.m[i][j]+=A.m[i][k]*B.m[k][j];</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> matrix <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    matrix B(1),C=A;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) B=B*C;</span><br><span class="line">        C=C*C;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实是看到的一个我认为还算优美的矩阵乘法板子，贴一下备忘&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.southe3n.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2018暑期集训[7.26~8.10]</title>
    <link href="http://blog.southe3n.cf/2018/08/11/2018shuqijixun726810/"/>
    <id>http://blog.southe3n.cf/2018/08/11/2018shuqijixun726810/</id>
    <published>2018-08-10T16:00:00.000Z</published>
    <updated>2018-10-30T01:45:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">放一些这段时间模拟赛的题<br>似乎很多题我都忘记了？！？<br>就当复习了  <br></div></blockquote><a id="more"></a><hr><h2 id="完备匹配"><a href="#完备匹配" class="headerlink" title="完备匹配"></a><center>完备匹配</center></h2><center><span id="inline-blue">时间限制：2s</span><span id="inline-yellow">空间限制：256MB</span></center><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>有一个两边点集大小都是$n$的二分图。他本来是一个完全二分图（即把图中的顶点分成两个集合，使得第一个集合中的所有顶点都与第二个集合中的所有顶点相连）。</p><p>每条边都有一个边权。对一个匹配，在匹配中边的边权的总和为这个匹配的价值。但是由于某些原因，这个二分图中的$k$条边不见了。</p><p>他想知道现在这个二分图还有几种完备匹配（如果图的所有顶点都与某匹配中的一条边相关联，则称此匹配为完备匹配)方案，并且所有完备匹配的价值的总和是多少。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行，一个正整数$n$。</p><p>接下来有$n$行，每行$n$个整数，第$i$行第$j$个整数$w_{i,j}$，表示点$i$向另一个点集中的点$j$边的权值。注意点从$0$开始标号。</p><p>接下来一行，一个正整数$k$，表示有多少条边不见了。</p><p>接下来$k$行，每行两个整数$u,v$，表示点$u$向另一个点集中的点$v$边不见了。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行两个整数，第一个数为完备匹配的个数，第二个数为所有完备匹配的价值总和，由于数字较大，请对$10^9+7$取模。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre>52 3 4 5 65 4 3 2 17 6 5 4 35 6 7 8 93 4 5 6 731 22 23 4</pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p><code>60 1408</code></p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于$100%$的数据，$n\leq 300$, $k\leq 20$ , $0\leq w_{i,j}\leq 500$。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这是一道要用到<strong>容斥原理</strong>的题</p><p>先考虑第一问。首先如果没有不可选的边，那么完备匹配数就是$n!$</p><p>然后我们可以惊喜的地发现$k$非常的小，只有20，那么我们就可以对不可选地边进行 $2^k$ 次枚举，<br><strong>根据容斥原理，将奇数条不可选的边产生地方案数从总方案数中减去，将偶数条的方案数加上</strong></p><blockquote><p>那么这个方案数该怎么计算呢？假设我们现在枚举出$sum$条边，由于一共需要$n$条边，其中$sum$条边已经确定，那么方案数就是$(n-sum)!$</p></blockquote><p>第二问其实也是同样的道理，首先算出<strong>全部边可选</strong>的情况下的权值总和<br>再将枚举出的边根据数量奇偶性在答案中加减，要注意的是在这个过程中不能有两条被选中的边有同一个顶点</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,K,g[<span class="number">310</span>][<span class="number">310</span>],sum[<span class="number">2</span>][<span class="number">310</span>],x[<span class="number">25</span>],y[<span class="number">25</span>],u[<span class="number">25</span>],v[<span class="number">25</span>],vis[<span class="number">2</span>][<span class="number">310</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> jc[<span class="number">310</span>],ans1,ans2,Sigma,tmp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> Sum,<span class="keyword">int</span> sigma,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==K+<span class="number">1</span>) &#123;</span><br><span class="line">        ans1+=(Sum&amp;<span class="number">1</span>)?mod-jc[n-Sum]:jc[n-Sum];</span><br><span class="line">        <span class="keyword">if</span>(ans1&gt;=mod) ans1%=mod;</span><br><span class="line">        tmp=(sigma*jc[n-Sum<span class="number">-1</span>]%mod+num*jc[n-Sum]%mod)%mod;</span><br><span class="line">        ans2+=(Sum&amp;<span class="number">1</span>)?mod-tmp:tmp;</span><br><span class="line">        <span class="keyword">if</span>(ans2&gt;=mod) ans2%=mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(k+<span class="number">1</span>,Sum,sigma,num);</span><br><span class="line">    <span class="keyword">if</span>(vis[<span class="number">0</span>][u[k]]||vis[<span class="number">1</span>][v[k]]) <span class="keyword">return</span>;</span><br><span class="line">    x[Sum+<span class="number">1</span>]=u[k];</span><br><span class="line">    y[Sum+<span class="number">1</span>]=v[k];</span><br><span class="line">    sigma+=g[u[k]][v[k]]-sum[<span class="number">0</span>][u[k]]-sum[<span class="number">1</span>][v[k]];</span><br><span class="line">    vis[<span class="number">0</span>][u[k]]=<span class="number">1</span>;</span><br><span class="line">    vis[<span class="number">1</span>][v[k]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Sum;i++)</span><br><span class="line">        sigma+=g[x[i]][v[k]]+g[u[k]][y[i]];</span><br><span class="line">    dfs(k+<span class="number">1</span>,Sum+<span class="number">1</span>,sigma,num+g[u[k]][v[k]]);</span><br><span class="line">    vis[<span class="number">0</span>][u[k]]=<span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">1</span>][v[k]]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;g[i][j]),sum[<span class="number">0</span>][i]+=g[i][j],sum[<span class="number">1</span>][j]+=g[i][j];</span><br><span class="line">        Sigma+=sum[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u[i],&amp;v[i]);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>,Sigma,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,ans1,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="图书列表"><a href="#图书列表" class="headerlink" title="图书列表"></a><center>图书列表</center></h2><center><span id="inline-blue">时间限制：1s</span><span id="inline-yellow">空间限制：256MB</span></center><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>现在小G作为图书管理员，他的第一份工作是重新安排一些图书。他得到了一张列表，每个表项具有以下格式：<br>CATEGORY1/CATEGORY 2/…./CATEGORY n/BOOKNAME<br>这表示图书BOOKNAME位于目录CATEGORY n下, 目录CATEGORY n 位于目录CATEGORY n-1下，目录CATEGORY n-1位于目录CATEGORY n-2下， 以此类推。也就是说，每个表项是由最后的一本图书，以及该图书所属的若干目录按照层级依次组成的。我们称CATEGORY1为一级目录，而CATEGORY 2为二级目录，以此类推。例如：</p><ol><li>MATH/GRAPH THEORY</li><li>ART/HISTORY/JAPANESE HISTORY/JAPANESE ACIENT HISTORY</li><li>ART/HISTORY/CHINESE HISTORY/THREE KINDOM/RESEARCHES ON LIUBEI</li><li>ART/HISTORY/CHINESE HISTORY/CHINESE MORDEN HISTORY</li><li>ART/HISTORY/CHINESE HISTORY/THREE KINDOM/RESEARCHES ON CAOCAO</li></ol><p>小G认为这份列表很不容易阅读和查找，于是他决定按照以下规则制作一份新列表，用缩进来体现图书与目录之间的层级关系：</p><ol><li>n级目录之前有$4\times (n-1)$个空格的缩进。</li><li>直接隶属于n级目录的图书前有$4\times n$个空格的缩进。</li><li>直接隶属于目录X目录与图书按照字典序列在目录X之后，但所有目录位于所有图书之前。</li><li>所有一级目录按照字典序先后列出。</li></ol><p>例如，上面的列表转化后将变为：</p><pre>ART    HISTORY        CHINESE HISTORY            THREE KINDOM                RESEARCHES ON CAOCAO                RESEARCHES ON LIUBEI            CHINESE MORDEN HISTORY        JAPANESE HISTORY            JAPANESE ACIENT HISTORYMATH    GRAPH THEORY</pre><p>请写一个程序帮助小G完成这项工作。</p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>输入原列表，共包含不超过30本图书，以一个数字0结尾。<br>每行列出一个表项，表项是一个由大写字母、数字、“/”和空格构成的字符串，长度不超过100。<br>一本图书可能在列表中出现多次，但在转化后的列表中，它应该只出现一次。但是若同名的图书或目录若在不同的目录结构下，则认为他们是不相同的。换句话说，一个图书或目录由以它的名字为结尾的前缀唯一确定。</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>输出新列表。本试题采用逐字节比较，行末请勿输出多余空格，文末以恰好一个换行符结尾。</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre>B/AB/AB/B0</pre><pre>A1/B1/B32/B7A1/B/B2/B4/C5A1/B1/B2/B6/C5A1/B1/B2/B5A1/B1/B2A1/B1/B2/B1A1/B3/B2A3/B1A0/A10</pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre>B    A    B</pre><pre>A0    A1A1    B        B2            B4                C5    B1        B2            B6                C5            B1            B5        B32            B7        B2    B3        B2A3    B1</pre><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>模拟题，将每行数据读入后，先在整个字符串后面加上一个’/‘方便处理，每次到一个’/‘，将前面的一串字符取出，根据其是否在行末判断是目录还是书籍，并作标记,然后记录到子目录列表中，记录时注意判重复，只有在当前子目录中没有的名称才新建，否则直接进入已有的目录</p><p>对每一个目录我们用一个数组记录其子目录，最后会形成一个树形结构，<br>注意，为了方便处理，我们可以将所有一级目录定为一个虚拟出来的根目录的子目录</p><p>将所有数据读完之后，将每一个子目录列表按照题目规定的顺序进行排序，然后从虚拟的根目录开始dfs按照顺序输出就可以了</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>((ch&lt;<span class="string">'A'</span>||ch&gt;<span class="string">'Z'</span>)&amp;&amp;(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&amp;&amp;ch!=<span class="string">' '</span>) ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">'\n'</span>&amp;&amp;ch!=<span class="string">'\r'</span>) s+=ch,ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> s[<span class="number">1600</span>],st,now;</span><br><span class="line"><span class="keyword">int</span> fa,lens,flg,cnt,son[<span class="number">1600</span>][<span class="number">100</span>],isbook[<span class="number">1600</span>],is;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isbook[x]==isbook[y]?s[x]&lt;s[y]:isbook[x]&lt;isbook[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>*(dep<span class="number">-1</span>);i++) <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s[u]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=son[u][<span class="number">0</span>];i++)</span><br><span class="line">        dfs(son[u][i],dep+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(st);</span><br><span class="line">    <span class="keyword">while</span>(st[<span class="number">0</span>]!=<span class="string">'0'</span>||st.length()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        st+=<span class="string">'/'</span>;</span><br><span class="line">        lens=st.size(); now.clear();</span><br><span class="line">        fa=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lens;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i]==<span class="string">'/'</span>)&#123;</span><br><span class="line">                flg=is=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==lens<span class="number">-1</span>) is=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=son[fa][<span class="number">0</span>];j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[son[fa][j]]==now&amp;&amp;is==isbook[son[fa][j]])&#123;</span><br><span class="line">                        fa=son[fa][j];</span><br><span class="line">                        flg=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flg) &#123;now.clear();<span class="keyword">continue</span>;&#125;</span><br><span class="line">                s[++cnt]=now;</span><br><span class="line">                son[fa][++son[fa][<span class="number">0</span>]]=cnt;</span><br><span class="line">                isbook[cnt]=is;</span><br><span class="line">                fa=cnt;</span><br><span class="line">                now.clear();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            now+=st[i];</span><br><span class="line">        &#125;</span><br><span class="line">        read(st);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;i++)</span><br><span class="line">        sort(son[i]+<span class="number">1</span>,son[i]+son[i][<span class="number">0</span>]+<span class="number">1</span>,cmp);</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="量化交易"><a href="#量化交易" class="headerlink" title="量化交易"></a><center>量化交易</center></h2><center><span id="inline-blue">时间限制：1s</span><span id="inline-yellow">空间限制：128MB</span></center><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><blockquote><p>由于原题面实在太罗嗦，笔者<del>稍微</del>简化了一下</p></blockquote><p>给出$n$个数，表示$n$天中股票的价格，每天可以买进或卖出一股，也可以什么也不做<strong>求$n$天后的最大收益</strong></p><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>每个测试点包含若干组数据，以EOF结尾。对于每组数据：<br>第一行1个整数N。<br>第二行N个正整数，相邻两个整数之间用1个空格隔开，表示每一天股票的价格。</p><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>对于每组数据，首先按样例所示的格式“Case #k:”输出该组数据的编号，然后输出一个整数，表示applepi最大能够获得的利润。</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre>62 6 7 3 5 681 2 3 4 5 6 7 8</pre><pre>1015831 47573 60015 51368 32460 34125 43074 75172 54014 93578</pre><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre>Case #1: 8Case #2: 16</pre><pre>Case #1: 161084</pre><h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>对于$50%$的数据，$1\leq N\leq 1000$。<br>对于$100%$的数据，$1\leq N\leq 100000$，股票价格不超过$100000$，每个测试点至多包含$5$组数据。</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><blockquote><p>考场上想了半天贪心，最后还是只打了50分的暴力，结果发现只是自己的贪心姿势水平不够啊</p></blockquote><p>我们先<strong>默认每天都是卖出的，然后维护一个堆</strong>，将每天的价格扔<strong>两个</strong>进去，<br>既然要卖出，那自然得有相应的买入，也就是从堆中取出一个价格，每天将答案加上当天价格减去取出的价格。第$n$天后的答案就是输出</p><div class="note success">那么来证明一下这个贪心<strong>正确性</strong><br>首先在贪心过程中一个卖出一定对应一个买入，并且每一时刻堆中的价格都是在该时刻以前的，是可以选择的。这样就符合了题意<br>那么为什么这样贪心最优呢？要理解<strong>若一天的价格没有从堆中取出，则该天的操作时卖出，若取出一次则是不操作，若取出两次则是买入</strong><br>而每次买入都是以当前可选的最低价格买入的，答案自然最优了</div><blockquote><p>要注意，由于C++的优先队列默认是大根堆，程序实现时压入的是价格的相反数，和描述不太一样</p></blockquote><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> x,T,n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        T++,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            q.push(-x),q.push(-x);</span><br><span class="line">            ans+=x+q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,T,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="小象和老鼠"><a href="#小象和老鼠" class="headerlink" title="小象和老鼠"></a><center>小象和老鼠</center></h2><center><span id="inline-blue">时间限制：1s</span><span id="inline-yellow">空间限制：128MB</span></center><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><blockquote><p>还是那句话，原题面好罗嗦啊，来zip一下</p></blockquote><p>给定一个$n\times m$的网格图，左上角为$(1,1)$ ，右下角为$(n,m)$ ，每个点上可能有若干只老鼠。</p><p>现在要从找出一条从左上角到右下角的路径，使沿途遇到的老鼠数量最少(“遇到”的定义是在路径上某一点的四联通快内，<strong>相同老鼠不重复计数</strong>)，走的时候<strong>只能向下或向右</strong>。</p><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个用空格隔开的整数，$n$ 和 $m$。 接下来一个 $n \times m$ 的矩阵表示动物园的地图。其中 <script type="math/tex">a_{i,j}</script> 表示第 <script type="math/tex">i</script> 行第 <script type="math/tex">j</script> 列上老鼠的数量。 若 $a_{i,j}=0$ 则表示当前位置上没有老鼠（$(1,1)$也可能存在老鼠）。</p><h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示路线最小的数量是多少。</p><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre>3 90 0 1 0 0 0 0 0 11 1 1 1 1 1 0 1 01 0 0 1 0 0 1 0 0</pre><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre>9</pre><h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>对于 $10%$ 的数据，$1\leq N,M\leq 5$。<br>对于 $100%$ 的数据，$1\leq N,M\leq 1000$ ， $0\leq A_{i,j}\leq 100$。</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><blockquote><p>一开始写了个记搜妄想能过，结果发现自己太天真了。。。还好DP并不难想</p></blockquote><p>单独考虑每一步遇到的老鼠数量，发现只有上一步走之前所处的位置有可能与这一步走完后所处位置上遇到的老鼠有重复。</p><p>那么我们用 $f[0..1][i][j]$ 表示上一步是向下还是向右，$i,j$ 表示所处位置，<br>这样 $f[0][i][j]$ 就从 $f[i-1][j]$ 两种状态转移过来， $f[1][i][j]$ 从 $f[i][j-1]$ 转移过来</p><div class="note warning">注意初始值将 $f[0..1][1][1]$ 都赋成 $(1,1)$ 能看到的老鼠数</div><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">1100</span>][<span class="number">1100</span>],f[<span class="number">2</span>][<span class="number">1100</span>][<span class="number">1100</span>],tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>][<span class="number">1</span>]+a[<span class="number">1</span>][<span class="number">2</span>]+a[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            tmp=a[i][j<span class="number">-1</span>]+a[i][j+<span class="number">1</span>]+a[i<span class="number">-1</span>][j]+a[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            f[<span class="number">0</span>][i][j]=tmp+min(f[<span class="number">0</span>][i<span class="number">-1</span>][j]-a[i<span class="number">-1</span>][j],f[<span class="number">1</span>][i<span class="number">-1</span>][j]-a[i<span class="number">-1</span>][j]-a[i][j<span class="number">-1</span>]);</span><br><span class="line">            f[<span class="number">1</span>][i][j]=tmp+min(f[<span class="number">0</span>][i][j<span class="number">-1</span>]-a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j],f[<span class="number">1</span>][i][j<span class="number">-1</span>]-a[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min(f[<span class="number">0</span>][n][m],f[<span class="number">1</span>][n][m]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="量子模型"><a href="#量子模型" class="headerlink" title="量子模型 "></a><center>量子模型 </center></h2><center><span id="inline-blue">时间限制：1s</span><span id="inline-yellow">空间限制：128MB</span></center><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><p>小 W 所在学校的物理学水平全国闻名，因此吸引来了大量民间科学爱好者。某一天， 一位自称能做出诺贝尔奖级别成果，颠覆人类物理学框架的民间科学爱好者拦住了小 W， 和小 W 分享了一种小 W 闻所未闻的量子模型：  一个量子的状态可以用一个有序三元组来表示，如果该量子的状态是$(x,y,z)$，则能够发生如下六种之一的跃迁，转移到另一个状态（如果原状态$(x,y,z)$满足这种跃迁发生的前提条件的话）。</p><div class="table-container"><table><thead><tr><th>前提条件</th><th>跃迁后状态</th></tr></thead><tbody><tr><td>$z &lt; min(2y-x,x)$ 或者 $z &gt; max(2y-x,x)$</td><td>$(2y-x,y,z)$</td></tr><tr><td>$z &lt; min(2x-y,y)$ 或者 $z &gt; max(2x-y,y)$</td><td>$(x,2x-y,z)$</td></tr><tr><td>$y &lt; min(2z-x,x)$ 或者 $y &gt; max(2z-x,x)$</td><td>$(2z-x,y,z)$</td></tr><tr><td>$y &lt; min(2x-z,z)$ 或者 $y &gt; max(2x-z,z)$</td><td>$(x,y,2x-z)$</td></tr><tr><td>$x &lt; min(2y-z,z)$ 或者 $x &gt; max(2y-z,z)$</td><td>$(x,y,2y-z)$</td></tr><tr><td>$x &lt; min(2z-y,y)$ 或者 $x &gt; max(2z-y,y)$</td><td>$(x,2z-y,z)$</td></tr></tbody></table></div><p>所有的量子的初始状态都是$(i,j,k)$，且总满足 $i+k=2·j$ ，现在对于任意的一个状态$(x,y,z)$ ， 定义三元函数 $dist(x,y,z) = (𝑖,𝑗,𝑘)$ 最少需要 $𝑑𝑖𝑠𝑡(𝑥,𝑦,𝑧)$ 次跃迁可以变成状态 $(𝑥,𝑦,𝑧)$ 。这位 民间科学爱好者同时声称，如果将一个量子一生中所有达到过的看作一个集合 S,那么 S 将 满足:</p><ol><li>$|S| = n$</li><li>$max(𝑑𝑖𝑠𝑡(𝑥,𝑦,𝑧)|(𝑥,𝑦,𝑧) ∈ 𝑆) = 𝑚$</li></ol><p>他想知道有多少种不同的集合 S 满足上述条件。</p><h3 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h3><p> 5 个以空格隔开的整数：i j k n m</p><h3 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h3><p>含一个整数，表示满足条件的集合 S 有多少种，为了方便起见，你只要输 出这个数字对 2016 取模的结果。</p><h3 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre>1 2 3 2 1</pre><pre>1 2 3 3 2</pre><h3 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre>2</pre><pre>4</pre><h3 id="Hint-3"><a href="#Hint-3" class="headerlink" title="Hint"></a>Hint</h3><p>对于 $30%$ 的测试数据 $n,m \leq 10$<br>对于 $50%$ 的测试数据 $m,n \leq 50$<br>对于 $100%$ 的测试数据 $m,n \leq 150$ ， $−50 \leq i,j,k \leq 50$</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>找点值代进去，发现其实每种状态 $(x,y,z)$ 都刚好会符合三种条件(除了$(x,y,z)$时等差数列的情况)，<strong>也就是说在任何时刻量子都可以跳跃到三种状态，其中有一种会与当前状态的上一状态重复</strong></p><p>那么一个初始状态 $(i,j,k)$ 的所有可到达的状态呈现一个<strong>完全二叉树</strong>形态，那就可以用树形DP了</p><p>首先题目要求状态集合中有 $n$ 种状态， 并且其中与初始状态 $dist$ 最大的为 $m$。<strong>也就是说要找到包含完全二叉树上 $n$ 个点的集合， 并且至少包含一个第 $m$ 层的点。</strong> 由于是完全二叉树，所以同一层的节点都是一样的，DP时枚举第几层就可以了</p><p>用 $f[i][j][0..1]$ 表示当前枚举到的结点处在第 $i$ 层，集合中已经有 $j$ 个结点， $0..1$ 表示是否可以到达第 $m$ 层<br>DP时从下往上枚举层数，每次从下一层转移过来 然后枚举集合中的总节点个数和左儿子集合中的点数就可以了</p><blockquote><p>发现其实 $i$ 这一维可以滚动掉，那就滚动一下呗</p></blockquote><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">2016</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][<span class="number">160</span>][<span class="number">2</span>],x,y,z,n,m,dep;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;x,&amp;y,&amp;z,&amp;n,&amp;m);</span><br><span class="line">    f[m&amp;<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=f[m&amp;<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        dep=i&amp;<span class="number">1</span>;  <span class="comment">//用于滚动数组</span></span><br><span class="line">        <span class="built_in">memset</span>(f[dep],<span class="number">0</span>,<span class="keyword">sizeof</span> f[dep]); <span class="comment">//滚动时记得初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;</span><br><span class="line">                (f[dep][j][<span class="number">0</span>]+=f[!dep][k][<span class="number">0</span>]*f[!dep][j-k<span class="number">-1</span>][<span class="number">0</span>])%=mod;</span><br><span class="line">                (f[dep][j][<span class="number">1</span>]+=f[!dep][k][<span class="number">1</span>]*f[!dep][j-k<span class="number">-1</span>][<span class="number">0</span>]%mod</span><br><span class="line">                            +f[!dep][k][<span class="number">1</span>]*f[!dep][j-k<span class="number">-1</span>][<span class="number">1</span>]%mod</span><br><span class="line">                            +f[!dep][k][<span class="number">0</span>]*f[!dep][j-k<span class="number">-1</span>][<span class="number">1</span>]%mod)%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        f[dep][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[<span class="number">0</span>][n][<span class="number">1</span>]);<span class="comment">//答案为根节点下状态数为n,且能到达第m层的方案数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="abcd"><a href="#abcd" class="headerlink" title="abcd"></a><center>abcd</center></h2><center><span id="inline-blue">时间限制：1s</span><span id="inline-yellow">空间限制：128MB</span></center><h3 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h3><p>有4个长度为$N$的数组$a,b,c,d$。现在需要你选择$N$个数构成数组$e$，数组 $e$ 满<br>足 $a_i \leq e_i \leq b_i$以及</p><script type="math/tex; mode=display">\Sigma_{i=1}^n e_i ∗ c_i=0</script><p>并且使得</p><script type="math/tex; mode=display">\Sigma_{i=1}^n e_i ∗ d_i</script><p>最大。</p><h3 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h3><p>输入文件名为$abcd.in$。<br>输入文件共 $N+1$ 行。<br>第 1 行包含1个正整数$N$。<br>第 $i+1$ 行包含4个整数 $a[i],b[i],c[i],d[i]$ 。</p><h3 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h3><p>输出文件名为 $abcd.out$ 。<br>输出共1行，包含1个整数，表示所给出公式的最大值。输入数据保证一定有<br>解。</p><h3 id="Sample-Input-5"><a href="#Sample-Input-5" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre>5-1 1 2 5-2 2 1 20 1 1 3-2 -1 3 10-2 2 3 9</pre><pre>101 10 1 7-10 10 2 0-10 10 2 2-10 10 2 01 10 1 0-10 10 2 010 10 2 01 10 1 0-10 10 2 0</pre><h3 id="Sample-Output-5"><a href="#Sample-Output-5" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre>2</pre><pre>90</pre><h3 id="Hint-4"><a href="#Hint-4" class="headerlink" title="Hint"></a>Hint</h3><p>对于 $100\%$ 的数据，$N\leq 200 , -25\leq a[i]&lt;b[i]\leq 25 , 1\leq c[i]\leq 20 , 0\leq p[i]\leq 100000$ 。</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>令 num[i]=e[i]-a[i] , 则 0≤num[i]≤b[i]-a[i] ，</p><script type="math/tex; mode=display">\Sigma e[i]*c[i]=\Sigma (num[i]+a[i])*c[i] = 0</script><script type="math/tex; mode=display">\Rightarrow \Sigma num[i]*c[i] = \Sigma (-a[i]*c[i])</script><p>需要求 <script type="math/tex">\Sigma e[i]*d[i] = \Sigma num[i]*d[i] + \Sigma a[i]*d[i]</script> 的最大值</p><p>所以 $b[i]-a[i]$ 是物品数量限制，num[i] 是 i 物品的选取数量，c[i] 是物品大小，$\Sigma (-a[i]*c[i])$ 是背包容量，$d[i]$ 是物品价值。原问题就变成了多重背包问题。</p><p>然后用单调队列优化一下就可以A掉此题</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">210</span>],b[<span class="number">210</span>],c[<span class="number">210</span>],d[<span class="number">210</span>],ans,n;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100010</span>],v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]),</span><br><span class="line">            v-=a[i]*c[i],ans+=a[i]*d[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=v;i++) f[i]=<span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k*c[i]&lt;=j&amp;&amp;k&lt;=b[i]-a[i];k++)</span><br><span class="line">                f[j]=max(f[j],f[j-c[i]*k]+d[i]*k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[v]+ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
放一些这段时间模拟赛的题&lt;br&gt;
似乎很多题我都忘记了？！？&lt;br&gt;
就当复习了  &lt;br&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="模拟赛" scheme="http://blog.southe3n.cf/categories/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>【网络流24题】太空飞行计划</title>
    <link href="http://blog.southe3n.cf/2018/07/27/wangluoliu24titaikongfeixingjihua/"/>
    <id>http://blog.southe3n.cf/2018/07/27/wangluoliu24titaikongfeixingjihua/</id>
    <published>2018-07-27T07:35:49.000Z</published>
    <updated>2018-10-21T05:49:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：最大权闭合子图  最小割<br>相关题目：<a href="https://www.luogu.org/problemnew/show/P2762" target="_blank" rel="noopener">$Luogu2762$</a><a href="hhttps://loj.ac/problem/6001" target="_blank" rel="noopener">$Loj6001$</a></div></blockquote><a id="more"></a><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>这道题是求一个<strong>最大权闭合子图</strong><br>然后可以转化为<strong>最小割</strong>问题，求一下<strong>最大流</strong>就可以了</p><blockquote><p>具体细节不谈</p></blockquote><p>比较麻烦的是如何<strong>求方案</strong><br><em>似乎有点难想</em><br>我们在残量网络中从源点沿着所有有残余容量的边遍历，<br>所有遍历到的点所代表的实验和器材都是要用到的</p><p>为什么这么做呢？<br>首先所有源点的有残余容量的出边所指向的实验肯定是要做的，<br>这样就会遍历到这些实验要用到的器材，<br>然后这些器材的一部分费用可能会由没有遍历到的实验的盈利承担<br>这时就会从这些器材的反向边遍历到那些实验，<br>那些实验需要的器材又会被遍历到</p><p>然后就如此反复反复咯，最后所有被遍历到的点都是需要的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>, ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ch!=<span class="string">'\r'</span>&amp;&amp;ch!=<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[<span class="number">1000</span>],nxt[<span class="number">1000</span>],head[<span class="number">200</span>],w[<span class="number">1000</span>],s,t,dep[<span class="number">200</span>],cunt[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> cur[<span class="number">200</span>],sum,maxflow,x,n,m,cnt=<span class="number">1</span>,a[<span class="number">600</span>],vis[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v,w[cnt]=val,</span><br><span class="line">    nxt[cnt]=head[u],head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    add(u,v,val),add(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> maxflow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) <span class="keyword">return</span> maxflow;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];i;i=nxt[i])&#123;</span><br><span class="line">        cur[u]=i;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&amp;&amp;dep[to[i]]+<span class="number">1</span>==dep[u])&#123;</span><br><span class="line">            <span class="keyword">int</span> now=dfs(to[i],min(w[i],maxflow-flow));</span><br><span class="line">            flow+=now;</span><br><span class="line">            w[i]-=now;</span><br><span class="line">            w[i^<span class="number">1</span>]+=now;</span><br><span class="line">            <span class="keyword">if</span>(maxflow==flow) <span class="keyword">return</span> flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur[u]=head[u];</span><br><span class="line">    <span class="keyword">if</span>(--cunt[dep[u]]==<span class="number">0</span>) dep[s]=n+m+<span class="number">2</span>;</span><br><span class="line">    cunt[++dep[u]]++;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">        <span class="keyword">if</span>(!vis[to[i]]&amp;&amp;w[i]) dfs(to[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n),read(m);</span><br><span class="line">    s=n+m+<span class="number">1</span>;</span><br><span class="line">    t=s+<span class="number">1</span>;cunt[<span class="number">0</span>]=t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        read(x),link(s,i,x),sum+=x; </span><br><span class="line">        <span class="keyword">while</span>(read(x)) link(i,x+n,<span class="number">2e9</span>);</span><br><span class="line">        link(i,x+n,<span class="number">2e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        read(a[i]),link(i+n,t,a[i]);</span><br><span class="line">    <span class="keyword">while</span>(dep[s]&lt;n+m+<span class="number">2</span>) </span><br><span class="line">        maxflow+=dfs(s,<span class="number">2e9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>,&amp;i);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n+m;i++)</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>,&amp;i-n);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum-maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：最大权闭合子图  最小割&lt;br&gt;
相关题目：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2762&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Luogu2762$&lt;/a&gt;
&lt;a href=&quot;hhttps://loj.ac/problem/6001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Loj6001$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="网络流" scheme="http://blog.southe3n.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>[NOI2018]归程</title>
    <link href="http://blog.southe3n.cf/2018/07/25/noi2018guicheng/"/>
    <id>http://blog.southe3n.cf/2018/07/25/noi2018guicheng/</id>
    <published>2018-07-25T08:27:39.000Z</published>
    <updated>2018-10-19T12:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词： $kruskal$重构树，倍增，最短路<br>相关题目：<a href="https://www.luogu.org/problemnew/show/P4768" target="_blank" rel="noopener">$Luogu4768$</a> <a href="https://loj.ac/problem/2718" target="_blank" rel="noopener">$Loj2718$</a></div></blockquote><a id="more"></a><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>首先题意要求<strong>出发点能到达的点中与1号点的最近距离</strong><br>那么我们先用 $dijstra$ 求出在原图中每个点与1号点的最短路</p><blockquote><p>至于为什么不用$spfa$。。。出题人语录——</p></blockquote><p><blockquote class="blockquote-center">关于SPFA，它死了</blockquote><br>【手动滑稽】</p><p>这个不谈，我们继续<br>那怎么找在某一水位与出发点连通的点有那些啊？<br>与出发点连通的要求是<strong>路径上所有边的海拔均高于$p$</strong></p><p>这个需要用到$kruskal$重构树,我们按照边的海拔从大到小排序，建立重构树<br>可以发现因为是<strong>小根堆</strong>，若根节点的权值大于$p$，则它的整颗子树在$p$的水位下都是连通的</p><p>我们可以用<strong>树上倍增</strong>来寻找权值大于$p$的深度最小的结点，<br>这样找出来的子树就是<strong>包含出发点的最大的联通块</strong></p><p>然后至于如何维护一个子树中 $dis$ 的最小值，写个$dfs$呗，顺便还可以把倍增的初始值赋了</p><div class="note success">总结一下<br>求最短路$\Rightarrow$建立$kruskal$重构树$\Rightarrow$<br>$dfs$维护子树最小$dis$$\Rightarrow$倍增求解</div><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">400010</span>,M=<span class="number">1010000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,m,to[M],head[M],nxt[M],w[M],cnt,vis[N];</span><br><span class="line"><span class="keyword">int</span> fa[N],f[N][<span class="number">21</span>],tot;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[N],sum[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p1</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,a;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> p1 &amp;x)<span class="keyword">const</span> &#123;<span class="keyword">return</span> a&gt;x.a;&#125;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pai_r</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,id;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> pai_r &amp;x)<span class="keyword">const</span>&#123;<span class="keyword">return</span> val&gt; x.val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>; <span class="keyword">int</span> f=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch<span class="number">-48</span>,ch=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;read(a),read(b);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b,<span class="keyword">int</span> &amp;c,<span class="keyword">int</span> &amp;d)</span></span>&#123;read(a,b),read(c,d);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clean_map</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head); cnt=<span class="number">0</span>;&#125;<span class="comment">//清零边表</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v,w[cnt]=l;</span><br><span class="line">    nxt[cnt]=head[u],head[u]=cnt;</span><br><span class="line">&#125;   <span class="comment">//原图加边</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v,nxt[cnt]=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;   <span class="comment">//Kruskal重构树加边</span></span><br><span class="line">priority_queue&lt;pai_r&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x7f</span>,<span class="keyword">sizeof</span> dis); dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    q.push(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.top().id; q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w[i])&#123;</span><br><span class="line">                dis[v]=dis[u]+w[i];</span><br><span class="line">                q.push(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=getf(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(e+<span class="number">1</span>,e+m+<span class="number">1</span>);</span><br><span class="line">    clean_map(); tot=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)&#123;</span><br><span class="line">        u=getf(e[i].u),v=getf(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        w[++tot]=e[i].a;</span><br><span class="line">        add(tot,u),add(u,tot);</span><br><span class="line">        add(v,tot),add(tot,v);</span><br><span class="line">        fa[u]=fa[v]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">    sum[u]=dis[u]; f[u][<span class="number">0</span>]=ff;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(to[i]==ff) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to[i],u);</span><br><span class="line">        sum[u]=min(sum[u],sum[to[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        read(n,m);</span><br><span class="line">        clean_map();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,l,a;i&lt;=m;i++)</span><br><span class="line">            read(u,v,l,a),add(u,v,l),add(v,u,l),e[i]=&#123;u,v,a&#125;;</span><br><span class="line">        dijstra();  <span class="comment">//求出最短路</span></span><br><span class="line">        kruskal();  <span class="comment">//建立Kruskal重构树确保小根堆的性质</span></span><br><span class="line">        dfs(tot,<span class="number">0</span>); <span class="comment">//寻找一棵子树中dis最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++)</span><br><span class="line">                f[j][i]=f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> q,k,s; <span class="keyword">long</span> <span class="keyword">long</span> lastans=<span class="number">0</span>;</span><br><span class="line">        read(q,k),read(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,v,p;i&lt;=q;i++)&#123;</span><br><span class="line">            read(v,p);</span><br><span class="line">            v=(v+k*lastans<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">            p=(p+k*lastans)%(s+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">                <span class="keyword">if</span>(w[f[v][i]]&gt;p) v=f[v][i];</span><br><span class="line">            <span class="comment">//倍增向上跳，寻找根结点权值大于p的最大的子树</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,lastans=sum[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词： $kruskal$重构树，倍增，最短路&lt;br&gt;
相关题目：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4768&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Luogu4768$&lt;/a&gt; &lt;a href=&quot;https://loj.ac/problem/2718&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Loj2718$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="Kruskal重构树" scheme="http://blog.southe3n.cf/tags/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"/>
    
      <category term="倍增" scheme="http://blog.southe3n.cf/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="最短路" scheme="http://blog.southe3n.cf/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】Kruskal重构树</title>
    <link href="http://blog.southe3n.cf/2018/07/22/xuexibijikruskalchonggoushu/"/>
    <id>http://blog.southe3n.cf/2018/07/22/xuexibijikruskalchonggoushu/</id>
    <published>2018-07-22T02:05:58.000Z</published>
    <updated>2018-10-19T12:56:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">最基本的用途就是维护<strong>连通图中路径权值的最值</strong>问题<br>相关题目：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3732" target="_blank" rel="noopener">$【BZOJ3732】Network$</a></div></blockquote><a id="more"></a><h4 id="主要思想"><a href="#主要思想" class="headerlink" title="-主要思想"></a><strong>-主要思想</strong></h4><p>本来对于一个连通图中的路径最值，我们采用的是建立最小生成树，<br>然后对两点在最小生成树中的路径暴力求最值或者用树剖加线段树的方法</p><p>但是这样要么慢，要么实现起来比较麻烦<br>这时候可以用到一种叫<strong>Kruskal重构树</strong>的算法</p><p>实现方式是在Kruskal连边时不直接连边，而是新建一个<strong>点权为该边边权</strong>的结点<br>将这条边的两个端点的整颗子树连到该节点上作为儿子，<br>各个子树的根用<strong>并查集</strong>维护一下就可以了</p><p>这样建出来的树具有一些性质：<br><span id="inline-toc">1.</span> 是一个大根堆（因为Kruskal连边时边权由小到大）<br><span id="inline-toc">2.</span> 原树和新树两点间路径上的边权/点权最大值相等<br>然后把性质1，2综合起来我们可以得到：<strong>原树上两点间边权最大值等于新树上两点的lca的点权</strong></p><p>利用这个性质就可以很方便的求<strong>路径最值</strong>了</p><p>下面是示意图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/07/22/PGmXEn.png" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure></p><div class="note warning">注意在新树中的圆点中的数字表示原树中的点的编号，<strong>它们是没有点权的</strong><br>而方点代表的就是<strong>新建的点</strong>，其中的数字表示的是其点权</div><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">31000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> u,v,w;&#125;e[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;x,<span class="keyword">const</span> node &amp;y)</span></span>&#123;<span class="keyword">return</span> x.w&lt;y.w;&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k,fa[N],to[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],head[N],cnt,val[N],tot;</span><br><span class="line"><span class="keyword">int</span> size[N],son[N],dep[N],top[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v,nxt[cnt]=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=getf(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    dep[u]=dep[ff]+<span class="number">1</span>;</span><br><span class="line">    fa[u]=ff;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==ff) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v,u);</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">        <span class="keyword">if</span>(size[v]&gt;size[son[u]]) son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> topp)</span></span>&#123;</span><br><span class="line">    top[u]=topp;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) dfs2(son[u],topp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">        <span class="keyword">if</span>(to[i]!=fa[u]&amp;&amp;to[i]!=son[u]) dfs2(to[i],to[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;i++) fa[i]=i;</span><br><span class="line">    tot=n;</span><br><span class="line">    sort(e+<span class="number">1</span>,e+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> fx=getf(e[i].u),fy=getf(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(fx==fy) <span class="keyword">continue</span>;</span><br><span class="line">        val[++tot]=e[i].w;</span><br><span class="line">        add(tot,fx),add(tot,fy);</span><br><span class="line">        fa[fx]=fa[fy]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(tot,<span class="number">0</span>),dfs2(tot,tot);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,val[lca(x,y)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
最基本的用途就是维护&lt;strong&gt;连通图中路径权值的最值&lt;/strong&gt;问题&lt;br&gt;
相关题目：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3732&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$【BZOJ3732】Network$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.southe3n.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Kruskal重构树" scheme="http://blog.southe3n.cf/tags/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题】餐巾计划问题</title>
    <link href="http://blog.southe3n.cf/2018/07/20/wangluoliu24ticanjinjihuawenti/"/>
    <id>http://blog.southe3n.cf/2018/07/20/wangluoliu24ticanjinjihuawenti/</id>
    <published>2018-07-20T09:31:00.000Z</published>
    <updated>2018-10-19T12:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：最小费用最大流<br>相关题目：<a href="https://www.luogu.org/problemnew/show/P1251" target="_blank" rel="noopener">$Luogu1251$</a></div></blockquote><a id="more"></a><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>这道题求的是规定状态下的最小费用，可以想到用费用流</p><p><strong>首先还是来讲如何建模</strong><del>（毕竟网络流也就是个建模。。）</del></p><p>首先考虑如何满足每天的餐巾数量这一最重要的限制条件，<br>可以想到从每一天向汇点连一条容量为$r[i]$（第 $i$ 天所需餐巾数量），费用为0</p><p>获取餐巾的方式有三种——<br><span id="inline-toc">1.</span> 以单价$a$买新的<br><span id="inline-toc">2.</span> 将旧餐巾以单价$c$送去快洗店，$b$天后才能用<br><span id="inline-toc">3.</span> 将旧餐巾以单价$e$送去快洗店，$d$天后才能用</p><p>我一开始是这么想的：<br>对于买新的，从源点向每天连一条容量$inf$费用为$a$的边<br>对于快洗店，从每天向$b$天后连一条容量$inf$费用$c$的边<br>对于快洗店，从每天向$d$天后连一条容量$inf$费用$e$的边<br>对于餐巾可以留着，从每天向第二天连一天容量$inf$费用0的边</p><div class="note warning"><strong>这样显然是错的</strong><br>这样建模没有分开旧餐巾和新餐巾，并不能保证送去洗的是否是用过的<br><del>新餐巾拿去洗岂不尬哉？</del></div><p>考虑<strong>拆点</strong>，<strong>把一天拆成旧餐巾和新餐巾两部分</strong>，分别用$A$和$B$表示</p><p>每天要用$r[i]$个餐巾，分别从$B$向汇点、从源点向$A$连容量$r[i]$费用0的边，表示用$r[i]$条新餐巾，产生$r[i]$条旧餐巾</p><p>对于三种获取餐巾方式，<br>买新的：从源点向$B$连一条容量$inf$费用$a$的边<br>快洗店：从当天的$A$向$b$天后的$B$连一条容量$inf$费用$c$的边<br>慢洗店：同快洗店</p><p>然后由于餐巾可以放着不管，从每天的$A$向第二天的$A$连容量$INF$费用0的边</p><p>就完了。。（主要还是一个拆点比较难想？）</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> E=<span class="number">210000</span>,N=<span class="number">4100</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,r[N],a,b,c,d,e,s,t;</span><br><span class="line"><span class="keyword">int</span> head[N],to[E],w[E],f[E],nxt[E],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> last[N],pre[N],maxflow[N],vis[N],q[E],he,tail;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[N],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val,<span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v,w[cnt]=val,f[cnt]=cost;</span><br><span class="line">    nxt[cnt]=head[u],head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val,<span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">    add(u,v,val,cost);</span><br><span class="line">    add(v,u,<span class="number">0</span>,-cost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis); dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(maxflow,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> maxflow);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis); vis[s]=<span class="number">1</span>;</span><br><span class="line">    he=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    q[++tail]=s;</span><br><span class="line">    <span class="keyword">while</span>(he&lt;=tail)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q[he]; he++;</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;<span class="number">0</span>&amp;&amp;dis[v]&gt;dis[u]+f[i])&#123;</span><br><span class="line">                pre[v]=u,last[v]=i;</span><br><span class="line">                dis[v]=dis[u]+f[i];</span><br><span class="line">                maxflow[v]=min(maxflow[u],w[i]);</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q[++tail]=v,vis[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;r[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e);</span><br><span class="line">    s=<span class="number">2</span>*n+<span class="number">1</span>,t=<span class="number">2</span>*n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        link(s,i,r[i],<span class="number">0</span>),link(s,i+n,<span class="number">2e9</span>,a),link(i+n,t,r[i],<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//产生的旧餐巾    新买餐巾           向汇点连边保证每天餐巾数量恰好为r[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        link(i,i+<span class="number">1</span>,<span class="number">2e9</span>,<span class="number">0</span>);    <span class="comment">//把旧餐巾留到第二天</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-b;i++)</span><br><span class="line">        link(i,i+b+n,<span class="number">2e9</span>,c);  <span class="comment">//快洗店</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-d;i++)</span><br><span class="line">        link(i,i+d+n,<span class="number">2e9</span>,e);  <span class="comment">//慢洗店</span></span><br><span class="line">    spfa();</span><br><span class="line">    <span class="keyword">while</span>(dis[t]&lt;<span class="number">1e9</span>)&#123;</span><br><span class="line">        ans+=dis[t]*maxflow[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=t;u!=s;u=pre[u])&#123;</span><br><span class="line">            w[last[u]]-=maxflow[t];</span><br><span class="line">            w[last[u]^<span class="number">1</span>]+=maxflow[t];</span><br><span class="line">        &#125;</span><br><span class="line">        spfa();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：最小费用最大流&lt;br&gt;
相关题目：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1251&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Luogu1251$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="网络流" scheme="http://blog.southe3n.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题】[CTSC1999]家园</title>
    <link href="http://blog.southe3n.cf/2018/07/19/wangluoliu24tictsc1999jiayuan/"/>
    <id>http://blog.southe3n.cf/2018/07/19/wangluoliu24tictsc1999jiayuan/</id>
    <published>2018-07-19T14:40:02.000Z</published>
    <updated>2018-10-19T12:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：网络最大流  枚举答案<br>相关题目：<a href="https://www.luogu.org/problemnew/show/P2754" target="_blank" rel="noopener">$Luogu2754$</a></div></blockquote><a id="more"></a><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Emmmm…这道题让我们求的是可行答案最小值，显然是单调的<br>这时候可以想到二分答案</p><p><strong>But！</strong> 其实这道题里面我们用逐个枚举答案可能会更好<br>为什么呢？</p><p><strong>先来看如何建模</strong></p><ul><li>由源点向每一个时刻的 地球 建一条容量INF的边</li><li>由每一个时刻的 月球 向汇点建一条容量为INF的边</li><li>然后由于可以在一个空间站等候<br>从每一个空间站的上一时刻向这一时刻的对应节点连一条容量为INF的边</li><li>然后考虑乘飞船如何转移，<br>就是从每一艘飞船的上一时刻所在的空间站向现在所处空间站连一条容量为<strong>h[i]</strong>的边</li></ul>  <div class="note warning">  注意注意！每一个空间站以及地球月球的不同时刻在建出来的模型中都是<strong>一个单独的结点</strong>  </div><p> 然后就是在图上跑一边最大流，最大流就是在当前时间内能运送多少人</p><p> 最后来解释一下为什么枚举答案反而会更快<br> 由于每一次答案变大时只需要加入一些边和一些节点，Dinic算法每次增广后构建出来的<strong>残量网络</strong>就可以得到充分利用，<br> 在上一时刻的残量网络的基础上继续往下做就行了。</p><blockquote><p>至于ISAP算法是不是也能这样“继承”我比较菜不太清楚。。</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,h[<span class="number">30</span>],r[<span class="number">30</span>],s[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> to[N],head[N],nxt[N],w[N],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> S,T,tot,id[<span class="number">30</span>],pre,now,maxflow,flow,dep[N],cur[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v,nxt[cnt]=head[u],</span><br><span class="line">    w[cnt]=flow,head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> maxflow)</span></span>&#123;</span><br><span class="line">    add(u,v,maxflow),add(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[N],he,tail;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span> dep);</span><br><span class="line">    he=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    q[++tail]=S,dep[S]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(he&lt;=tail)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q[he]; he++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">            <span class="keyword">if</span>(w[i]&amp;&amp;!dep[to[i]])&#123;</span><br><span class="line">                q[++tail]=to[i];</span><br><span class="line">                dep[to[i]]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(to[i]==T) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> maxflow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T) <span class="keyword">return</span> maxflow;</span><br><span class="line">    <span class="keyword">int</span> k,flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];i;i=nxt[i])&#123;</span><br><span class="line">        cur[u]=i;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&amp;&amp;dep[to[i]]==dep[u]+<span class="number">1</span>)&#123;</span><br><span class="line">            k=dinic(to[i],min(maxflow-flow,w[i]));</span><br><span class="line">            <span class="keyword">if</span>(!k) dep[to[i]]=<span class="number">0</span>;</span><br><span class="line">            w[i]-=k;</span><br><span class="line">            w[i^<span class="number">1</span>]+=k;</span><br><span class="line">            flow+=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur[u]=head[u];</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;h[i],&amp;r[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;r[i];j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;r[i];j++)</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="number">0</span>) s[i][j]=n+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i][j]==<span class="number">-1</span>) s[i][j]=n+<span class="number">2</span>;</span><br><span class="line">    S=<span class="number">1</span>,T=<span class="number">2</span>,tot=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ans=<span class="number">0</span>;ans&lt;=<span class="number">1000</span>;ans++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) id[i]=++tot;</span><br><span class="line">        link(S,id[n+<span class="number">1</span>],<span class="number">2e9</span>);</span><br><span class="line">        link(id[n+<span class="number">2</span>],T,<span class="number">2e9</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++)</span><br><span class="line">                link(id[i]-n<span class="number">-2</span>,id[i],<span class="number">2e9</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">                now=id[s[i][ans%r[i]]];</span><br><span class="line">                pre=id[s[i][(ans<span class="number">-1</span>)%r[i]]]-n<span class="number">-2</span>;</span><br><span class="line">                link(pre,now,h[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(bfs())</span><br><span class="line">            <span class="keyword">while</span>(flow=dinic(S,<span class="number">2e9</span>)) maxflow+=flow;</span><br><span class="line">        <span class="keyword">if</span>(maxflow&gt;=k) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans),<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS：其实我代码中判无解依据答案是否过大并不严谨，<br>最好还是用并查集维护连通性来判</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：网络最大流  枚举答案&lt;br&gt;
相关题目：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2754&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Luogu2754$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="网络流" scheme="http://blog.southe3n.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题】负载平衡问题</title>
    <link href="http://blog.southe3n.cf/2018/07/18/wangluoliu24tifuzaipinghengwenti/"/>
    <id>http://blog.southe3n.cf/2018/07/18/wangluoliu24tifuzaipinghengwenti/</id>
    <published>2018-07-18T09:31:22.000Z</published>
    <updated>2018-10-19T12:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：费用流  收支平衡 <br>相关题目：<a href="https://www.luogu.org/problemnew/show/P4016" target="_blank" rel="noopener">$Luogu4016$</a></div></blockquote><a id="more"></a><blockquote><p>说实在第一次写费用流，之前也只是听人口胡口胡用spfa转移之类的，写的丑请见谅</p></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>这道题让我们使所有仓库的货物都处于平均值，且要使搬运量最小，可以想到是一个<strong>费用流</strong></p><p>关建还是如何建模<br>首先如何保证所有仓库最后都处于平均值呢？<br>也就是说当网络达到最大流时，所有仓库都达到平均值<br>我们对每个仓库计算其与平均值的<strong>偏差</strong><br>若偏差为正，也就是有余，则<strong>从源点向其连一条容量为偏差值的边</strong><br>若偏差为负，即不足，就<strong>从这个仓库向汇点连一条容量为偏差值的相反数的边</strong><br>那么当<strong>这两种边都处于满流状态</strong>时，仓库中的货物数就符合平均值这个条件了</p><p>只能向相邻的两个仓库运输，那就对相邻的仓库连边，<br>为了达到上述的满流状态，显然相邻仓库所连的边容量为<strong>无限大</strong>，<br>因为<strong>货物总量不变，一定收支平衡</strong>，所以能保证满流</p><p>那么再来考虑费用单价<br>由于源点和汇点是虚构出来的点，它们的边费用自然为0<br>而相邻仓库之间搬运会产生代价，费用为1</p><p>这样最小费用最大流的结果就是答案了</p><blockquote><p>最后在罗嗦几句费用流的细节(其实是我自己写的时候有点小纠结的地方)<br>1、反边的费用为原费用的相反数<br>2、spfa转移的同时记录路径<br>3、转移时同时转移路径总费用和路径最大流量</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">2e9</span>,N=<span class="number">1100</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">110</span>],sum,s,t,head[<span class="number">110</span>],to[N],nxt[N],w[N],cnt=<span class="number">1</span>,ans;</span><br><span class="line"><span class="keyword">int</span> f[N],dis[<span class="number">110</span>],maxflow[<span class="number">110</span>],pre[<span class="number">110</span>],last[<span class="number">110</span>],vis[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val,<span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v; nxt[cnt]=head[u]; f[cnt]=cost;</span><br><span class="line">    w[cnt]=val; head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val,<span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">        <span class="comment">//依次为出点，入点，容量，费用单价</span></span><br><span class="line">    add(u,v,val,cost);</span><br><span class="line">    add(v,u,<span class="number">0</span>,-cost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">1100000</span>],l,r;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;   <span class="comment">//通过spfa转移状态</span></span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis); dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(maxflow,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> maxflow);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis); vis[s]=<span class="number">1</span>;</span><br><span class="line">    r=<span class="number">0</span>,l=<span class="number">1</span>; q[++r]=s;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q[l]; l++,vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+f[i]&amp;&amp;w[i])&#123;</span><br><span class="line">                dis[v]=dis[u]+f[i];</span><br><span class="line">                maxflow[v]=min(maxflow[u],w[i]);</span><br><span class="line">                pre[v]=u, last[v]=i;</span><br><span class="line">                    <span class="comment">//记录这条最小费用最大流的路径</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q[++r]=v,vis[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    s=n+<span class="number">1</span>,t=n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),sum+=a[i];</span><br><span class="line">    sum/=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]-sum&gt;<span class="number">0</span>) link(s,i,a[i]-sum,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]-sum&lt;<span class="number">0</span>) link(i,t,sum-a[i],<span class="number">0</span>);</span><br><span class="line">      <span class="comment">//对每一个仓库，若有余，则从源点向该点连边，若不足，则由该点向汇点连边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">        link(i,i<span class="number">-1</span>,inf,<span class="number">1</span>),link(i,i+<span class="number">1</span>,inf,<span class="number">1</span>);</span><br><span class="line">    link(<span class="number">1</span>,<span class="number">2</span>,inf,<span class="number">1</span>),link(<span class="number">1</span>,n,inf,<span class="number">1</span>);</span><br><span class="line">    link(n,n<span class="number">-1</span>,inf,<span class="number">1</span>),link(n,<span class="number">1</span>,inf,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//每一个仓库都可以向左右两个相邻的仓库运输，费用单价为一</span></span><br><span class="line">    spfa();</span><br><span class="line">    <span class="keyword">while</span>(dis[t]&lt;<span class="number">1e9</span>)&#123;</span><br><span class="line">        ans+=maxflow[t]*dis[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=t;u!=s;u=pre[u])&#123;</span><br><span class="line">            w[last[u]]-=maxflow[t];</span><br><span class="line">            w[last[u]^<span class="number">1</span>]+=maxflow[t];</span><br><span class="line">        &#125;</span><br><span class="line">        spfa();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：费用流  收支平衡 &lt;br&gt;
相关题目：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4016&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Luogu4016$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="网络流" scheme="http://blog.southe3n.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题】飞行员配对方案问题</title>
    <link href="http://blog.southe3n.cf/2018/07/17/wangluoliu24tifeixingyuanpeiduifanganwenti/"/>
    <id>http://blog.southe3n.cf/2018/07/17/wangluoliu24tifeixingyuanpeiduifanganwenti/</id>
    <published>2018-07-17T13:39:40.000Z</published>
    <updated>2018-10-19T12:56:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：网络最大流  二分图最大匹配 <br>相关题目：<a href="https://www.luogu.org/problemnew/show/P2756" target="_blank" rel="noopener">$Luogu2756$</a></div></blockquote><a id="more"></a><blockquote><p>题面就不放了。。可以直接去洛谷看</p></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>其实是一个二分图最大匹配，但是毕竟是网络流24题，那就用网络流来做呗~<br>建图的主要方法是添加源点 $s$ 和汇点 $t$<br>由源点向二分图左部分点连容量为1的边，由右部分点向汇点也连容量为1的边<br>对于每一个可匹配的关系，在两点之间连一条边就可以了，容量可以为INF也可以为1</p><p>然后对这个图跑一边最大流，<strong>总流量就是最大匹配数</strong></p><p>注意这道题还需要我们输出一种<strong>方案</strong>，<br>那么我们枚举左部分各点的出边，若目标点在右部分而且残余容量为0，那么这就是一个匹配</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,head[<span class="number">110</span>],s,t,cnt=<span class="number">1</span>,to[<span class="number">11000</span>],nxt[<span class="number">11000</span>],w[<span class="number">11000</span>];</span><br><span class="line"><span class="keyword">int</span> cur[<span class="number">11000</span>],dep[<span class="number">300</span>],cunt[<span class="number">300</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v; nxt[cnt]=head[u];</span><br><span class="line">    head[u]=cnt; w[cnt]=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> maxflow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) <span class="keyword">return</span> maxflow;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];i;i=nxt[i])&#123;</span><br><span class="line">        cur[u]=i;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&amp;&amp;dep[to[i]]+<span class="number">1</span>==dep[u])&#123;</span><br><span class="line">            <span class="keyword">int</span> now=dfs(to[i],min(w[i],maxflow-flow));</span><br><span class="line">            flow+=now;</span><br><span class="line">            w[i]-=now;</span><br><span class="line">            w[i^<span class="number">1</span>]+=now;</span><br><span class="line">            <span class="keyword">if</span>(maxflow==flow) <span class="keyword">return</span> flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur[u]=head[u];</span><br><span class="line">    <span class="keyword">if</span>(--cunt[dep[u]]==<span class="number">0</span>) dep[s]=m+<span class="number">2</span>;</span><br><span class="line">    cunt[++dep[u]]++;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    s=m+<span class="number">1</span>,t=m+<span class="number">2</span>;</span><br><span class="line">    cunt[<span class="number">0</span>]=m+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        add(s,i,<span class="number">1</span>),add(i,s,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        add(i,t,<span class="number">1</span>),add(t,i,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">-1</span>)&#123;</span><br><span class="line">        add(x,y,<span class="number">1</span>);</span><br><span class="line">        add(y,x,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cur,<span class="number">0</span>,<span class="keyword">sizeof</span> cur);</span><br><span class="line">    <span class="keyword">while</span>(dep[s]&lt;m+<span class="number">2</span>)</span><br><span class="line">        ans+=dfs(s,<span class="number">1e9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];j;j=nxt[j])</span><br><span class="line">            <span class="keyword">if</span>(to[j]!=s&amp;&amp;to[j]!=t&amp;&amp;!w[j])</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,to[j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：网络最大流  二分图最大匹配 &lt;br&gt;
相关题目：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2756&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Luogu2756$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="网络流" scheme="http://blog.southe3n.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【学习计划】网络流24题</title>
    <link href="http://blog.southe3n.cf/2018/07/17/xuexijihuawangluoliu24ti/"/>
    <id>http://blog.southe3n.cf/2018/07/17/xuexijihuawangluoliu24ti/</id>
    <published>2018-07-17T13:31:55.000Z</published>
    <updated>2018-07-27T07:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Emmmm...<br>可能要做一做<strong>网络流24题</strong>？？<br><del>我怎么感觉不看题解我一道都做不出来啊喂？！</del><br>数学建模能力极差</blockquote><a id="more"></a><blockquote><p>下面放一放链接</p></blockquote><p><a href="/2018/07/17/【网络流24题】飞行员配对方案问题/">飞行员配对方案问题</a><br><a href="/2018/07/18/【网络流24题】负载平衡问题/">收支平衡问题</a><br><a href="/2018/07/19/【网络流24题】-CTSC1999-家园/">【CTSC1999】家园</a><br><a href="/2018/07/20/【网络流24题】%20餐巾计划问题/">餐巾计划问题</a><br><a href="/2018/07/27/【网络流24题】太空飞行计划/">太空飞行计划</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;
Emmmm...&lt;br&gt;
可能要做一做&lt;strong&gt;网络流24题&lt;/strong&gt;？？&lt;br&gt;
&lt;del&gt;我怎么感觉不看题解我一道都做不出来啊喂？！&lt;/del&gt;&lt;br&gt;
数学建模能力极差
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="网络流" scheme="http://blog.southe3n.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>NOIP模拟赛 Babystep</title>
    <link href="http://blog.southe3n.cf/2018/07/14/noipmonisaibabystep/"/>
    <id>http://blog.southe3n.cf/2018/07/14/noipmonisaibabystep/</id>
    <published>2018-07-14T11:03:47.000Z</published>
    <updated>2018-10-19T12:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：网格图  并查集  对偶图 </div></blockquote><a id="more"></a><h4 id="一句话题意"><a href="#一句话题意" class="headerlink" title="-一句话题意"></a><strong>-一句话题意</strong></h4><p>给出一个 $R\times R$ 的网格图$(R\leq 500)$ </p><p>进行$N(N\leq 2R^2-2R)$ 次操作</p><p>Baby 偶尔会炸掉网格图中的一条边 $(u, v)$。之后他会尝试从 $u$ 走到 $v$。 </p><p>如果他成功地从 $u$ 走到  $v$，他会很高兴；否则他会找人打架。 从第二次爆炸开始，根据 Baby 此时心情的不同，Baby 会炸掉不同的边。 你被要求编写一个程序，对于每次爆炸，给出此时 Baby 是否还能从 $u $ 到 $v$。 </p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="-输入格式"></a><strong>-输入格式</strong></h4><p>第一行，一个整数 $R$，代表网格图是 $R\times R$ 的。</p><p> 第二行，一个整数 $N$，代表操作数。 </p><p>第三行，四个整数 $x1,y1,x2,y2$，描述了第一次爆炸的边。 </p><p>以下 $N-1$ 行，每行四个整数 $x1,y1,x2,y2,x1’,y1’,x2’,y2’$，<br>分别描述 Baby 高兴时炸的边和 想找人打架时炸的边。 </p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre>2 2 1 1 1 21 1 2 1 1 2 2 2 </pre><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre>HAHA DAJIA </pre><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="-主要思路"></a><strong>-主要思路</strong></h4><p>首先要清楚什么是网格图<del>（其实是因为我本来并不知道。。。）</del><br>说白了就是点呈矩形，每个点向上下左右各点连边的一个图<del>及其不严谨</del><br>接下来我们定义各边所围成的区域为<strong>域</strong>  （如下图就是一个网格图，中间的大数字表示的就是域的编号，要注意<strong>整个网格图外</strong>也是一个域）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2018/07/14/PMJWeH.png" alt="PMJWeH.png" title="">                </div>                <div class="image-caption">PMJWeH.png</div>            </figure></p><p>对于这道题，由于是强制在线的，我们如果要用<strong>并查集</strong>维护连通性就必须要把原本的删边转化为连边<br>我们可以发现如果一条边两侧的域是连通的，再删边之后，边两端的点就不再连通了<br>那么就可以在每次操作时，判断边两侧的域是否连通，若连通，则输出”DAJIA”<br>否则将两个域连通，输出”HAHA”   <strong>这个连通性可以用并查集维护</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,R,fa[<span class="number">260000</span>],id[<span class="number">510</span>][<span class="number">510</span>],last,cnt,x[<span class="number">2</span>],xx[<span class="number">2</span>],y[<span class="number">2</span>],yy[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=getf(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getf(x)==getf(y)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[fa[x]]=fa[y],<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;R,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;R;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;R;j++)</span><br><span class="line">            id[i][j]=++cnt, fa[cnt]=cnt;</span><br><span class="line">    fa[++cnt]=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x[<span class="number">0</span>],&amp;y[<span class="number">0</span>],&amp;xx[<span class="number">0</span>],&amp;yy[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x[<span class="number">1</span>],&amp;y[<span class="number">1</span>],&amp;xx[<span class="number">1</span>],&amp;yy[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(x[last]==xx[last]) tmp=min(y[last],yy[last]),</span><br><span class="line">            last=merge(x[last]==<span class="number">1</span>?cnt:id[x[last]<span class="number">-1</span>][tmp],x[last]==R?cnt:id[x[last]][tmp]);</span><br><span class="line">        <span class="keyword">else</span> tmp=min(x[last], xx[last]), </span><br><span class="line">            last=merge(y[last]==<span class="number">1</span>?cnt:id[tmp][y[last]<span class="number">-1</span>],y[last]==R?cnt:id[tmp][y[last]]);</span><br><span class="line">        <span class="built_in">puts</span>(last?<span class="string">"DAJIA"</span>:<span class="string">"HAHA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：网格图  并查集  对偶图 
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="模拟赛" scheme="http://blog.southe3n.cf/categories/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    
    
      <category term="图论" scheme="http://blog.southe3n.cf/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="并查集" scheme="http://blog.southe3n.cf/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>NOIP十连测D8T1-神炎皇</title>
    <link href="http://blog.southe3n.cf/2018/07/09/noipshilianced8t1shenyanhuang/"/>
    <id>http://blog.southe3n.cf/2018/07/09/noipshilianced8t1shenyanhuang/</id>
    <published>2018-07-09T11:32:21.000Z</published>
    <updated>2018-10-21T05:54:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：数论  欧拉函数 <br>相关题目：发现题源BZOJ</div></blockquote><a id="more"></a><h4 id="一句话题意"><a href="#一句话题意" class="headerlink" title="-一句话题意"></a><strong>-一句话题意</strong></h4><p>求正整数对$(a,b)$ ，求满足 $a+b\leq n$  且 $a+b\mid ab$ 的数对个数</p><p>保证答案不超过$long~long$范围  $n\leq 10^{14}$</p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre>21</pre><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre>11</pre><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="-主要思路"></a><strong>-主要思路</strong></h4><p>设$gcd(a,b)=d$  , $x=\frac{a}{d}$，$y=\frac{b}{d}$</p><p>则有$(x+y)d=a+b$ 且$xyd^2=ab$</p><p>$\Rightarrow (x+y)d\mid xyd^2$  ，将 $d$ 约去，且由于 $x,y$ 互质，所以 $(x+y),xy$  互质</p><p>可以得到 $x+y\mid d$   所以 $x+y\leq d$ 又因为 $(x+y)d \leq n$</p><p>$\Rightarrow x+y\leq \sqrt{n}$ ，这样，我们就把时间复杂度降到了 $O(\sqrt{n})$ ,显然是符合要求的</p><p>那么我们再考虑每一个 $x+y$ 对答案的贡献，显然 $1\leq d\leq \frac{n}{x+y}$ ，又因为  $x+y\mid d$</p><p>所以 $d$ 有 $n/(x+y)/(x+y)$ 种取值</p><p>那么再来考虑 $x+y$ 有多少种方案，由于 $x,y$ 互质，所以 $x+y,x,y$相互互质，</p><p>因此其实方案数就是 $\phi(x+y)$</p><p>我们在 $1..\sqrt{n}$ 的范围内枚举 $x+y$ 的值</p><div class="note success">所以最终答案为$\Sigma_{i=1}^{\sqrt{n}} \phi(i)*n/i/i$</div><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,ans,m;</span><br><span class="line"><span class="keyword">int</span> euler[<span class="number">11000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) euler[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span>(euler[i]==i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i; j&lt;=n; j+=i)</span><br><span class="line">                euler[j]=euler[j]/i*(i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    m=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    Euler(m);  <span class="comment">//求sqrt(n)以内的欧拉函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">        ans+=euler[i]*(n/i/i);</span><br><span class="line">        <span class="comment">//将答案累加</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：数论  欧拉函数 &lt;br&gt;
相关题目：发现题源BZOJ
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="模拟赛" scheme="http://blog.southe3n.cf/categories/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    
    
      <category term="数论" scheme="http://blog.southe3n.cf/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[NOIP十连测D2T3]最近公共祖先</title>
    <link href="http://blog.southe3n.cf/2018/07/08/noipshilianced2t3zuijingonggongzuxian/"/>
    <id>http://blog.southe3n.cf/2018/07/08/noipshilianced2t3zuijingonggongzuxian/</id>
    <published>2018-07-08T10:39:42.000Z</published>
    <updated>2018-10-21T05:54:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：DFS序  线段树 <br>相关题目：似乎是内部OJ？</div></blockquote><a id="more"></a><h4 id="一句话题意"><a href="#一句话题意" class="headerlink" title="-一句话题意"></a><strong>-一句话题意</strong></h4><p>给出一颗以1为根结点，有$N(N \leq 100000)$个结点的树，初始所有结点都是白色的<br>现在要进行$M(M\leq 200000)$次操作，有以下两种：<br><span id="inline-toc">1.</span> $Modify~v$：将结点$v$的颜色修改为黑色<br><span id="inline-toc">2.</span> $Query~v$：找到一个黑色结点 $u$ ,使得$u$和$v$的最近公共祖先的权值<strong>尽可能大</strong>，输出最大权值，<br>若树中不存在黑色结点，输出-$1$</p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre>7 74 3 5 7 6 5 21 42 17 56 22 53 4Query 1Modify 2Modify 4Query 3Modify 2Modify 5Query 6</pre><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre>-174</pre><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="-主要思路"></a><strong>-主要思路</strong></h4><p>冷静分析一下，发现每个点被染黑的时候，所产生的贡献就是<strong>它与它的所有祖先</strong><br>也就是说一个点被涂黑后，它会使得它与它的祖先可以作为<strong>查询某些结点时的答案</strong><br>对于每一个祖先，带来的贡献是这个祖先的<strong>除包含涂黑结点的子树以外的所有其他子树</strong><br>这些子树中的每一个点都可以与这个被涂黑的点作出$LCA$即为这个祖先</p><p>但是，如果我们涂黑时对每一个能影响到的点的答案暴力修改，显然是不行的，<br>由于我们每一次修改修改的都是一整棵子树，我们可以想到<strong>$DFS$序+线段树</strong>，<br>来维护区间$MAX$值，也就是答案</p><p>然而如果每次涂黑对其每个祖先都修改，显然会被一条链卡掉<br>我们再进行<strong>慌张分析</strong>，发现其实如果一个点已经被作为祖先过了，那么就不用再继续往上上修改了</p><blockquote><p>具体的话<strong>画个图</strong>应该就可以理解了</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">110000</span>],to[<span class="number">210000</span>],nxt[<span class="number">210000</span>],cnt,tot;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">110000</span>],val[<span class="number">110000</span>],sum[<span class="number">110000</span>];</span><br><span class="line"><span class="keyword">int</span> ans,n,m,v,size[<span class="number">110000</span>],dfn[<span class="number">110000</span>];</span><br><span class="line"><span class="keyword">int</span> maxn[<span class="number">410000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v;</span><br><span class="line">    nxt[cnt]=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//划分DFS序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">    fa[u]=ff;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    dfn[u]=++tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">        <span class="keyword">if</span>(to[i]!=ff)</span><br><span class="line">            dfs(to[i],u),size[u]+=size[to[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;maxn[u]=max(maxn[u],val);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) modify(u&lt;&lt;<span class="number">1</span>,l,mid,x,y,val);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) modify(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> maxn[u];</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> max(maxn[u],query(u&lt;&lt;<span class="number">1</span>,l,mid,x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max(maxn[u],query(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=====================线段树===================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> son)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">    modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[u],val[u]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">        <span class="keyword">if</span>(to[i]!=son&amp;&amp;to[i]!=fa[u])</span><br><span class="line">            modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[to[i]],dfn[to[i]]+size[to[i]]<span class="number">-1</span>,val[u]);</span><br><span class="line">    <span class="keyword">if</span>(sum[u]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果一个点已经做过祖先了，修改完这个点就不需要向上跳了</span></span><br><span class="line">    sum[u]=<span class="number">1</span>;   <span class="comment">//标记作为祖先</span></span><br><span class="line">    update(fa[u],u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),add(x,y),add(y,x);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memset</span>(maxn,<span class="number">-1</span>,<span class="keyword">sizeof</span> maxn);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,opt,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[v]));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[v],dfn[v]+size[v]<span class="number">-1</span>,val[v]);</span><br><span class="line">            update(fa[v],v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：DFS序  线段树 &lt;br&gt;
相关题目：似乎是内部OJ？
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="模拟赛" scheme="http://blog.southe3n.cf/categories/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    
    
      <category term="线段树" scheme="http://blog.southe3n.cf/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="DFS序" scheme="http://blog.southe3n.cf/tags/DFS%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>[USACO07DEC]观光奶牛</title>
    <link href="http://blog.southe3n.cf/2018/07/05/usaco07decguanguangnainiu/"/>
    <id>http://blog.southe3n.cf/2018/07/05/usaco07decguanguangnainiu/</id>
    <published>2018-07-05T10:34:57.000Z</published>
    <updated>2018-10-19T12:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：二分答案  判负环<br>相关题目：<a href="https://www.luogu.org/problemnew/show/P2868" target="_blank" rel="noopener">$Luogu2868$</a></div></blockquote><a id="more"></a><h4 id="N句话题意"><a href="#N句话题意" class="headerlink" title="-N句话题意"></a><strong>-N句话题意</strong></h4><blockquote><p><del>懒得概括，直接拉题面。。</del>还是不偷懒了</p></blockquote><p>给出一张$L(L\leq 1000)$个点，$P(P\leq 5000)$条边的有向图<br>有点权和边权，要求找出一个环，使其 <strong>点权和/边权和</strong> 值最大</p><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="-主要思路"></a><strong>-主要思路</strong></h4><p>Emmmm我们设一个环的点权和为$sum(f[v])$,边权和$sum(t[e])$<br>答案$ans=max(sum(f[v])/sum(t[e]))$<br>移一下项 得$sum(ans·t[e])-sum(f[v])=0$<br>那么我们就可以对这个$ans$进行<strong>二分</strong>了<br>对于每一个$mid$建立一张<strong>新图</strong>，每条边的值$t_{new}[i]=t[i]·mid-f[to[i]]$<br>以每一个点为起点跑一遍$dfs$-$SPFA$判断有没有<strong>负环</strong>就可以了<br>如果有负环，那么当前$mid$就是可以达到的，$l=mid$<br>反之$r=mid$</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,to[<span class="number">5100</span>],nxt[<span class="number">5100</span>],head[<span class="number">1100</span>],w[<span class="number">5100</span>];</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">1100</span>],vis[<span class="number">1100</span>],cnt;</span><br><span class="line"><span class="keyword">double</span> wa[<span class="number">5100</span>],dis[<span class="number">1100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;   </span><br><span class="line">    vis[u]=<span class="number">1</span>;       </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(dis[v]&gt;dis[u]+wa[i]) &#123;</span><br><span class="line">            dis[v]=dis[u]+wa[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[v]||spfa(v)) &#123;vis[u]=<span class="number">0</span>;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u]=<span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v;</span><br><span class="line">    nxt[cnt]=head[u];</span><br><span class="line">    w[cnt]=val;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z),add(x,y,z);</span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">100007</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">0.000001</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> flg=<span class="number">0</span>;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) wa[i]=w[i]*mid-val[to[i]]; <span class="comment">//建新图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(spfa(i)) &#123;l=mid; flg=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!flg) r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：二分答案  判负环&lt;br&gt;
相关题目：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2868&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Luogu2868$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="图论" scheme="http://blog.southe3n.cf/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分答案" scheme="http://blog.southe3n.cf/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>[2018湖南省队集训]circular</title>
    <link href="http://blog.southe3n.cf/2018/06/28/2018hunanshengduijixuncircular/"/>
    <id>http://blog.southe3n.cf/2018/06/28/2018hunanshengduijixuncircular/</id>
    <published>2018-06-28T12:27:16.000Z</published>
    <updated>2018-10-19T12:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：贪心 分类讨论<br>相关题目：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5397" target="_blank" rel="noopener">$BZOJ5397$</a></div></blockquote><a id="more"></a><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="-写在前面"></a><strong>-写在前面</strong></h4><p>Emmmm…其实是模拟省选考试题，<br><del>我居然奇迹般地能A题了</del>？！</p><h4 id="一句话题意"><a href="#一句话题意" class="headerlink" title="-一句话题意"></a><strong>-一句话题意</strong></h4><p>他有一个长度为$M$的环,环上有$M$个等距离的点, 按顺时针顺序依次标号为$0,1,…,M−1$<br>环上有$N$个线段$(a_i,b_i)(1 \leq i \leq N)$,<br>需要注意的是$(a_i,b_i)$所指的线段是从点$a_i$顺时针延伸到$b_i$的线段<br>希望知道最多能选多少个<strong>不相交</strong>的线段, 注意线段的<strong>端点是允许重合</strong>的</p><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="-主要思路"></a><strong>-主要思路</strong></h4><p>很显然$b_i \leq a_i$的线段(即绕过$0$点的线段)最多只会被选一个<br>那么我们<strong>不考虑</strong>这样的线段，对所有$a_i \leq b_i$线段进行<strong>贪心</strong><br>这时候我们得到一个贪心出来的答案<br>这时候再来考虑绕过$0$点的线段，显然这最多只会使答案+$1$<br>因此在这些线段中选取一个$b_i$最小且在当前贪心出来的线段的右端点之后的线段<br>以这个线段为起点再进行一次贪心，最后选取这两种情况中答案大的那个即可</p><div class="note success">具体的贪心策略就是将所有线段按右端点为第一关键字，左端点为第二关键字排序<br>优先选右端点越左且满足当前贪心到的最终右端点的线段</div><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> x,y;&#125;a[<span class="number">110000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.y==y.y?x.x&gt;y.x:x.y&lt;y.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,now,ans,ans1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"c.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"c.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">        <span class="keyword">if</span>(a[i].x&gt;a[i].y) a[i].y+=m;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i].x&gt;=now)</span><br><span class="line">            <span class="keyword">if</span>(a[i].y&lt;m) now=a[i].y,ans++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    now=a[i].y;ans++;</span><br><span class="line">                    tmp=i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="keyword">if</span>(now-m&gt;a[<span class="number">1</span>].x) ans--;</span><br><span class="line">    <span class="keyword">if</span>(!tmp) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans),<span class="number">0</span>;</span><br><span class="line">    ans1=<span class="number">1</span>;</span><br><span class="line">    now=a[tmp].y-m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i].x&gt;=now&amp;&amp;a[i].y&lt;=a[tmp].x)</span><br><span class="line">            now=a[i].y,ans1++;</span><br><span class="line">    <span class="keyword">if</span>(ans1&gt;ans) ans=ans1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：贪心 分类讨论&lt;br&gt;
相关题目：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=5397&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$BZOJ5397$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="贪心" scheme="http://blog.southe3n.cf/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>[CTSC2008]网络管理</title>
    <link href="http://blog.southe3n.cf/2018/06/26/ctsc2008wangluoguanli/"/>
    <id>http://blog.southe3n.cf/2018/06/26/ctsc2008wangluoguanli/</id>
    <published>2018-06-26T10:12:03.000Z</published>
    <updated>2018-10-19T12:57:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class="note info">关键词：带修主席树  树链剖分 <br>相关题目：<a href="https://www.luogu.org/problemnew/show/P4175" target="_blank" rel="noopener">$Luogu4175$</a> <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1146" target="_blank" rel="noopener">$BZOJ1146$</a></div></blockquote><a id="more"></a><h4 id="一句话题意"><a href="#一句话题意" class="headerlink" title="-一句话题意"></a><strong>-一句话题意</strong></h4><p>给出一棵树节点数为$N$，每个点有一个权值，要求支持两种操作：<br> <span id="inline-toc">1.</span>求结点$u$与$v$之间路径上第$k$大的权值<br> <span id="inline-toc">2.</span>修改某一结点上的权值<br>共$Q$次操作<br>数据范围:$N,Q\leq 80000$,权值$\leq 10^8$。</p><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="-主要思路"></a><strong>-主要思路</strong></h4><p>对于一棵树上的路径进行操作首先我们可以想到<strong>树链剖分</strong><br>而树链剖分需要一个可以维护<strong>区间信息</strong>的数据结构来辅助<br>那么对于动态区间第$K$大显然可以使用<strong>带修主席树</strong>的方法</p><p>我们首先将树进行剖分，<br>单点修改时修改每一棵包含点$u$的权值线段树<br>路径查询时先利用树链剖分将路径分割为多条$dfs$序连续的重链<br>这就是我们所要查询的区间了，对所有在<strong>树状数组意义下包含在这些区间里</strong>的权值线段树进行查询，就可以求出这条路径上的第$K$大了</p><div class="note success">路径查询的具体实现<br>利用两个数组分别记录需要加上和减去的线段树的<strong>结点序号</strong><br>每一次判断当前所处权值区间的右子区间的权值总个数是否大于我们所求的$K$<br>若大于等于则说明所求权值在右区间，向右区间查询<br>若小于则$k$-=$rsize$,向左区间查询<br>注意在向下层区间查询时<strong>将两个数组所存的结点序号更新</strong> </div><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><span id="inline-green">代码</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">90000</span>;</span><br><span class="line"><span class="keyword">int</span> to[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],head[N],cnt,a[N],root[N],n,q;</span><br><span class="line"><span class="keyword">int</span> id[N],val[N],dep[N],size[N],fa[N],top[N],son[N],dfn;</span><br><span class="line"><span class="keyword">int</span> l1,l2,q1[N],q2[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++cnt]=v;</span><br><span class="line">    nxt[cnt]=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[ff]+<span class="number">1</span>;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    fa[u]=ff;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==ff) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v,u);</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">        <span class="keyword">if</span>(size[v]&gt;size[son[u]]) son[u]=v; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> topp)</span></span>&#123;</span><br><span class="line">    top[u]=topp;</span><br><span class="line">    id[u]=++dfn;</span><br><span class="line">    val[dfn]=a[u];</span><br><span class="line">    <span class="keyword">if</span>(son[u]) dfs2(son[u],topp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">        <span class="keyword">if</span>(to[i]!=fa[u]&amp;&amp;to[i]!=son[u]) dfs2(to[i],to[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;     </span><br><span class="line">    l1=l2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=id[top[x]]<span class="number">-1</span>;i&gt;<span class="number">0</span>;i-=i&amp;-i) q1[++l1]=root[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=id[x];i&gt;<span class="number">0</span>;i-=i&amp;-i) q2[++l2]=root[i];</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=id[x]<span class="number">-1</span>;i&gt;<span class="number">0</span>;i-=i&amp;-i) q1[++l1]=root[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=id[y];i&gt;<span class="number">0</span>;i-=i&amp;-i) q2[++l2]=root[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============================树链剖分===========================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot,size[N&lt;&lt;<span class="number">8</span>],lson[N&lt;&lt;<span class="number">8</span>],rson[N&lt;&lt;<span class="number">8</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u=++cnt;         </span><br><span class="line">        size[u]+=value;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=mid) ins(lson[u],k,l,mid,value);</span><br><span class="line">            <span class="keyword">else</span> ins(rson[u],k,mid+<span class="number">1</span>,r,value); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> rsize=<span class="number">0</span>,mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l1;i++) rsize-=size[rson[q1[i]]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l2;i++) rsize+=size[rson[q2[i]]];</span><br><span class="line">            <span class="comment">//将所有有关权值线段树当前结点上的信息整合</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;rsize)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l1;i++) q1[i]=lson[q1[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l2;i++) q2[i]=lson[q2[i]];</span><br><span class="line">            <span class="keyword">return</span> query(l,mid,k-rsize);</span><br><span class="line">                <span class="comment">//向左区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l1;i++) q1[i]=rson[q1[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l2;i++) q2[i]=rson[q2[i]];</span><br><span class="line">            <span class="keyword">return</span> query(mid+<span class="number">1</span>,r,k);</span><br><span class="line">                <span class="comment">//向右区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="comment">//=============================带修主席树============================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),add(x,y),add(y,x); </span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=id[i];j&lt;=n;j+=j&amp;-j)</span><br><span class="line">            t.ins(root[j],val[id[i]],<span class="number">0</span>,<span class="number">1e8</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> k,x,y;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=id[x];i&lt;=n;i+=i&amp;-i)</span><br><span class="line">                t.ins(root[i],val[id[x]],<span class="number">0</span>,<span class="number">1e8</span>,<span class="number">-1</span>),</span><br><span class="line">                t.ins(root[i],y,<span class="number">0</span>,<span class="number">1e8</span>,<span class="number">1</span>);</span><br><span class="line">            val[id[x]]=y;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            query(x,y);</span><br><span class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l1;i++) tmp-=t.size[q1[i]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l2;i++) tmp+=t.size[q2[i]];</span><br><span class="line">            <span class="keyword">if</span>(tmp&lt;k) &#123;<span class="built_in">puts</span>(<span class="string">"invalid request!"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t.query(<span class="number">0</span>,<span class="number">1e8</span>,k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS:我居然做完这道题才明白第$K$大和第$K$小的正确意义？！-_-</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;
关键词：带修主席树  树链剖分 &lt;br&gt;
相关题目：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4175&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$Luogu4175$&lt;/a&gt; &lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1146&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$BZOJ1146$&lt;/a&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常" scheme="http://blog.southe3n.cf/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="主席树" scheme="http://blog.southe3n.cf/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="树剖" scheme="http://blog.southe3n.cf/tags/%E6%A0%91%E5%89%96/"/>
    
  </entry>
  
</feed>
