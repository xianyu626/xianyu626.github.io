[{"title":"CF1072记录贴","date":"2018-10-21T12:40:36.000Z","path":"2018/10/21/cf1072jilutie/","text":"这场CF打完心态有点崩…记录一下 （T2卡一小时 ， T3 FST了解一下？） 先扔个比赛链接 T1不管 T2Description T2题意是给两个长度为 $n-1(n\\leq 10^5)$ 的数列 $a,b$ ，值域 $0$~$3$ 要求构造一个数列 $t$ 满足： $a[i]=t[i]|t[i+1]$ $b[i]=t[i]\\&amp;t[i+1]$ 若无解则输出$NO$ Solution 其实是一个挺简单的DP，注意值域只有两位二进制 $f[i][j]$ 表示 $t$ 数组填到第 $i$ 个且 $t_i=j$ 是否可行，然后在转移的时候记录是从哪里转移过来的就好了。输出时从最后一位倒着找回去。 Code 123456789101112131415161718192021222324#include &lt;cstdio&gt;using namespace std;int n,a[101000],b[101000],f[101000][10],fa[101000][10];int ans[101000],res;int main(int argc, char const *argv[])&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(int i=1;i&lt;n;i++) scanf(\"%d\",&amp;b[i]); f[1][0]=f[1][1]=f[1][2]=f[1][3]=1; for(int i=2;i&lt;=n;i++) for(int j=0;j&lt;=3;j++) for(int k=0;k&lt;=3;k++) if((a[i-1]==(j|k))&amp;&amp;(b[i-1]==(j&amp;k))) if(f[i-1][k]) f[i][j]=1,fa[i][j]=k; res=0; while(!f[n][res]&amp;&amp;res&lt;=3) res++; if(res==4) return puts(\"NO\"),0; puts(\"YES\"); for(int i=n;i;i--) ans[i]=res,res=fa[i][res]; for(int i=1;i&lt;=n;i++) printf(\"%d \",ans[i]); return 0;&#125; T3Description 给两个数 $a,b\\le 10^9$ 要求构造两个数列，使其和分别小于等于 $a,b$ 且数列中的数两两不相同 使两数列长度和最大，给出方案 Solution 贪心一下，先将 $a+b$ 拆成 $1+2+…+x$ + $y(x&lt;y)$的形式 后用贪心地思想先将 $a$ 填完，再用剩下的数去填 $b$ Attention：$b$ 是有可能填不满的！！ 代码写的太乱，就不贴了 T4Description 给出一个 $n·n(n\\leq 2000)$ 的字母矩阵，从 $(1,1)$ 走到 $(n,n)$ ，只能向下或向右走，有 $k$ 次机会将一个格子上的字母改成 &#39;a&#39; 求一种走法使得路径所经过的字母串的字典序最小 Input 4 2 abcd bcde bcad bcde 5 3 bwwwz hrhdh sepsp sqfaf ajbvw Output aaabcde aaaepfafw Solution 首先因为是字典序，所以改前面比改后面优秀，先DP求出所有能在改 $k$ 次及以内走到的点使得路径上全部都是&#39;a&#39; 如下图，黑色的格子是改 $k$ 次能走到的最远的点 1 显然，在红线以前的格子一定不是最优的，所以我们从红线上的黑格子开始平行于对角线向 $(n,n)$ 推进，以到当前斜线为止答案最优的点向右和下拓展，打上标记，然后从下一条斜线打了标记的点中选出字母最小的点继续进行标记。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n,K,line,f[2010][2010];int able[2010][2010]; //标记前面的路径是最优的char g[2010][2010];string ans;int main(int argc, char const *argv[])&#123; scanf(\"%d%d\",&amp;n,&amp;K); for(int i=1;i&lt;=n;i++) scanf(\"%s\",g[i]+1); memset(f,0x3f,sizeof f); f[0][1]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) f[i][j]=min(f[i-1][j],f[i][j-1])+(g[i][j]!='a'); //求出到每个点的最小更改次数 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(f[i][j]&lt;=K)&#123; line=max(i+j-1,line); //找到最远的一条斜线 able[i+1][j]=able[i][j+1]=1; &#125; for(int i=1;i&lt;=line;i++) ans+='a'; able[1][1]=1; line++; int nowmin; while(line&lt;n*2)&#123; nowmin=1e9; for(int i=1,j;i&lt;=n;i++)&#123; j=line-i+1; if(j&lt;1||j&gt;n) continue; if(able[i][j]) nowmin=min(nowmin,(int)g[i][j]); &#125; ans+=nowmin; //找出每条斜线中的最小合法字母，计入答案 for(int i=1,j;i&lt;=n;i++)&#123; j=line-i+1; if(j&lt;0||j&gt;n) continue; if(nowmin==g[i][j]&amp;&amp;able[i][j]) able[i+1][j]=able[i][j+1]=1; &#125; line++; &#125; cout&lt;&lt;ans; return 0;&#125; 写在最后 T2刚看到没注意到值域只有两位二进制想了半天，看到了之后又想着贪心构造，一点都没想着要DP，菜菜菜 T3听同学讲的题意，不知道拆出来数列和可以不等于那个数，就挂了。。 T4最后二十多分钟其实应该要码的出来的，还是挂了，心有点乱 心态真的是个大问题，见的题也少，T2显然的DP愣是没看出来，后面心态就崩了 总而言之，菜是原罪","tags":[{"name":"贪心","slug":"贪心","permalink":"http://blog.southe3n.cf/tags/贪心/"},{"name":"DP","slug":"DP","permalink":"http://blog.southe3n.cf/tags/DP/"}]},{"title":"CF1060E [上下DP]","date":"2018-10-04T13:30:43.000Z","path":"2018/10/04/cf1060eshangxiadp/","text":"关键词：树形DP 上下DP 相关题目：$CF1060E$ 题意有一颗 $n(n\\leq 200000)$ 个点的树,边权均为1 若两个点在树上具有一个相同的相邻点，则在新图上建立一条链接这两点的边换句话说若$u$和$a$在树上有连边，$v$和$a$也有连边，则在新图上建立边$(u,v)$ 求在新图上所有点对之间的最短距离之和 Solution考虑每个点对*在原树和新图上的距离变化，设原树距离为$Len$ 若$Len$为偶数，则在路径上每两点之间都有一条新边，新距离为$\\frac{Len}{2}$若$Len$为奇数，则在路径上多了一个点要使用原树上的边，新距离为$\\frac{Len}{2}+1$ 因此，若我们可以知道以每个点为起点的到所有点的路径长度和，以及其中长度为奇数的路径的条数就可以统计答案了 考虑如何求这两个东西，想到树形DP但是普通的树形DP是从叶节点到一个固定的根统计答案的，而这里我们需要知道的是以每个点为根的答案 这时候就需要引入一个叫上下DP的东西 似乎是机房特供？向机房大佬低头！ 对每个点记录三个值 sum：以该点为起点的所有路径长度和 s1: 以该点为起点的长度为奇数的路径条数 s2: 以该点为起点的长度为偶数的路径条数 然后我们现在需要从一个点 $u$ 将答案转移掉另一个点 $v$，且它们在原树中有连边发现所有路径的长度变化都取决于边$(u,v)$是被包含进去了还是不再取了 到$v$点及其子树的点的路径变短了，到其余点的路径变长了，而路径长度的奇偶性则对换了一下1234sum[v]=sum[u]+size[u]-2*size[v];size[v]=size[u];s1[v]=s2[u];s2[v]=s1[u]; 那么事情就好办了将以每个点为根的答案累加，由于所有路径都被算了两次，最后再除以2就好了 依我个人的理解，上下DP就是在树上将以不同点为根的答案进行转移 在转移过程中只用考虑转移的这条边对答案的影响就好了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;const int N=210000;using namespace std;long long sum[N],ans;int s1[N],s2[N],size[N],n;int to[N&lt;&lt;1],nxt[N&lt;&lt;1],head[N],cnt;inline void add(int u,int v)&#123; to[++cnt]=v,nxt[cnt]=head[u]; head[u]=cnt;&#125;void dfs1(int u,int ff)&#123; size[u]=1; for(int i=head[u];i;i=nxt[i]) if(to[i]!=ff) &#123; dfs1(to[i],u); size[u]+=size[to[i]]; &#125;&#125;void dfs2(int u,int ff)&#123; s2[u]=1; for(int i=head[u],v=to[i];i;i=nxt[i],v=to[i])&#123; if(v==ff) continue; dfs2(v,u); sum[u]+=sum[v]+size[v]; s1[u]+=s2[v]; s2[u]+=s1[v]; &#125;&#125;void dfs3(int u,int ff)&#123; ans+=sum[u]+s1[u]; //先直接累加原值，到输出时直接/4 for(int i=head[u],v=to[i];i;i=nxt[i],v=to[i])&#123; if(v==ff) continue; sum[v]=sum[u]+size[u]-2*size[v]; size[v]=size[u]; s1[v]=s2[u]; s2[v]=s1[u]; dfs3(v,u); &#125;&#125;int main(int argc, char const *argv[])&#123; scanf(\"%d\",&amp;n); for(int i=1,x,y;i&lt;n;i++)&#123; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y), add(y,x); &#125; dfs1(1,0); //处理出子树大小 dfs2(1,0); //用树形DP算出以1为根时的答案 dfs3(1,0); //将答案转移到所有点上 printf(\"%lld\\n\",ans/4); return 0;&#125;","tags":[{"name":"DP","slug":"DP","permalink":"http://blog.southe3n.cf/tags/DP/"}]},{"title":"CF1058E","date":"2018-09-25T12:15:32.000Z","path":"2018/09/25/cf1058e/","text":"关键词：二进制 相关题目：$CF1058E$ 题意给定$n(n\\leq 300000)$个数，值域 $1 \\sim 1e18$定义操作为，将一个数转换成二进制后，可以将其变为任何与其1个数相同的数（位数不限） 求区间 $(l,r)$ 使区间内的数经任意操作后异或和为0的区间数 Solution首先发现数的具体值对答案没有影响，所以先把数处理成1的个数 易得1.一个区间内1个数和为偶数2.且1的个数的最大值不大于1个数和的话 这个区间就是合法的 首先考虑如果只有第一个条件怎么办维护三个前缀和：1的个数和，前缀和为奇数的个数和，前缀和为偶数的个数和 然后枚举一下左端点，用三个前缀和算一下当前左端点对答案的贡献就好了 等等？！似乎还有个条件2？？ 冷静分析 发现一个数1的个数最大只有63个，最少也有1个 似乎只要区间长度大于64，第二个条件就一定满足？ 那对于每一个左端点向右枚举一下右端点，单独算一下 直到区间长度大于64再用前面所说的前缀和算一下剩下的贡献就好了。 代码12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=300100;using namespace std;int n,a[N],sum[N],f[10][N];long long ans,x;int main(int argc, char const *argv[])&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%lld\",&amp;x); while(x) a[i]+=x&amp;1,x&gt;&gt;=1; &#125; for(int i=1;i&lt;=n;i++) &#123; sum[i]=sum[i-1]+a[i]; f[sum[i]&amp;1][i]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; f[0][i]+=f[0][i-1]; f[1][i]+=f[1][i-1]; &#125; for(int l=1,r,maxn;l&lt;=n;l++)&#123; maxn=a[l]; for(r=l+1;r&lt;=n&amp;&amp;r-l+1&lt;=64;r++)&#123; maxn=max(a[r],maxn); if((sum[r]-sum[l-1])%2==0&amp;&amp;maxn*2&lt;=(sum[r]-sum[l-1])) ans++; &#125; ans+=f[sum[l-1]&amp;1][n]-f[sum[l-1]&amp;1][r-1]; &#125; printf(\"%lld\\n\",ans); return 0;&#125;","tags":[]},{"title":"青蛙","date":"2018-09-24T01:15:09.000Z","path":"2018/09/24/qingwa/","text":"关键词：数学期望 调和级数 相关题目：$Luogu39825$ 同学私人题库里的一道题，数学期望入门题 题目描述现在有一只青蛙（Called ZBY!） 在第$n$个荷叶上，每一次等概率地跳到第1格~当前所在荷叶上求ZBY跳到第1个格子上的步数期望，保留8位小数 Solution我们用 f[i] 表示第i格跳到第1格的数学期望，则易得 f[i]=1+\\Sigma_{j=1}^i f[j]*\\frac{1}{i}变一下形 i*f[i]=i+\\Sigma_{j=1}^{i-1}f[j]+f[i]然后可得 (i-1)*f[i]=i+\\Sigma_{j=1}^{i-1}f[j](i-1)*f[i-1]=i-1+\\Sigma_{j=1}^{i-1}f[j]上下两个式子相减,我们会惊喜的发现 f[i]-f[i-1]=\\frac{1}{i-1}这样我们就得到了一个递推式 f[n]=f[2]+\\Sigma_{i=2}^{n-1}\\frac{1}{i}似乎后面这部分是个调和级数？调和级数 $\\Sigma_{i=1}^{n}\\frac{1}{i}$ 虽然是发散的，但是当n较大时,可以用 $ln(n)+欧拉常数$ 来求其近似前缀和 欧拉常数≈$0.5772156649015328606$$f[2]=2$ Code123456789101112#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;double ans;long long n;int main(int argc, char const *argv[])&#123; scanf(\"%lld\",&amp;n); if(n&lt;=1e6) for(int i=2;i&lt;n;i++) ans+=1/(double)i; else ans=log(n-1)-1+0.5772156649015328606; printf(\"%.8lf\\n\",2+ans); return 0;&#125;","tags":[{"name":"数学期望","slug":"数学期望","permalink":"http://blog.southe3n.cf/tags/数学期望/"}]},{"title":"【学习笔记】矩阵乘法","date":"2018-08-11T16:00:00.000Z","path":"2018/08/12/xuexibijijuzhenchengfa/","text":"其实是看到的一个我认为还算优美的矩阵乘法板子，贴一下备忘 12345678910111213141516171819202122232425struct matrix&#123; double m[101][101]; matrix(int flg=0)&#123; memset(m,0,sizeof m); if(flg) for(int i=0;i&lt;100;i++) m[i][i]=1; &#125;&#125;A;inline matrix operator * (const matrix &amp;A,const matrix &amp;B) &#123; matrix C(0); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++) for(int k=0;k&lt;m;k++) C.m[i][j]+=A.m[i][k]*B.m[k][j]; return C;&#125;inline matrix pow(int x)&#123; matrix B(1),C=A; while(x)&#123; if(x&amp;1) B=B*C; C=C*C; x&gt;&gt;=1; &#125; return B;&#125;","tags":[]},{"title":"2018暑期集训[7.26~8.10]","date":"2018-08-10T16:00:00.000Z","path":"2018/08/11/2018shuqijixun726810/","text":"放一些这段时间模拟赛的题 似乎很多题我都忘记了？！？ 就当复习了 完备匹配时间限制：2s空间限制：256MB Description有一个两边点集大小都是$n$的二分图。他本来是一个完全二分图（即把图中的顶点分成两个集合，使得第一个集合中的所有顶点都与第二个集合中的所有顶点相连）。 每条边都有一个边权。对一个匹配，在匹配中边的边权的总和为这个匹配的价值。但是由于某些原因，这个二分图中的$k$条边不见了。 他想知道现在这个二分图还有几种完备匹配（如果图的所有顶点都与某匹配中的一条边相关联，则称此匹配为完备匹配)方案，并且所有完备匹配的价值的总和是多少。 Input第一行，一个正整数$n$。 接下来有$n$行，每行$n$个整数，第$i$行第$j$个整数$w_{i,j}$，表示点$i$向另一个点集中的点$j$边的权值。注意点从$0$开始标号。 接下来一行，一个正整数$k$，表示有多少条边不见了。 接下来$k$行，每行两个整数$u,v$，表示点$u$向另一个点集中的点$v$边不见了。 Output一行两个整数，第一个数为完备匹配的个数，第二个数为所有完备匹配的价值总和，由于数字较大，请对$10^9+7$取模。 Sample Input 5 2 3 4 5 6 5 4 3 2 1 7 6 5 4 3 5 6 7 8 9 3 4 5 6 7 3 1 2 2 2 3 4 Sample Output60 1408 Hint对于$100%$的数据，$n\\leq 300$, $k\\leq 20$ , $0\\leq w_{i,j}\\leq 500$。 Solution这是一道要用到容斥原理的题 先考虑第一问。首先如果没有不可选的边，那么完备匹配数就是$n!$ 然后我们可以惊喜的地发现$k$非常的小，只有20，那么我们就可以对不可选地边进行 $2^k$ 次枚举，根据容斥原理，将奇数条不可选的边产生地方案数从总方案数中减去，将偶数条的方案数加上 那么这个方案数该怎么计算呢？假设我们现在枚举出$sum$条边，由于一共需要$n$条边，其中$sum$条边已经确定，那么方案数就是$(n-sum)!$ 第二问其实也是同样的道理，首先算出全部边可选的情况下的权值总和再将枚举出的边根据数量奇偶性在答案中加减，要注意的是在这个过程中不能有两条被选中的边有同一个顶点 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;using namespace std;const int mod=1e9+7;int n,K,g[310][310],sum[2][310],x[25],y[25],u[25],v[25],vis[2][310];long long jc[310],ans1,ans2,Sigma,tmp;void dfs(int k,int Sum,int sigma,int num)&#123; if(k==K+1) &#123; ans1+=(Sum&amp;1)?mod-jc[n-Sum]:jc[n-Sum]; if(ans1&gt;=mod) ans1%=mod; tmp=(sigma*jc[n-Sum-1]%mod+num*jc[n-Sum]%mod)%mod; ans2+=(Sum&amp;1)?mod-tmp:tmp; if(ans2&gt;=mod) ans2%=mod; return; &#125; dfs(k+1,Sum,sigma,num); if(vis[0][u[k]]||vis[1][v[k]]) return; x[Sum+1]=u[k]; y[Sum+1]=v[k]; sigma+=g[u[k]][v[k]]-sum[0][u[k]]-sum[1][v[k]]; vis[0][u[k]]=1; vis[1][v[k]]=1; for(int i=1;i&lt;=Sum;i++) sigma+=g[x[i]][v[k]]+g[u[k]][y[i]]; dfs(k+1,Sum+1,sigma,num+g[u[k]][v[k]]); vis[0][u[k]]=0; vis[1][v[k]]=0;&#125;int main(int argc, char const *argv[])&#123; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++) scanf(\"%d\",&amp;g[i][j]),sum[0][i]+=g[i][j],sum[1][j]+=g[i][j]; Sigma+=sum[0][i]; &#125; jc[0]=1; for(int i=1;i&lt;=n;i++) jc[i]=jc[i-1]*i%mod; scanf(\"%d\",&amp;K); for(int i=1;i&lt;=K;i++) scanf(\"%d%d\",&amp;u[i],&amp;v[i]); dfs(1,0,Sigma,0); printf(\"%lld %lld\\n\",ans1,ans2); return 0;&#125; 图书列表时间限制：1s空间限制：256MB Description现在小G作为图书管理员，他的第一份工作是重新安排一些图书。他得到了一张列表，每个表项具有以下格式：CATEGORY1/CATEGORY 2/…./CATEGORY n/BOOKNAME这表示图书BOOKNAME位于目录CATEGORY n下, 目录CATEGORY n 位于目录CATEGORY n-1下，目录CATEGORY n-1位于目录CATEGORY n-2下， 以此类推。也就是说，每个表项是由最后的一本图书，以及该图书所属的若干目录按照层级依次组成的。我们称CATEGORY1为一级目录，而CATEGORY 2为二级目录，以此类推。例如： MATH/GRAPH THEORY ART/HISTORY/JAPANESE HISTORY/JAPANESE ACIENT HISTORY ART/HISTORY/CHINESE HISTORY/THREE KINDOM/RESEARCHES ON LIUBEI ART/HISTORY/CHINESE HISTORY/CHINESE MORDEN HISTORY ART/HISTORY/CHINESE HISTORY/THREE KINDOM/RESEARCHES ON CAOCAO 小G认为这份列表很不容易阅读和查找，于是他决定按照以下规则制作一份新列表，用缩进来体现图书与目录之间的层级关系： n级目录之前有$4\\times (n-1)$个空格的缩进。 直接隶属于n级目录的图书前有$4\\times n$个空格的缩进。 直接隶属于目录X目录与图书按照字典序列在目录X之后，但所有目录位于所有图书之前。 所有一级目录按照字典序先后列出。 例如，上面的列表转化后将变为： ART HISTORY CHINESE HISTORY THREE KINDOM RESEARCHES ON CAOCAO RESEARCHES ON LIUBEI CHINESE MORDEN HISTORY JAPANESE HISTORY JAPANESE ACIENT HISTORY MATH GRAPH THEORY 请写一个程序帮助小G完成这项工作。 Input输入原列表，共包含不超过30本图书，以一个数字0结尾。每行列出一个表项，表项是一个由大写字母、数字、“/”和空格构成的字符串，长度不超过100。一本图书可能在列表中出现多次，但在转化后的列表中，它应该只出现一次。但是若同名的图书或目录若在不同的目录结构下，则认为他们是不相同的。换句话说，一个图书或目录由以它的名字为结尾的前缀唯一确定。 Output输出新列表。本试题采用逐字节比较，行末请勿输出多余空格，文末以恰好一个换行符结尾。 Sample Input B/A B/A B/B 0 A1/B1/B32/B7 A1/B/B2/B4/C5 A1/B1/B2/B6/C5 A1/B1/B2/B5 A1/B1/B2 A1/B1/B2/B1 A1/B3/B2 A3/B1 A0/A1 0 Sample Output B A B A0 A1 A1 B B2 B4 C5 B1 B2 B6 C5 B1 B5 B32 B7 B2 B3 B2 A3 B1 Solution模拟题，将每行数据读入后，先在整个字符串后面加上一个’/‘方便处理，每次到一个’/‘，将前面的一串字符取出，根据其是否在行末判断是目录还是书籍，并作标记,然后记录到子目录列表中，记录时注意判重复，只有在当前子目录中没有的名称才新建，否则直接进入已有的目录 对每一个目录我们用一个数组记录其子目录，最后会形成一个树形结构，注意，为了方便处理，我们可以将所有一级目录定为一个虚拟出来的根目录的子目录 将所有数据读完之后，将每一个子目录列表按照题目规定的顺序进行排序，然后从虚拟的根目录开始dfs按照顺序输出就可以了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;inline void read(string &amp;s)&#123; s.clear(); char ch=getchar(); while((ch&lt;'A'||ch&gt;'Z')&amp;&amp;(ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!=' ') ch=getchar(); while(ch!='\\n'&amp;&amp;ch!='\\r') s+=ch,ch=getchar();&#125;string s[1600],st,now;int fa,lens,flg,cnt,son[1600][100],isbook[1600],is;int cmp(const int &amp;x,const int &amp;y)&#123; return isbook[x]==isbook[y]?s[x]&lt;s[y]:isbook[x]&lt;isbook[y];&#125;void dfs(int u,int dep)&#123; if(u)&#123; for(int i=1;i&lt;=4*(dep-1);i++) putchar(' '); cout&lt;&lt;s[u]&lt;&lt;endl; &#125; for(int i=1;i&lt;=son[u][0];i++) dfs(son[u][i],dep+1);&#125;int main(int argc, char const *argv[])&#123; read(st); while(st[0]!='0'||st.length()&gt;1)&#123; st+='/'; lens=st.size(); now.clear(); fa=0; for(int i=0;i&lt;lens;i++)&#123; if(st[i]=='/')&#123; flg=is=0; if(i==lens-1) is=1; for(int j=1;j&lt;=son[fa][0];j++)&#123; if(s[son[fa][j]]==now&amp;&amp;is==isbook[son[fa][j]])&#123; fa=son[fa][j]; flg=1; break; &#125; &#125; if(flg) &#123;now.clear();continue;&#125; s[++cnt]=now; son[fa][++son[fa][0]]=cnt; isbook[cnt]=is; fa=cnt; now.clear(); continue; &#125; now+=st[i]; &#125; read(st); &#125; for(int i=0;i&lt;=cnt;i++) sort(son[i]+1,son[i]+son[i][0]+1,cmp); dfs(0,0); return 0;&#125; 量化交易时间限制：1s空间限制：128MB Description 由于原题面实在太罗嗦，笔者稍微简化了一下 给出$n$个数，表示$n$天中股票的价格，每天可以买进或卖出一股，也可以什么也不做求$n$天后的最大收益 Input每个测试点包含若干组数据，以EOF结尾。对于每组数据：第一行1个整数N。第二行N个正整数，相邻两个整数之间用1个空格隔开，表示每一天股票的价格。 Output对于每组数据，首先按样例所示的格式“Case #k:”输出该组数据的编号，然后输出一个整数，表示applepi最大能够获得的利润。 Sample Input 6 2 6 7 3 5 6 8 1 2 3 4 5 6 7 8 10 15831 47573 60015 51368 32460 34125 43074 75172 54014 93578 Sample Output Case #1: 8 Case #2: 16 Case #1: 161084 Hint对于$50%$的数据，$1\\leq N\\leq 1000$。对于$100%$的数据，$1\\leq N\\leq 100000$，股票价格不超过$100000$，每个测试点至多包含$5$组数据。 Solution 考场上想了半天贪心，最后还是只打了50分的暴力，结果发现只是自己的贪心姿势水平不够啊 我们先默认每天都是卖出的，然后维护一个堆，将每天的价格扔两个进去，既然要卖出，那自然得有相应的买入，也就是从堆中取出一个价格，每天将答案加上当天价格减去取出的价格。第$n$天后的答案就是输出 那么来证明一下这个贪心正确性 首先在贪心过程中一个卖出一定对应一个买入，并且每一时刻堆中的价格都是在该时刻以前的，是可以选择的。这样就符合了题意 那么为什么这样贪心最优呢？要理解若一天的价格没有从堆中取出，则该天的操作时卖出，若取出一次则是不操作，若取出两次则是买入 而每次买入都是以当前可选的最低价格买入的，答案自然最优了 要注意，由于C++的优先队列默认是大根堆，程序实现时压入的是价格的相反数，和描述不太一样 Code1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int x,T,n;long long ans;priority_queue&lt;int&gt;q;int main(int argc, char const *argv[])&#123; while(scanf(\"%d\",&amp;n)!=EOF)&#123; T++,ans=0; while(!q.empty()) q.pop(); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;x); q.push(-x),q.push(-x); ans+=x+q.top(); q.pop(); &#125; printf(\"Case #%d: %lld\\n\",T,ans); &#125; return 0;&#125; 小象和老鼠时间限制：1s空间限制：128MB Description 还是那句话，原题面好罗嗦啊，来zip一下 给定一个$n\\times m$的网格图，左上角为$(1,1)$ ，右下角为$(n,m)$ ，每个点上可能有若干只老鼠。 现在要从找出一条从左上角到右下角的路径，使沿途遇到的老鼠数量最少(“遇到”的定义是在路径上某一点的四联通快内，相同老鼠不重复计数)，走的时候只能向下或向右。 Input第一行包含两个用空格隔开的整数，$n$ 和 $m$。 接下来一个 $n \\times m$ 的矩阵表示动物园的地图。其中 a_{i,j} 表示第 i 行第 j 列上老鼠的数量。 若 $a_{i,j}=0$ 则表示当前位置上没有老鼠（$(1,1)$也可能存在老鼠）。 Output输出一个整数，表示路线最小的数量是多少。 Sample Input 3 9 0 0 1 0 0 0 0 0 1 1 1 1 1 1 1 0 1 0 1 0 0 1 0 0 1 0 0 Sample Output 9 Hint对于 $10%$ 的数据，$1\\leq N,M\\leq 5$。对于 $100%$ 的数据，$1\\leq N,M\\leq 1000$ ， $0\\leq A_{i,j}\\leq 100$。 Solution 一开始写了个记搜妄想能过，结果发现自己太天真了。。。还好DP并不难想 单独考虑每一步遇到的老鼠数量，发现只有上一步走之前所处的位置有可能与这一步走完后所处位置上遇到的老鼠有重复。 那么我们用 $f[0..1][i][j]$ 表示上一步是向下还是向右，$i,j$ 表示所处位置，这样 $f[0][i][j]$ 就从 $f[i-1][j]$ 两种状态转移过来， $f[1][i][j]$ 从 $f[i][j-1]$ 转移过来 注意初始值将 $f[0..1][1][1]$ 都赋成 $(1,1)$ 能看到的老鼠数 Code12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int n,m,a[1100][1100],f[2][1100][1100],tmp;int main(int argc, char const *argv[])&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(\"%d\",&amp;a[i][j]); memset(f,0x3f,sizeof f); f[0][1][1]=f[1][1][1]=a[1][1]+a[1][2]+a[2][1]; for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=m;j++)&#123; tmp=a[i][j-1]+a[i][j+1]+a[i-1][j]+a[i+1][j]; if(i==1&amp;&amp;j==1) continue; f[0][i][j]=tmp+min(f[0][i-1][j]-a[i-1][j],f[1][i-1][j]-a[i-1][j]-a[i][j-1]); f[1][i][j]=tmp+min(f[0][i][j-1]-a[i][j-1]-a[i-1][j],f[1][i][j-1]-a[i][j-1]); &#125; printf(\"%d\\n\",min(f[0][n][m],f[1][n][m])); return 0;&#125; 量子模型 时间限制：1s空间限制：128MB Description小 W 所在学校的物理学水平全国闻名，因此吸引来了大量民间科学爱好者。某一天， 一位自称能做出诺贝尔奖级别成果，颠覆人类物理学框架的民间科学爱好者拦住了小 W， 和小 W 分享了一种小 W 闻所未闻的量子模型： 一个量子的状态可以用一个有序三元组来表示，如果该量子的状态是$(x,y,z)$，则能够发生如下六种之一的跃迁，转移到另一个状态（如果原状态$(x,y,z)$满足这种跃迁发生的前提条件的话）。 前提条件 跃迁后状态 $z &lt; min(2y-x,x)$ 或者 $z &gt; max(2y-x,x)$ $(2y-x,y,z)$ $z &lt; min(2x-y,y)$ 或者 $z &gt; max(2x-y,y)$ $(x,2x-y,z)$ $y &lt; min(2z-x,x)$ 或者 $y &gt; max(2z-x,x)$ $(2z-x,y,z)$ $y &lt; min(2x-z,z)$ 或者 $y &gt; max(2x-z,z)$ $(x,y,2x-z)$ $x &lt; min(2y-z,z)$ 或者 $x &gt; max(2y-z,z)$ $(x,y,2y-z)$ $x &lt; min(2z-y,y)$ 或者 $x &gt; max(2z-y,y)$ $(x,2z-y,z)$ 所有的量子的初始状态都是$(i,j,k)$，且总满足 $i+k=2·j$ ，现在对于任意的一个状态$(x,y,z)$ ， 定义三元函数 $dist(x,y,z) = (𝑖,𝑗,𝑘)$ 最少需要 $𝑑𝑖𝑠𝑡(𝑥,𝑦,𝑧)$ 次跃迁可以变成状态 $(𝑥,𝑦,𝑧)$ 。这位 民间科学爱好者同时声称，如果将一个量子一生中所有达到过的看作一个集合 S,那么 S 将 满足: $|S| = n$ $max(𝑑𝑖𝑠𝑡(𝑥,𝑦,𝑧)|(𝑥,𝑦,𝑧) ∈ 𝑆) = 𝑚$ 他想知道有多少种不同的集合 S 满足上述条件。 Input 5 个以空格隔开的整数：i j k n m Output含一个整数，表示满足条件的集合 S 有多少种，为了方便起见，你只要输 出这个数字对 2016 取模的结果。 Sample Input 1 2 3 2 1 1 2 3 3 2 Sample Output 2 4 Hint对于 $30%$ 的测试数据 $n,m \\leq 10$对于 $50%$ 的测试数据 $m,n \\leq 50$对于 $100%$ 的测试数据 $m,n \\leq 150$ ， $−50 \\leq i,j,k \\leq 50$ Solution找点值代进去，发现其实每种状态 $(x,y,z)$ 都刚好会符合三种条件(除了$(x,y,z)$时等差数列的情况)，也就是说在任何时刻量子都可以跳跃到三种状态，其中有一种会与当前状态的上一状态重复 那么一个初始状态 $(i,j,k)$ 的所有可到达的状态呈现一个完全二叉树形态，那就可以用树形DP了 首先题目要求状态集合中有 $n$ 种状态， 并且其中与初始状态 $dist$ 最大的为 $m$。也就是说要找到包含完全二叉树上 $n$ 个点的集合， 并且至少包含一个第 $m$ 层的点。 由于是完全二叉树，所以同一层的节点都是一样的，DP时枚举第几层就可以了 用 $f[i][j][0..1]$ 表示当前枚举到的结点处在第 $i$ 层，集合中已经有 $j$ 个结点， $0..1$ 表示是否可以到达第 $m$ 层DP时从下往上枚举层数，每次从下一层转移过来 然后枚举集合中的总节点个数和左儿子集合中的点数就可以了 发现其实 $i$ 这一维可以滚动掉，那就滚动一下呗 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstring&gt;const int mod=2016;using namespace std;int f[2][160][2],x,y,z,n,m,dep;int main(int argc, char const *argv[])&#123; scanf(\"%d%d%d%d%d\",&amp;x,&amp;y,&amp;z,&amp;n,&amp;m); f[m&amp;1][1][1]=f[m&amp;1][0][0]=1; for(int i=m-1;i&gt;=0;i--)&#123; dep=i&amp;1; //用于滚动数组 memset(f[dep],0,sizeof f[dep]); //滚动时记得初始化 for(int j=0;j&lt;=n;j++) for(int k=0;k&lt;j;k++)&#123; (f[dep][j][0]+=f[!dep][k][0]*f[!dep][j-k-1][0])%=mod; (f[dep][j][1]+=f[!dep][k][1]*f[!dep][j-k-1][0]%mod +f[!dep][k][1]*f[!dep][j-k-1][1]%mod +f[!dep][k][0]*f[!dep][j-k-1][1]%mod)%=mod; &#125; f[dep][0][0]=1; &#125; printf(\"%d\\n\",f[0][n][1]);//答案为根节点下状态数为n,且能到达第m层的方案数 return 0;&#125; abcd时间限制：1s空间限制：128MB Description有4个长度为$N$的数组$a,b,c,d$。现在需要你选择$N$个数构成数组$e$，数组 $e$ 满足 $a_i \\leq e_i \\leq b_i$以及 \\Sigma_{i=1}^n e_i ∗ c_i=0并且使得 \\Sigma_{i=1}^n e_i ∗ d_i最大。 Input输入文件名为$abcd.in$。输入文件共 $N+1$ 行。第 1 行包含1个正整数$N$。第 $i+1$ 行包含4个整数 $a[i],b[i],c[i],d[i]$ 。 Output输出文件名为 $abcd.out$ 。输出共1行，包含1个整数，表示所给出公式的最大值。输入数据保证一定有解。 Sample Input 5 -1 1 2 5 -2 2 1 2 0 1 1 3 -2 -1 3 10 -2 2 3 9 10 1 10 1 7 -10 10 2 0 -10 10 2 2 -10 10 2 0 1 10 1 0 -10 10 2 0 10 10 2 0 1 10 1 0 -10 10 2 0 Sample Output 2 90 Hint对于 $100\\%$ 的数据，$N\\leq 200 , -25\\leq a[i]&lt;b[i]\\leq 25 , 1\\leq c[i]\\leq 20 , 0\\leq p[i]\\leq 100000$ 。 Solution令 num[i]=e[i]-a[i] , 则 0≤num[i]≤b[i]-a[i] ， \\Sigma e[i]*c[i]=\\Sigma (num[i]+a[i])*c[i] = 0\\Rightarrow \\Sigma num[i]*c[i] = \\Sigma (-a[i]*c[i])需要求 \\Sigma e[i]*d[i] = \\Sigma num[i]*d[i] + \\Sigma a[i]*d[i] 的最大值 所以 $b[i]-a[i]$ 是物品数量限制，num[i] 是 i 物品的选取数量，c[i] 是物品大小，$\\Sigma (-a[i]*c[i])$ 是背包容量，$d[i]$ 是物品价值。原问题就变成了多重背包问题。 然后用单调队列优化一下就可以A掉此题 Code123456789101112131415161718#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int a[210],b[210],c[210],d[210],ans,n;int f[100010],v;int main(int argc, char const *argv[])&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d%d%d\",&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]), v-=a[i]*c[i],ans+=a[i]*d[i]; for(int i=1;i&lt;=v;i++) f[i]=-2e9; for(int i=1;i&lt;=n;i++) for(int j=v;j&gt;=0;j--) for(int k=0;k*c[i]&lt;=j&amp;&amp;k&lt;=b[i]-a[i];k++) f[j]=max(f[j],f[j-c[i]*k]+d[i]*k); printf(\"%d\\n\",f[v]+ans); return 0;&#125;","tags":[]},{"title":"【网络流24题】太空飞行计划","date":"2018-07-27T07:35:49.000Z","path":"2018/07/27/wangluoliu24titaikongfeixingjihua/","text":"关键词：最大权闭合子图 最小割 相关题目：$Luogu2762$ $Loj6001$ Solution这道题是求一个最大权闭合子图然后可以转化为最小割问题，求一下最大流就可以了 具体细节不谈 比较麻烦的是如何求方案似乎有点难想我们在残量网络中从源点沿着所有有残余容量的边遍历，所有遍历到的点所代表的实验和器材都是要用到的 为什么这么做呢？首先所有源点的有残余容量的出边所指向的实验肯定是要做的，这样就会遍历到这些实验要用到的器材，然后这些器材的一部分费用可能会由没有遍历到的实验的盈利承担这时就会从这些器材的反向边遍历到那些实验，那些实验需要的器材又会被遍历到 然后就如此反复反复咯，最后所有被遍历到的点都是需要的 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;algorithm&gt;using namespace std;inline int read(int &amp;x)&#123; x=0; int f=1; char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48, ch=getchar(); return ch!='\\r'&amp;&amp;ch!='\\n';&#125;int to[1000],nxt[1000],head[200],w[1000],s,t,dep[200],cunt[200];int cur[200],sum,maxflow,x,n,m,cnt=1,a[600],vis[110];inline void add(int u,int v,int val)&#123; to[++cnt]=v,w[cnt]=val, nxt[cnt]=head[u],head[u]=cnt;&#125;inline void link(int u,int v,int val)&#123; add(u,v,val),add(v,u,0);&#125;int dfs(int u,int maxflow)&#123; if(u==t) return maxflow; int flow=0; for(int i=cur[u];i;i=nxt[i])&#123; cur[u]=i; if(w[i]&amp;&amp;dep[to[i]]+1==dep[u])&#123; int now=dfs(to[i],min(w[i],maxflow-flow)); flow+=now; w[i]-=now; w[i^1]+=now; if(maxflow==flow) return flow; &#125; &#125; cur[u]=head[u]; if(--cunt[dep[u]]==0) dep[s]=n+m+2; cunt[++dep[u]]++; return flow;&#125;void dfs(int u)&#123; vis[u]=1; for(int i=head[u];i;i=nxt[i]) if(!vis[to[i]]&amp;&amp;w[i]) dfs(to[i]);&#125;int main(int argc, char const *argv[])&#123; read(n),read(m); s=n+m+1; t=s+1;cunt[0]=t; for(int i=1;i&lt;=n;i++)&#123; read(x),link(s,i,x),sum+=x; while(read(x)) link(i,x+n,2e9); link(i,x+n,2e9); &#125; for(int i=1;i&lt;=m;i++) read(a[i]),link(i+n,t,a[i]); while(dep[s]&lt;n+m+2) maxflow+=dfs(s,2e9); for(int i=1;i&lt;=n;i++) if(vis[i]) printf(\"%d \",&amp;i); puts(\"\"); for(int i=n+1;i&lt;=n+m;i++) if(vis[i]) printf(\"%d \",&amp;i-n); puts(\"\"); printf(\"%d\\n\",sum-maxflow); return 0;&#125;","tags":[{"name":"网络流","slug":"网络流","permalink":"http://blog.southe3n.cf/tags/网络流/"}]},{"title":"[NOI2018]归程","date":"2018-07-25T08:27:39.000Z","path":"2018/07/25/noi2018guicheng/","text":"关键词： $kruskal$重构树，倍增，最短路 相关题目：$Luogu4768$ $Loj2718$ Solution首先题意要求出发点能到达的点中与1号点的最近距离那么我们先用 $dijstra$ 求出在原图中每个点与1号点的最短路 至于为什么不用$spfa$。。。出题人语录—— 关于SPFA，它死了 【手动滑稽】 这个不谈，我们继续那怎么找在某一水位与出发点连通的点有那些啊？与出发点连通的要求是路径上所有边的海拔均高于$p$ 这个需要用到$kruskal$重构树,我们按照边的海拔从大到小排序，建立重构树可以发现因为是小根堆，若根节点的权值大于$p$，则它的整颗子树在$p$的水位下都是连通的 我们可以用树上倍增来寻找权值大于$p$的深度最小的结点，这样找出来的子树就是包含出发点的最大的联通块 然后至于如何维护一个子树中 $dis$ 的最小值，写个$dfs$呗，顺便还可以把倍增的初始值赋了 总结一下 求最短路$\\Rightarrow$建立$kruskal$重构树$\\Rightarrow$ $dfs$维护子树最小$dis$$\\Rightarrow$倍增求解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;ctype.h&gt;const int N=400010,M=1010000;using namespace std;int T,n,m,to[M],head[M],nxt[M],w[M],cnt,vis[N];int fa[N],f[N][21],tot;long long dis[N],sum[N];struct p1&#123; int u,v,a; inline bool operator &lt;(const p1 &amp;x)const &#123;return a&gt;x.a;&#125;&#125;e[N&lt;&lt;1];struct pai_r&#123; int val,id; inline bool operator &lt;(const pai_r &amp;x)const&#123;return val&gt; x.val;&#125;&#125;;inline void read(int &amp;x)&#123; x=0; int f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1;ch=getchar();&#125; while(isdigit(ch)) x=x*10+ch-48,ch=getchar(); x*=f;&#125;inline void read(int &amp;a,int &amp;b)&#123;read(a),read(b);&#125;inline void read(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;read(a,b),read(c,d);&#125;inline void clean_map()&#123;memset(head,0,sizeof head); cnt=0;&#125;//清零边表inline void add(int u,int v,int l)&#123; to[++cnt]=v,w[cnt]=l; nxt[cnt]=head[u],head[u]=cnt;&#125; //原图加边inline void add(int u,int v)&#123; to[++cnt]=v,nxt[cnt]=head[u]; head[u]=cnt;&#125; //Kruskal重构树加边priority_queue&lt;pai_r&gt;q;inline void dijstra()&#123; memset(dis,0x7f,sizeof dis); dis[1]=0; memset(vis,0,sizeof vis); q.push(&#123;0,1&#125;); while(!q.empty())&#123; int u=q.top().id; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(dis[v]&gt;dis[u]+w[i])&#123; dis[v]=dis[u]+w[i]; q.push(&#123;dis[v],v&#125;); &#125; &#125; &#125;&#125;int getf(int x)&#123;return x==fa[x]?x:fa[x]=getf(fa[x]);&#125;inline void kruskal()&#123; sort(e+1,e+m+1); clean_map(); tot=n; for(int i=1;i&lt;=n*2;i++) fa[i]=i; for(int i=1,u,v;i&lt;=m;i++)&#123; u=getf(e[i].u),v=getf(e[i].v); if(u==v) continue; w[++tot]=e[i].a; add(tot,u),add(u,tot); add(v,tot),add(tot,v); fa[u]=fa[v]=tot; &#125;&#125;void dfs(int u,int ff)&#123; sum[u]=dis[u]; f[u][0]=ff; for(int i=head[u];i;i=nxt[i])&#123; if(to[i]==ff) continue; dfs(to[i],u); sum[u]=min(sum[u],sum[to[i]]); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf(\"%d\",&amp;T); while(T--)&#123; read(n,m); clean_map(); for(int i=1,u,v,l,a;i&lt;=m;i++) read(u,v,l,a),add(u,v,l),add(v,u,l),e[i]=&#123;u,v,a&#125;; dijstra(); //求出最短路 kruskal(); //建立Kruskal重构树确保小根堆的性质 dfs(tot,0); //寻找一棵子树中dis最小的点 for(int i=1;i&lt;=20;i++) for(int j=1;j&lt;=tot;j++) f[j][i]=f[f[j][i-1]][i-1]; int q,k,s; long long lastans=0; read(q,k),read(s); for(int i=1,v,p;i&lt;=q;i++)&#123; read(v,p); v=(v+k*lastans-1)%n+1; p=(p+k*lastans)%(s+1); for(int i=20;i&gt;=0;i--) if(w[f[v][i]]&gt;p) v=f[v][i]; //倍增向上跳，寻找根结点权值大于p的最大的子树 printf(\"%lld\\n\",lastans=sum[v]); &#125; &#125; return 0;&#125;","tags":[{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"http://blog.southe3n.cf/tags/Kruskal重构树/"},{"name":"倍增","slug":"倍增","permalink":"http://blog.southe3n.cf/tags/倍增/"},{"name":"最短路","slug":"最短路","permalink":"http://blog.southe3n.cf/tags/最短路/"}]},{"title":"【学习笔记】Kruskal重构树","date":"2018-07-22T02:05:58.000Z","path":"2018/07/22/xuexibijikruskalchonggoushu/","text":"最基本的用途就是维护连通图中路径权值的最值问题 相关题目：$【BZOJ3732】Network$ -主要思想本来对于一个连通图中的路径最值，我们采用的是建立最小生成树，然后对两点在最小生成树中的路径暴力求最值或者用树剖加线段树的方法 但是这样要么慢，要么实现起来比较麻烦这时候可以用到一种叫Kruskal重构树的算法 实现方式是在Kruskal连边时不直接连边，而是新建一个点权为该边边权的结点将这条边的两个端点的整颗子树连到该节点上作为儿子，各个子树的根用并查集维护一下就可以了 这样建出来的树具有一些性质：1. 是一个大根堆（因为Kruskal连边时边权由小到大）2. 原树和新树两点间路径上的边权/点权最大值相等然后把性质1，2综合起来我们可以得到：原树上两点间边权最大值等于新树上两点的lca的点权 利用这个性质就可以很方便的求路径最值了 下面是示意图 1 注意在新树中的圆点中的数字表示原树中的点的编号，它们是没有点权的 而方点代表的就是新建的点，其中的数字表示的是其点权 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N=31000;using namespace std;struct node&#123;int u,v,w;&#125;e[N];int cmp(const node &amp;x,const node &amp;y)&#123;return x.w&lt;y.w;&#125;int n,m,k,fa[N],to[N&lt;&lt;1],nxt[N&lt;&lt;1],head[N],cnt,val[N],tot;int size[N],son[N],dep[N],top[N];inline void add(int u,int v)&#123; to[++cnt]=v,nxt[cnt]=head[u]; head[u]=cnt;&#125;int getf(int x)&#123;return fa[x]==x?x:fa[x]=getf(fa[x]);&#125;void dfs1(int u,int ff)&#123; size[u]=1; dep[u]=dep[ff]+1; fa[u]=ff; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==ff) continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]]) son[u]=v; &#125;&#125;void dfs2(int u,int topp)&#123; top[u]=topp; if(son[u]) dfs2(son[u],topp); for(int i=head[u];i;i=nxt[i]) if(to[i]!=fa[u]&amp;&amp;to[i]!=son[u]) dfs2(to[i],to[i]);&#125;inline int lca(int u,int v)&#123; while(top[u]!=top[v])&#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); u=fa[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); return u;&#125;int main(int argc, char const *argv[]) &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); for(int i=1;i&lt;=2*n-1;i++) fa[i]=i; tot=n; sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=m;i++)&#123; int fx=getf(e[i].u),fy=getf(e[i].v); if(fx==fy) continue; val[++tot]=e[i].w; add(tot,fx),add(tot,fy); fa[fx]=fa[fy]=tot; &#125; dfs1(tot,0),dfs2(tot,tot); int x,y; while(k--)&#123; scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%d\\n\",val[lca(x,y)]); &#125; return 0;&#125;","tags":[{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"http://blog.southe3n.cf/tags/Kruskal重构树/"}]},{"title":"【网络流24题】餐巾计划问题","date":"2018-07-20T09:31:00.000Z","path":"2018/07/20/wangluoliu24ticanjinjihuawenti/","text":"关键词：最小费用最大流 相关题目：$Luogu1251$ Solution这道题求的是规定状态下的最小费用，可以想到用费用流 首先还是来讲如何建模（毕竟网络流也就是个建模。。） 首先考虑如何满足每天的餐巾数量这一最重要的限制条件，可以想到从每一天向汇点连一条容量为$r[i]$（第 $i$ 天所需餐巾数量），费用为0 获取餐巾的方式有三种——1. 以单价$a$买新的2. 将旧餐巾以单价$c$送去快洗店，$b$天后才能用3. 将旧餐巾以单价$e$送去快洗店，$d$天后才能用 我一开始是这么想的：对于买新的，从源点向每天连一条容量$inf$费用为$a$的边对于快洗店，从每天向$b$天后连一条容量$inf$费用$c$的边对于快洗店，从每天向$d$天后连一条容量$inf$费用$e$的边对于餐巾可以留着，从每天向第二天连一天容量$inf$费用0的边 这样显然是错的 这样建模没有分开旧餐巾和新餐巾，并不能保证送去洗的是否是用过的 新餐巾拿去洗岂不尬哉？ 考虑拆点，把一天拆成旧餐巾和新餐巾两部分，分别用$A$和$B$表示 每天要用$r[i]$个餐巾，分别从$B$向汇点、从源点向$A$连容量$r[i]$费用0的边，表示用$r[i]$条新餐巾，产生$r[i]$条旧餐巾 对于三种获取餐巾方式，买新的：从源点向$B$连一条容量$inf$费用$a$的边快洗店：从当天的$A$向$b$天后的$B$连一条容量$inf$费用$c$的边慢洗店：同快洗店 然后由于餐巾可以放着不管，从每天的$A$向第二天的$A$连容量$INF$费用0的边 就完了。。（主要还是一个拆点比较难想？） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int E=210000,N=4100;using namespace std;int n,r[N],a,b,c,d,e,s,t;int head[N],to[E],w[E],f[E],nxt[E],cnt=1;int last[N],pre[N],maxflow[N],vis[N],q[E],he,tail;long long dis[N],ans;inline void add(int u,int v,int val,int cost)&#123; to[++cnt]=v,w[cnt]=val,f[cnt]=cost; nxt[cnt]=head[u],head[u]=cnt;&#125;inline void link(int u,int v,int val,int cost)&#123; add(u,v,val,cost); add(v,u,0,-cost);&#125;inline void spfa()&#123; memset(dis,0x3f,sizeof dis); dis[s]=0; memset(maxflow,0x3f,sizeof maxflow); memset(vis,0,sizeof vis); vis[s]=1; he=1,tail=0; q[++tail]=s; while(he&lt;=tail)&#123; int u=q[he]; he++; vis[u]=0; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(w[i]&gt;0&amp;&amp;dis[v]&gt;dis[u]+f[i])&#123; pre[v]=u,last[v]=i; dis[v]=dis[u]+f[i]; maxflow[v]=min(maxflow[u],w[i]); if(!vis[v]) q[++tail]=v,vis[v]=1; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;r[i]); scanf(\"%d%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e); s=2*n+1,t=2*n+2; for(int i=1;i&lt;=n;i++) link(s,i,r[i],0),link(s,i+n,2e9,a),link(i+n,t,r[i],0); //产生的旧餐巾 新买餐巾 向汇点连边保证每天餐巾数量恰好为r[i] for(int i=1;i&lt;n;i++) link(i,i+1,2e9,0); //把旧餐巾留到第二天 for(int i=1;i&lt;=n-b;i++) link(i,i+b+n,2e9,c); //快洗店 for(int i=1;i&lt;=n-d;i++) link(i,i+d+n,2e9,e); //慢洗店 spfa(); while(dis[t]&lt;1e9)&#123; ans+=dis[t]*maxflow[t]; for(int u=t;u!=s;u=pre[u])&#123; w[last[u]]-=maxflow[t]; w[last[u]^1]+=maxflow[t]; &#125; spfa(); &#125; printf(\"%lld\\n\",ans); return 0;&#125;","tags":[{"name":"网络流","slug":"网络流","permalink":"http://blog.southe3n.cf/tags/网络流/"}]},{"title":"【网络流24题】[CTSC1999]家园","date":"2018-07-19T14:40:02.000Z","path":"2018/07/19/wangluoliu24tictsc1999jiayuan/","text":"关键词：网络最大流 枚举答案 相关题目：$Luogu2754$ SolutionEmmmm…这道题让我们求的是可行答案最小值，显然是单调的这时候可以想到二分答案 But！ 其实这道题里面我们用逐个枚举答案可能会更好为什么呢？ 先来看如何建模 由源点向每一个时刻的 地球 建一条容量INF的边 由每一个时刻的 月球 向汇点建一条容量为INF的边 然后由于可以在一个空间站等候从每一个空间站的上一时刻向这一时刻的对应节点连一条容量为INF的边 然后考虑乘飞船如何转移，就是从每一艘飞船的上一时刻所在的空间站向现在所处空间站连一条容量为h[i]的边 注意注意！每一个空间站以及地球月球的不同时刻在建出来的模型中都是一个单独的结点 然后就是在图上跑一边最大流，最大流就是在当前时间内能运送多少人 最后来解释一下为什么枚举答案反而会更快 由于每一次答案变大时只需要加入一些边和一些节点，Dinic算法每次增广后构建出来的残量网络就可以得到充分利用， 在上一时刻的残量网络的基础上继续往下做就行了。 至于ISAP算法是不是也能这样“继承”我比较菜不太清楚。。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int N=110000;using namespace std;int n,m,k,h[30],r[30],s[30][30];int to[N],head[N],nxt[N],w[N],cnt=1;int S,T,tot,id[30],pre,now,maxflow,flow,dep[N],cur[N];inline void add(int u,int v,int flow)&#123; to[++cnt]=v,nxt[cnt]=head[u], w[cnt]=flow,head[u]=cnt;&#125;inline void link(int u,int v,int maxflow)&#123; add(u,v,maxflow),add(v,u,0);&#125;int q[N],he,tail;inline int bfs()&#123; memset(dep,0,sizeof dep); he=1,tail=0; q[++tail]=S,dep[S]=1; while(he&lt;=tail)&#123; int u=q[he]; he++; for(int i=head[u];i;i=nxt[i]) if(w[i]&amp;&amp;!dep[to[i]])&#123; q[++tail]=to[i]; dep[to[i]]=dep[u]+1; if(to[i]==T) return 1; &#125; &#125; return 0;&#125;int dinic(int u,int maxflow)&#123; if(u==T) return maxflow; int k,flow=0; for(int i=cur[u];i;i=nxt[i])&#123; cur[u]=i; if(w[i]&amp;&amp;dep[to[i]]==dep[u]+1)&#123; k=dinic(to[i],min(maxflow-flow,w[i])); if(!k) dep[to[i]]=0; w[i]-=k; w[i^1]+=k; flow+=k; &#125; &#125; cur[u]=head[u]; return flow;&#125;int main(int argc, char const *argv[]) &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;h[i],&amp;r[i]); for(int j=0;j&lt;r[i];j++) scanf(\"%d\",&amp;s[i][j]); &#125; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;r[i];j++) if(s[i][j]==0) s[i][j]=n+1; else if(s[i][j]==-1) s[i][j]=n+2; S=1,T=2,tot=2; for(int ans=0;ans&lt;=1000;ans++)&#123; for(int i=1;i&lt;=n+2;i++) id[i]=++tot; link(S,id[n+1],2e9); link(id[n+2],T,2e9); if(ans!=0)&#123; for(int i=1;i&lt;=n+2;i++) link(id[i]-n-2,id[i],2e9); for(int i=1;i&lt;=m;i++)&#123; now=id[s[i][ans%r[i]]]; pre=id[s[i][(ans-1)%r[i]]]-n-2; link(pre,now,h[i]); &#125; &#125; while(bfs()) while(flow=dinic(S,2e9)) maxflow+=flow; if(maxflow&gt;=k) return printf(\"%d\\n\",ans),0; &#125; puts(\"0\"); return 0;&#125; PS：其实我代码中判无解依据答案是否过大并不严谨，最好还是用并查集维护连通性来判","tags":[{"name":"网络流","slug":"网络流","permalink":"http://blog.southe3n.cf/tags/网络流/"}]},{"title":"【网络流24题】负载平衡问题","date":"2018-07-18T09:31:22.000Z","path":"2018/07/18/wangluoliu24tifuzaipinghengwenti/","text":"关键词：费用流 收支平衡 相关题目：$Luogu4016$ 说实在第一次写费用流，之前也只是听人口胡口胡用spfa转移之类的，写的丑请见谅 Solution这道题让我们使所有仓库的货物都处于平均值，且要使搬运量最小，可以想到是一个费用流 关建还是如何建模首先如何保证所有仓库最后都处于平均值呢？也就是说当网络达到最大流时，所有仓库都达到平均值我们对每个仓库计算其与平均值的偏差若偏差为正，也就是有余，则从源点向其连一条容量为偏差值的边若偏差为负，即不足，就从这个仓库向汇点连一条容量为偏差值的相反数的边那么当这两种边都处于满流状态时，仓库中的货物数就符合平均值这个条件了 只能向相邻的两个仓库运输，那就对相邻的仓库连边，为了达到上述的满流状态，显然相邻仓库所连的边容量为无限大，因为货物总量不变，一定收支平衡，所以能保证满流 那么再来考虑费用单价由于源点和汇点是虚构出来的点，它们的边费用自然为0而相邻仓库之间搬运会产生代价，费用为1 这样最小费用最大流的结果就是答案了 最后在罗嗦几句费用流的细节(其实是我自己写的时候有点小纠结的地方)1、反边的费用为原费用的相反数2、spfa转移的同时记录路径3、转移时同时转移路径总费用和路径最大流量 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int inf=2e9,N=1100;int n,a[110],sum,s,t,head[110],to[N],nxt[N],w[N],cnt=1,ans;int f[N],dis[110],maxflow[110],pre[110],last[110],vis[110];inline void add(int u,int v,int val,int cost)&#123; to[++cnt]=v; nxt[cnt]=head[u]; f[cnt]=cost; w[cnt]=val; head[u]=cnt;&#125;inline void link(int u,int v,int val,int cost)&#123; //依次为出点，入点，容量，费用单价 add(u,v,val,cost); add(v,u,0,-cost);&#125;int q[1100000],l,r;inline void spfa()&#123; //通过spfa转移状态 memset(dis,0x3f,sizeof dis); dis[s]=0; memset(maxflow,0x3f,sizeof maxflow); memset(vis,0,sizeof vis); vis[s]=1; r=0,l=1; q[++r]=s; while(l&lt;=r)&#123; int u=q[l]; l++,vis[u]=0; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(dis[v]&gt;dis[u]+f[i]&amp;&amp;w[i])&#123; dis[v]=dis[u]+f[i]; maxflow[v]=min(maxflow[u],w[i]); pre[v]=u, last[v]=i; //记录这条最小费用最大流的路径 if(!vis[v]) q[++r]=v,vis[v]=1; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf(\"%d\",&amp;n); s=n+1,t=n+2; for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),sum+=a[i]; sum/=n; for(int i=1;i&lt;=n;i++) if(a[i]-sum&gt;0) link(s,i,a[i]-sum,0); else if(a[i]-sum&lt;0) link(i,t,sum-a[i],0); //对每一个仓库，若有余，则从源点向该点连边，若不足，则由该点向汇点连边 for(int i=2;i&lt;n;i++) link(i,i-1,inf,1),link(i,i+1,inf,1); link(1,2,inf,1),link(1,n,inf,1); link(n,n-1,inf,1),link(n,1,inf,1); //每一个仓库都可以向左右两个相邻的仓库运输，费用单价为一 spfa(); while(dis[t]&lt;1e9)&#123; ans+=maxflow[t]*dis[t]; for(int u=t;u!=s;u=pre[u])&#123; w[last[u]]-=maxflow[t]; w[last[u]^1]+=maxflow[t]; &#125; spfa(); &#125; printf(\"%d\\n\",ans); return 0;&#125;","tags":[{"name":"网络流","slug":"网络流","permalink":"http://blog.southe3n.cf/tags/网络流/"}]},{"title":"【网络流24题】飞行员配对方案问题","date":"2018-07-17T13:39:40.000Z","path":"2018/07/17/wangluoliu24tifeixingyuanpeiduifanganwenti/","text":"关键词：网络最大流 二分图最大匹配 相关题目：$Luogu2756$ 题面就不放了。。可以直接去洛谷看 Solution其实是一个二分图最大匹配，但是毕竟是网络流24题，那就用网络流来做呗~建图的主要方法是添加源点 $s$ 和汇点 $t$由源点向二分图左部分点连容量为1的边，由右部分点向汇点也连容量为1的边对于每一个可匹配的关系，在两点之间连一条边就可以了，容量可以为INF也可以为1 然后对这个图跑一边最大流，总流量就是最大匹配数 注意这道题还需要我们输出一种方案，那么我们枚举左部分各点的出边，若目标点在右部分而且残余容量为0，那么这就是一个匹配 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int n,m,x,y,head[110],s,t,cnt=1,to[11000],nxt[11000],w[11000];int cur[11000],dep[300],cunt[300],ans;inline void add(int u,int v,int val)&#123; to[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt; w[cnt]=val;&#125;int dfs(int u,int maxflow)&#123; if(u==t) return maxflow; int flow=0; for(int i=cur[u];i;i=nxt[i])&#123; cur[u]=i; if(w[i]&amp;&amp;dep[to[i]]+1==dep[u])&#123; int now=dfs(to[i],min(w[i],maxflow-flow)); flow+=now; w[i]-=now; w[i^1]+=now; if(maxflow==flow) return flow; &#125; &#125; cur[u]=head[u]; if(--cunt[dep[u]]==0) dep[s]=m+2; cunt[++dep[u]]++; return flow;&#125;int main(int argc, char const *argv[]) &#123; scanf(\"%d%d\",&amp;n,&amp;m); s=m+1,t=m+2; cunt[0]=m+2; for(int i=1;i&lt;=n;i++) add(s,i,1),add(i,s,0); for(int i=n+1;i&lt;=m;i++) add(i,t,1),add(t,i,0); scanf(\"%d%d\", &amp;x,&amp;y); while(x!=-1)&#123; add(x,y,1); add(y,x,0); scanf(\"%d%d\",&amp;x,&amp;y); &#125; memset(cur,0,sizeof cur); while(dep[s]&lt;m+2) ans+=dfs(s,1e9); printf(\"%d\\n\",ans); for(int i=1;i&lt;=n;i++) for(int j=head[i];j;j=nxt[j]) if(to[j]!=s&amp;&amp;to[j]!=t&amp;&amp;!w[j]) printf(\"%d %d\\n\",i,to[j]); return 0;&#125;","tags":[{"name":"网络流","slug":"网络流","permalink":"http://blog.southe3n.cf/tags/网络流/"}]},{"title":"【学习计划】网络流24题","date":"2018-07-17T13:31:55.000Z","path":"2018/07/17/xuexijihuawangluoliu24ti/","text":"Emmmm... 可能要做一做网络流24题？？ 我怎么感觉不看题解我一道都做不出来啊喂？！ 数学建模能力极差 下面放一放链接 飞行员配对方案问题收支平衡问题【CTSC1999】家园餐巾计划问题太空飞行计划","tags":[{"name":"网络流","slug":"网络流","permalink":"http://blog.southe3n.cf/tags/网络流/"}]},{"title":"NOIP模拟赛 Babystep","date":"2018-07-14T11:03:47.000Z","path":"2018/07/14/noipmonisaibabystep/","text":"关键词：网格图 并查集 对偶图 -一句话题意给出一个 $R\\times R$ 的网格图$(R\\leq 500)$ 进行$N(N\\leq 2R^2-2R)$ 次操作 Baby 偶尔会炸掉网格图中的一条边 $(u, v)$。之后他会尝试从 $u$ 走到 $v$。 如果他成功地从 $u$ 走到 $v$，他会很高兴；否则他会找人打架。 从第二次爆炸开始，根据 Baby 此时心情的不同，Baby 会炸掉不同的边。 你被要求编写一个程序，对于每次爆炸，给出此时 Baby 是否还能从 $u $ 到 $v$。 -输入格式第一行，一个整数 $R$，代表网格图是 $R\\times R$ 的。 第二行，一个整数 $N$，代表操作数。 第三行，四个整数 $x1,y1,x2,y2$，描述了第一次爆炸的边。 以下 $N-1$ 行，每行四个整数 $x1,y1,x2,y2,x1’,y1’,x2’,y2’$，分别描述 Baby 高兴时炸的边和 想找人打架时炸的边。 Sample Input 2 2 1 1 1 2 1 1 2 1 1 2 2 2 Sample Output HAHA DAJIA -主要思路首先要清楚什么是网格图（其实是因为我本来并不知道。。。）说白了就是点呈矩形，每个点向上下左右各点连边的一个图及其不严谨接下来我们定义各边所围成的区域为域 （如下图就是一个网格图，中间的大数字表示的就是域的编号，要注意整个网格图外也是一个域） PMJWeH.png 对于这道题，由于是强制在线的，我们如果要用并查集维护连通性就必须要把原本的删边转化为连边我们可以发现如果一条边两侧的域是连通的，再删边之后，边两端的点就不再连通了那么就可以在每次操作时，判断边两侧的域是否连通，若连通，则输出”DAJIA”否则将两个域连通，输出”HAHA” 这个连通性可以用并查集维护 代码123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int n,R,fa[260000],id[510][510],last,cnt,x[2],xx[2],y[2],yy[2];int getf(int x)&#123;return fa[x]==x?x:fa[x]=getf(fa[x]);&#125;inline int merge(int x, int y)&#123; if(getf(x)==getf(y)) return 1; else return fa[fa[x]]=fa[y],0;&#125;int main() &#123; scanf(\"%d%d\",&amp;R,&amp;n); for(int i=1;i&lt;R;i++) for(int j=1;j&lt;R;j++) id[i][j]=++cnt, fa[cnt]=cnt; fa[++cnt]=cnt; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d%d%d%d\",&amp;x[0],&amp;y[0],&amp;xx[0],&amp;yy[0]); if(i&gt;1) scanf(\"%d%d%d%d\",&amp;x[1],&amp;y[1],&amp;xx[1],&amp;yy[1]); int tmp; if(x[last]==xx[last]) tmp=min(y[last],yy[last]), last=merge(x[last]==1?cnt:id[x[last]-1][tmp],x[last]==R?cnt:id[x[last]][tmp]); else tmp=min(x[last], xx[last]), last=merge(y[last]==1?cnt:id[tmp][y[last]-1],y[last]==R?cnt:id[tmp][y[last]]); puts(last?\"DAJIA\":\"HAHA\"); &#125; return 0;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"http://blog.southe3n.cf/tags/图论/"},{"name":"并查集","slug":"并查集","permalink":"http://blog.southe3n.cf/tags/并查集/"}]},{"title":"NOIP十连测D8T1-神炎皇","date":"2018-07-09T11:32:21.000Z","path":"2018/07/09/noipshilianced8t1shenyanhuang/","text":"关键词：数论 欧拉函数 相关题目：发现题源BZOJ -一句话题意求正整数对$(a,b)$ ，求满足 $a+b\\leq n$ 且 $a+b\\mid ab$ 的数对个数 保证答案不超过$long~long$范围 $n\\leq 10^{14}$ Sample Input21 Sample Output11 -主要思路设$gcd(a,b)=d$ , $x=\\frac{a}{d}$，$y=\\frac{b}{d}$ 则有$(x+y)d=a+b$ 且$xyd^2=ab$ $\\Rightarrow (x+y)d\\mid xyd^2$ ，将 $d$ 约去，且由于 $x,y$ 互质，所以 $(x+y),xy$ 互质 可以得到 $x+y\\mid d$ 所以 $x+y\\leq d$ 又因为 $(x+y)d \\leq n$ $\\Rightarrow x+y\\leq \\sqrt{n}$ ，这样，我们就把时间复杂度降到了 $O(\\sqrt{n})$ ,显然是符合要求的 那么我们再考虑每一个 $x+y$ 对答案的贡献，显然 $1\\leq d\\leq \\frac{n}{x+y}$ ，又因为 $x+y\\mid d$ 所以 $d$ 有 $n/(x+y)/(x+y)$ 种取值 那么再来考虑 $x+y$ 有多少种方案，由于 $x,y$ 互质，所以 $x+y,x,y$相互互质， 因此其实方案数就是 $\\phi(x+y)$ 我们在 $1..\\sqrt{n}$ 的范围内枚举 $x+y$ 的值 所以最终答案为$\\Sigma_{i=1}^{\\sqrt{n}} \\phi(i)*n/i/i$ 代码12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;long long n,ans,m;int euler[11000000];void Euler(int n) &#123; for(register int i=1; i&lt;=n; i++) euler[i]=i; for(register int i=2; i&lt;=n; i++) if(euler[i]==i) for(register int j=i; j&lt;=n; j+=i) euler[j]=euler[j]/i*(i-1);&#125;int main(int argc, char const *argv[])&#123; scanf(\"%lld\",&amp;n); m=sqrt(n); Euler(m); //求sqrt(n)以内的欧拉函数 for(int i=2;i&lt;=m;i++) ans+=euler[i]*(n/i/i); //将答案累加 printf(\"%lld\\n\",ans); return 0;&#125;","tags":[{"name":"数论","slug":"数论","permalink":"http://blog.southe3n.cf/tags/数论/"}]},{"title":"[NOIP十连测D2T3]最近公共祖先","date":"2018-07-08T10:39:42.000Z","path":"2018/07/08/noipshilianced2t3zuijingonggongzuxian/","text":"关键词：DFS序 线段树 相关题目：似乎是内部OJ？ -一句话题意给出一颗以1为根结点，有$N(N \\leq 100000)$个结点的树，初始所有结点都是白色的现在要进行$M(M\\leq 200000)$次操作，有以下两种：1. $Modify~v$：将结点$v$的颜色修改为黑色2. $Query~v$：找到一个黑色结点 $u$ ,使得$u$和$v$的最近公共祖先的权值尽可能大，输出最大权值，若树中不存在黑色结点，输出-$1$ Sample Input 7 7 4 3 5 7 6 5 2 1 4 2 1 7 5 6 2 2 5 3 4 Query 1 Modify 2 Modify 4 Query 3 Modify 2 Modify 5 Query 6 Sample Output -1 7 4 -主要思路冷静分析一下，发现每个点被染黑的时候，所产生的贡献就是它与它的所有祖先也就是说一个点被涂黑后，它会使得它与它的祖先可以作为查询某些结点时的答案对于每一个祖先，带来的贡献是这个祖先的除包含涂黑结点的子树以外的所有其他子树这些子树中的每一个点都可以与这个被涂黑的点作出$LCA$即为这个祖先 但是，如果我们涂黑时对每一个能影响到的点的答案暴力修改，显然是不行的，由于我们每一次修改修改的都是一整棵子树，我们可以想到$DFS$序+线段树，来维护区间$MAX$值，也就是答案 然而如果每次涂黑对其每个祖先都修改，显然会被一条链卡掉我们再进行慌张分析，发现其实如果一个点已经被作为祖先过了，那么就不用再继续往上上修改了 具体的话画个图应该就可以理解了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int head[110000],to[210000],nxt[210000],cnt,tot;int fa[110000],val[110000],sum[110000];int ans,n,m,v,size[110000],dfn[110000];int maxn[410000];inline int max(int x,int y)&#123;return x&gt;y?x:y;&#125;inline void add(int u,int v)&#123; to[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt;&#125;//划分DFS序void dfs(int u,int ff)&#123; fa[u]=ff; size[u]=1; dfn[u]=++tot; for(int i=head[u];i;i=nxt[i]) if(to[i]!=ff) dfs(to[i],u),size[u]+=size[to[i]];&#125;void modify(int u,int l,int r,int x,int y,int val)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)&#123;maxn[u]=max(maxn[u],val);return;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) modify(u&lt;&lt;1,l,mid,x,y,val); if(y&gt;mid) modify(u&lt;&lt;1|1,mid+1,r,x,y,val);&#125;int query(int u,int l,int r,int x)&#123; if(l==r) return maxn[u]; int mid=l+r&gt;&gt;1; if(x&lt;=mid) return max(maxn[u],query(u&lt;&lt;1,l,mid,x)); else return max(maxn[u],query(u&lt;&lt;1|1,mid+1,r,x));&#125;//=====================线段树===================================void update(int u,int son)&#123; if(!u) return; modify(1,1,n,dfn[u],dfn[u],val[u]); for(int i=head[u];i;i=nxt[i]) if(to[i]!=son&amp;&amp;to[i]!=fa[u]) modify(1,1,n,dfn[to[i]],dfn[to[i]]+size[to[i]]-1,val[u]); if(sum[u]) return; //如果一个点已经做过祖先了，修改完这个点就不需要向上跳了 sum[u]=1; //标记作为祖先 update(fa[u],u);&#125;int main(int argc, char const *argv[])&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;val[i]);; for(int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs(1,0); char opt[20]; memset(maxn,-1,sizeof maxn); while(m--)&#123; scanf(\"%s%d\",opt,&amp;v); if(opt[0]=='Q')&#123; printf(\"%d\\n\",query(1,1,n,dfn[v])); &#125;else&#123; modify(1,1,n,dfn[v],dfn[v]+size[v]-1,val[v]); update(fa[v],v); &#125; &#125; return 0;&#125;","tags":[{"name":"线段树","slug":"线段树","permalink":"http://blog.southe3n.cf/tags/线段树/"},{"name":"DFS序","slug":"DFS序","permalink":"http://blog.southe3n.cf/tags/DFS序/"}]},{"title":"[USACO07DEC]观光奶牛","date":"2018-07-05T10:34:57.000Z","path":"2018/07/05/usaco07decguanguangnainiu/","text":"关键词：二分答案 判负环 相关题目：$Luogu2868$ -N句话题意 懒得概括，直接拉题面。。还是不偷懒了 给出一张$L(L\\leq 1000)$个点，$P(P\\leq 5000)$条边的有向图有点权和边权，要求找出一个环，使其 点权和/边权和 值最大 -主要思路Emmmm我们设一个环的点权和为$sum(f[v])$,边权和$sum(t[e])$答案$ans=max(sum(f[v])/sum(t[e]))$移一下项 得$sum(ans·t[e])-sum(f[v])=0$那么我们就可以对这个$ans$进行二分了对于每一个$mid$建立一张新图，每条边的值$t_{new}[i]=t[i]·mid-f[to[i]]$以每一个点为起点跑一遍$dfs$-$SPFA$判断有没有负环就可以了如果有负环，那么当前$mid$就是可以达到的，$l=mid$反之$r=mid$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;using namespace std;int n,m,to[5100],nxt[5100],head[1100],w[5100];int val[1100],vis[1100],cnt;double wa[5100],dis[1100];int spfa(int u) &#123; vis[u]=1; for(int i=head[u];i;i=nxt[i]) &#123; int v=to[i]; if(dis[v]&gt;dis[u]+wa[i]) &#123; dis[v]=dis[u]+wa[i]; if(vis[v]||spfa(v)) &#123;vis[u]=0;return 1;&#125; &#125; &#125; vis[u]=0; return 0; &#125;inline void add(int u, int v,int val)&#123; to[++cnt]=v; nxt[cnt]=head[u]; w[cnt]=val; head[u]=cnt;&#125;int main(int argc, char const *argv[])&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;val[i]); for(int i=1,x,y,z;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(x,y,z); double l=0,r=100007,mid; while(r-l&gt;0.000001)&#123; int flg=0; mid=(l+r)/2; for(int i=1;i&lt;=cnt;i++) wa[i]=w[i]*mid-val[to[i]]; //建新图 for(int i=1;i&lt;=n;i++) if(spfa(i)) &#123;l=mid; flg=1;break;&#125; if(!flg) r=mid; &#125; printf(\"%.2lf\\n\",l); return 0;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"http://blog.southe3n.cf/tags/图论/"},{"name":"二分答案","slug":"二分答案","permalink":"http://blog.southe3n.cf/tags/二分答案/"}]},{"title":"[2018湖南省队集训]circular","date":"2018-06-28T12:27:16.000Z","path":"2018/06/28/2018hunanshengduijixuncircular/","text":"关键词：贪心 分类讨论 相关题目：$BZOJ5397$ -写在前面Emmmm…其实是模拟省选考试题，我居然奇迹般地能A题了？！ -一句话题意他有一个长度为$M$的环,环上有$M$个等距离的点, 按顺时针顺序依次标号为$0,1,…,M−1$环上有$N$个线段$(a_i,b_i)(1 \\leq i \\leq N)$,需要注意的是$(a_i,b_i)$所指的线段是从点$a_i$顺时针延伸到$b_i$的线段希望知道最多能选多少个不相交的线段, 注意线段的端点是允许重合的 -主要思路很显然$b_i \\leq a_i$的线段(即绕过$0$点的线段)最多只会被选一个那么我们不考虑这样的线段，对所有$a_i \\leq b_i$线段进行贪心这时候我们得到一个贪心出来的答案这时候再来考虑绕过$0$点的线段，显然这最多只会使答案+$1$因此在这些线段中选取一个$b_i$最小且在当前贪心出来的线段的右端点之后的线段以这个线段为起点再进行一次贪心，最后选取这两种情况中答案大的那个即可 具体的贪心策略就是将所有线段按右端点为第一关键字，左端点为第二关键字排序 优先选右端点越左且满足当前贪心到的最终右端点的线段 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123;int x,y;&#125;a[110000];int cmp(node x,node y)&#123; return x.y==y.y?x.x&gt;y.x:x.y&lt;y.y;&#125;int n,m,now,ans,ans1;int main(int argc, char const *argv[])&#123; freopen(\"c.in\",\"r\",stdin); freopen(\"c.out\",\"w\",stdout); scanf(\"%d%d\",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d%d\",&amp;a[i].x,&amp;a[i].y); if(a[i].x&gt;a[i].y) a[i].y+=m; &#125; sort(a+1,a+n+1,cmp); int tmp=0; for(int i=1;i&lt;=n;i++) if(a[i].x&gt;=now) if(a[i].y&lt;m) now=a[i].y,ans++; else &#123; now=a[i].y;ans++; tmp=i; break; &#125; if(now-m&gt;a[1].x) ans--; if(!tmp) return printf(\"%d\\n\",ans),0; ans1=1; now=a[tmp].y-m; for(int i=1;i&lt;=n;i++) if(a[i].x&gt;=now&amp;&amp;a[i].y&lt;=a[tmp].x) now=a[i].y,ans1++; if(ans1&gt;ans) ans=ans1; printf(\"%d\\n\",ans); return 0;&#125;","tags":[{"name":"贪心","slug":"贪心","permalink":"http://blog.southe3n.cf/tags/贪心/"}]},{"title":"[CTSC2008]网络管理","date":"2018-06-26T10:12:03.000Z","path":"2018/06/26/ctsc2008wangluoguanli/","text":"关键词：带修主席树 树链剖分 相关题目：$Luogu4175$ $BZOJ1146$ -一句话题意给出一棵树节点数为$N$，每个点有一个权值，要求支持两种操作： 1.求结点$u$与$v$之间路径上第$k$大的权值 2.修改某一结点上的权值共$Q$次操作数据范围:$N,Q\\leq 80000$,权值$\\leq 10^8$。 -主要思路对于一棵树上的路径进行操作首先我们可以想到树链剖分而树链剖分需要一个可以维护区间信息的数据结构来辅助那么对于动态区间第$K$大显然可以使用带修主席树的方法 我们首先将树进行剖分，单点修改时修改每一棵包含点$u$的权值线段树路径查询时先利用树链剖分将路径分割为多条$dfs$序连续的重链这就是我们所要查询的区间了，对所有在树状数组意义下包含在这些区间里的权值线段树进行查询，就可以求出这条路径上的第$K$大了 路径查询的具体实现 利用两个数组分别记录需要加上和减去的线段树的结点序号 每一次判断当前所处权值区间的右子区间的权值总个数是否大于我们所求的$K$ 若大于等于则说明所求权值在右区间，向右区间查询 若小于则$k$-=$rsize$,向左区间查询 注意在向下层区间查询时将两个数组所存的结点序号更新 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include&lt;memory&gt;#include &lt;cstring&gt;using namespace std;const int N=90000;int to[N&lt;&lt;1],nxt[N&lt;&lt;1],head[N],cnt,a[N],root[N],n,q;int id[N],val[N],dep[N],size[N],fa[N],top[N],son[N],dfn;int l1,l2,q1[N],q2[N];inline void add(int u,int v)&#123; to[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt;&#125;void dfs1(int u,int ff)&#123; dep[u]=dep[ff]+1; size[u]=1; fa[u]=ff; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==ff) continue; dfs1(v,u); size[u]+=size[v]; if(size[v]&gt;size[son[u]]) son[u]=v; &#125;&#125;void dfs2(int u,int topp)&#123; top[u]=topp; id[u]=++dfn; val[dfn]=a[u]; if(son[u]) dfs2(son[u],topp); for(int i=head[u];i;i=nxt[i]) if(to[i]!=fa[u]&amp;&amp;to[i]!=son[u]) dfs2(to[i],to[i]);&#125;inline void query(int x,int y)&#123; l1=l2=0; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); for(int i=id[top[x]]-1;i&gt;0;i-=i&amp;-i) q1[++l1]=root[i]; for(int i=id[x];i&gt;0;i-=i&amp;-i) q2[++l2]=root[i]; x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y); for(int i=id[x]-1;i&gt;0;i-=i&amp;-i) q1[++l1]=root[i]; for(int i=id[y];i&gt;0;i-=i&amp;-i) q2[++l2]=root[i];&#125;//============================树链剖分===========================struct &#123; int tot,size[N&lt;&lt;8],lson[N&lt;&lt;8],rson[N&lt;&lt;8]; void ins(int &amp;u,int k,int l,int r,int value)&#123; if(!u) u=++cnt; size[u]+=value; if(l==r) return; int mid=l+r&gt;&gt;1; if(k&lt;=mid) ins(lson[u],k,l,mid,value); else ins(rson[u],k,mid+1,r,value); &#125; int query(int l,int r,int k)&#123; if(l==r) return l; int rsize=0,mid=l+r&gt;&gt;1; for(int i=1;i&lt;=l1;i++) rsize-=size[rson[q1[i]]]; for(int i=1;i&lt;=l2;i++) rsize+=size[rson[q2[i]]]; //将所有有关权值线段树当前结点上的信息整合 if(k&gt;rsize)&#123; for (int i=1;i&lt;=l1;i++) q1[i]=lson[q1[i]]; for (int i=1;i&lt;=l2;i++) q2[i]=lson[q2[i]]; return query(l,mid,k-rsize); //向左区间查找 &#125; else&#123; for (int i=1;i&lt;=l1;i++) q1[i]=rson[q1[i]]; for (int i=1;i&lt;=l2;i++) q2[i]=rson[q2[i]]; return query(mid+1,r,k); //向右区间查找 &#125; &#125;&#125;t;//=============================带修主席树============================int main(int argc, char const *argv[])&#123; scanf(\"%d%d\",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); for(int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs1(1,0); dfs2(1,1); for(int i=1;i&lt;=n;i++) for(int j=id[i];j&lt;=n;j+=j&amp;-j) t.ins(root[j],val[id[i]],0,1e8,1); int k,x,y; while(q--)&#123; scanf(\"%d%d%d\",&amp;k,&amp;x,&amp;y); if(k==0)&#123; for(int i=id[x];i&lt;=n;i+=i&amp;-i) t.ins(root[i],val[id[x]],0,1e8,-1), t.ins(root[i],y,0,1e8,1); val[id[x]]=y; &#125;else&#123; query(x,y); int tmp=0; for(int i=1;i&lt;=l1;i++) tmp-=t.size[q1[i]]; for(int i=1;i&lt;=l2;i++) tmp+=t.size[q2[i]]; if(tmp&lt;k) &#123;puts(\"invalid request!\");continue;&#125; printf(\"%d\\n\",t.query(0,1e8,k)); &#125; &#125; return 0;&#125; PS:我居然做完这道题才明白第$K$大和第$K$小的正确意义？！-_-","tags":[{"name":"主席树","slug":"主席树","permalink":"http://blog.southe3n.cf/tags/主席树/"},{"name":"树剖","slug":"树剖","permalink":"http://blog.southe3n.cf/tags/树剖/"}]},{"title":"[CQOI2011]动态逆序对","date":"2018-06-25T01:52:40.000Z","path":"2018/06/25/cqoi2011dongtainixudui/","text":"关键词：主席树 逆序对 CDQ分治 相关题目：$Luogu3157$ $BZOJ3295$ -一句话题意给出一个序列长度为$N$，每次删除其中一个元素，共删除$M$个，要求在每次删除元素前求其当前逆序对个数数据范围$N\\leq 100000,M\\leq 50000$ -主要思路先求出初始逆序对个数(用树状数组或者归并排序都可以啊)对于每次删除第$i$个数的操作，利用带修主席树求出该数对逆序对个数的贡献具体就是求出区间$[1..i-1]$中未被删除的大于$val[i]$的数的个数同理求出区间$[i+1,n]$中小于$val[i]$的数的个数，将这两种贡献从$ans$中减去即可由于要动态的删数来求当前贡献，需要使用带修主席树 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;using namespace std;const int N=100005;int size[N*100],lson[N*100],rson[N*100],root[N];int q1[N],q2[N],l1,l2,n,m,cnt,a[N],pos[N];long long ans,sum[N];inline long long gets(int x)&#123; int res=0; for(int i=x;i&gt;0;i-=i&amp;-i) res+=sum[i]; return res;&#125;void ins(int &amp;u,int k,int l,int r,int val)&#123; if(!u) u=++cnt; size[u]+=val; if(l==r) return; int mid=l+r&gt;&gt;1; if(k&lt;=mid) ins(lson[u],k,l,mid,val); else ins(rson[u],k,mid+1,r,val);&#125;long long askpre(int x,int l,int r)&#123; if(l==r) return 0; int mid=l+r&gt;&gt;1; if(x&lt;=mid)&#123; long long res=0; for(int i=1;i&lt;=l1;i++) res+=size[rson[q1[i]]],q1[i]=lson[q1[i]]; return res+askpre(x,l,mid); &#125;else&#123; for(int i=1;i&lt;=l1;i++) q1[i]=rson[q1[i]]; return askpre(x,mid+1,r); &#125;&#125;long long asksuc(int x,int l,int r)&#123; if(l==r) return 0; int mid=l+r&gt;&gt;1; if(x&lt;=mid)&#123; for(int i=1;i&lt;=l1;i++) q1[i]=lson[q1[i]]; for(int i=1;i&lt;=l2;i++) q2[i]=lson[q2[i]]; return asksuc(x,l,mid); &#125;else&#123; long long res=0; for(int i=1;i&lt;=l1;i++) res+=size[lson[q1[i]]],q1[i]=rson[q1[i]]; for(int i=1;i&lt;=l2;i++) res-=size[lson[q2[i]]],q2[i]=rson[q2[i]]; return res+asksuc(x,mid+1,r); &#125;&#125;inline long long query(int x)&#123; long long res=0; l1=0; for(int i=pos[x]-1;i&gt;0;i-=i&amp;-i) q1[++l1]=root[i]; res+=askpre(x,1,n); //求区间[1..i-1]中比大于x的数 l1=l2=0; for(int i=n;i&gt;0;i-=i&amp;-i) q1[++l1]=root[i]; for(int i=pos[x];i&gt;0;i-=i&amp;-i) q2[++l2]=root[i]; return res+asksuc(x,1,n); //求区间[i+1..n]中小于x的数&#125;int main(int argc, char const *argv[])&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); pos[a[i]]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; ans+=gets(n)-gets(a[i]); for(int j=i;j&lt;=n;j+=j&amp;-j) ins(root[j],a[i],1,n,1); for(int j=a[i];j&lt;=n;j+=j&amp;-j) sum[j]++; &#125; int x; while(m--)&#123; printf(\"%lld\\n\",ans); scanf(\"%d\",&amp;x); ans-=query(x); for(int i=pos[x];i&lt;=n;i+=i&amp;-i) ins(root[i],x,1,n,-1); &#125; return 0;&#125; PS:似乎这道题用CDQ分治更加无脑方便??学会了再说。。","tags":[{"name":"主席树","slug":"主席树","permalink":"http://blog.southe3n.cf/tags/主席树/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://blog.southe3n.cf/tags/CDQ分治/"}]},{"title":"【学习笔记】带修主席树","date":"2018-06-23T10:13:31.000Z","path":"2018/06/23/xuexibijidaixiuzhuxishu/","text":"洛谷P2617 Dynamic Rankings -写在前面带修主席树主要用于维护区间第$k$大，并且支持单点修改是由主席树改进过来的，但并不是很多人所说的所谓的树状数组套主席树主席树的思想是可持久化，将信息进行继承而带修主席树其实并没有用到这一思想 -主要思想 我们可以发现这里的修改是单点修改区间查询，那么自然而然可以想到树状数组 带修主席树的实质是树状数组套权值线段树 我们对树状数组的每一个节点建立一棵权值线段树 修改的时候对每一个包含该点的线段树进行修改，查询时类似于树状数组对多棵权值线段树相同位置上的信息进行加减就可以得到所需区间的信息了 -实现方法依然是利用动态开点的方法，在查询区间$[l,r]$时开两个数组分别记录包含$[l..l-1]$和$[1..r]$信息的权值线段树有哪些在查询向下递归时注意同时更新两个数组中的结点位置信息 每次查询和修改需要访问$\\log N$棵权值线段树 而对于每一棵权值线段树，深度为$\\log N$,因此时间复杂度为$O(N\\log^2 N)$ 由于使用动态开点，空间复杂度也是$O(N\\log^2 N)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;using namespace std;const int N=10005;int root[N],size[N&lt;&lt;9],lson[N&lt;&lt;9],rson[N&lt;&lt;9],q1[N],q2[N],a[N];int l1,l2,cnt,n,m;void ins(int &amp;u,int k,int l,int r,int val)&#123; if(!u) u=++cnt; //动态开点 size[u]+=val; if(l==r) return; int mid=l+r&gt;&gt;1; if(k&lt;=mid) ins(lson[u],k,l,mid,val); else ins(rson[u],k,mid+1,r,val);&#125;int query(int l,int r,int k)&#123; if(l==r) return l; int lsize=0,mid=l+r&gt;&gt;1; for(int i=1;i&lt;=l1;i++) lsize-=size[lson[q1[i]]]; for(int i=1;i&lt;=l2;i++) lsize+=size[lson[q2[i]]]; if(k&gt;lsize)&#123; for (int i=1;i&lt;=l1;i++) q1[i]=rson[q1[i]]; for (int i=1;i&lt;=l2;i++) q2[i]=rson[q2[i]]; //向下递归的同时更新当前队列中的结点 return query(mid+1,r,k-lsize); &#125; else&#123; for (int i=1;i&lt;=l1;i++) q1[i]=lson[q1[i]]; for (int i=1;i&lt;=l2;i++) q2[i]=lson[q2[i]]; return query(l,mid,k); &#125;&#125;int main(int argc, char const *argv[])&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); for(int j=i;j&lt;=n;j+=j&amp;-j) ins(root[j],a[i],0,1e9,1); &#125; char opt[10];int x,y,z; while(m--)&#123; scanf(\"%s%d%d\",opt,&amp;x,&amp;y); if(opt[0]=='Q')&#123; scanf(\"%d\",&amp;z); l1=l2=0; for(int i=x-1;i&gt;0;i-=i&amp;-i) q1[++l1]=root[i]; for(int i=y;i&gt;0;i-=i&amp;-i) q2[++l2]=root[i]; //运用树状数组的思想，实质是树状数组套权值线段树 printf(\"%d\\n\",query(0,1e9,z)); &#125;else&#123; for(int i=x;i&lt;=n;i+=i&amp;-i) ins(root[i],a[x],0,1e9,-1),ins(root[i],y,0,1e9,1); a[x]=y; &#125; &#125; return 0;&#125;","tags":[{"name":"主席树","slug":"主席树","permalink":"http://blog.southe3n.cf/tags/主席树/"},{"name":"树状数组","slug":"树状数组","permalink":"http://blog.southe3n.cf/tags/树状数组/"}]},{"title":"【学习笔记】主席树","date":"2018-06-23T02:14:46.000Z","path":"2018/06/23/xuexibijizhuxishu/","text":"洛谷P3834 【模板】可持久化线段树 1（主席树）-主要思想主席树比较经典的应用是求区间第$k$大即给定一个数列，查询某一区间中的第$k$大数 主席树的本质是多棵权值线段树，利用前缀和的思想来实现 由于形态完全相同的线段树若维护的信息是满足加减性(即合并信息时可以直接加减)的 那么这两棵线段树也能通过直接将对应结点的信息相互加减来合并或拆分 这样就可以将前缀和的思想应用到线段树上了 -实现方法我们对每一个$1..i$的区间建立一棵权值线段树对于每一个区间$[l,r]$查询，代表这个区间的权值线段树就是线段树$[r]$-线段树$[l-1]$对这个线段树进行二分答案，判断排名是否$=k$,就可以得到答案了 至于具体的权值线段树实现方法，这里就不写了。（其实是我懒）如果不知道可以先去学一下,主要是将普通线段树维护的区间变为权值区间 等一蛤，似乎这样建权值线段树的空间复杂度是$O(4N^2)$？？这不是铁定爆了嘛好，让我们冷静分析一下,似乎区间$[1..i]$和$[1..i-1]$的线段树只有一条$\\log N$的链是不同的？因为两个区间相比只多了一个权值为$val[i]$的数，所以只有包含$val[i]$的权值区间是不一样的 我们运用**可持久化思想**，通过动态开点的方法，对于当前区间的左右孩子, 若新增的一个权值不属于其权值区间，则直接指向到上一棵线段树的相同位置 对于需要修改的一条链，用动态开点新开一条链就可以了 具体形态会长成这样子 那么我们就可以在$O(N\\log N)$的时间内解决这个问题了 需要注意的是，若数据的值域很大，由于使用的是权值线段树，复杂度会很高 这时候我们就需要将数据离散化一下，将值域降为$N$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int maxa=-2e9,mina=2e9;int root[210000],lson[21000000],rson[21000000],size[21000000];int cnt,n,m,x[210000],y[210000],tot;struct node&#123;int val,id;&#125;a[210000];int cmp(node x,node y)&#123;return x.val&lt;y.val;&#125;void ins(int &amp;u,int pre,int k,int l,int r)&#123; u=++cnt; //动态开点，u使用实参 size[u]=size[pre]+1; lson[u]=lson[pre],rson[u]=rson[pre]; //继承上一时刻的区间信息 if(l==r) return; int mid=l+r&gt;&gt;1; if(k&lt;=mid) ins(lson[u],lson[pre],k,l,mid); //只需要修改logn的区间信息 else ins(rson[u],rson[pre],k,mid+1,r);&#125;int query(int ul,int ur,int k,int l,int r)&#123; if(l==r) return l; int lsize=size[lson[ur]]-size[lson[ul]],mid=l+r&gt;&gt;1; if(lsize&gt;=k) return query(lson[ul],lson[ur],k,l,mid); else return query(rson[ul],rson[ur],k-lsize,mid+1,r); &#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i].val),a[i].id=i; sort(a+1,a+n+1,cmp); //离散化，使权值线段树的值域降到n for(int i=1;i&lt;=n;i++)&#123; if(a[i].val==a[i-1].val&amp;&amp;a[i].val!=0) x[a[i].id]=tot; else x[a[i].id]=++tot; y[tot]=a[i].val; &#125; for(int i=1;i&lt;=n;i++) ins(root[i],root[i-1],x[i],1,tot); //每插入一个数，都只需要记录一条logn的链，其余的都与时刻i-1的线段树相同，直接使用即可 while(m--)&#123; int l,r,k; scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;k); printf(\"%d\\n\",y[query(root[l-1],root[r],k,1,tot)]); //r时刻的线段树减去l-1时刻的线段树即是区间l~r的线段树 &#125; return 0;&#125;","tags":[{"name":"主席树","slug":"主席树","permalink":"http://blog.southe3n.cf/tags/主席树/"}]},{"title":"[AHOI2009]中国象棋","date":"2018-06-21T11:00:50.000Z","path":"2018/06/21/ahoi2009zhongguoxiangqi/","text":"关键词：状压DP,动态规划 相关题目：$Luogu2051$ $BZOJ1801$ Emmmm…其实这道题说是状压DP比较Fake，只是一个50分的做法，但正解可以从状压DP优化过来 -一句话题意给定一个N行M列的棋盘，求在上面放置中国象棋中的炮的方案数，要求任意的一对炮都不能相互攻击到方案数对$9999973$取模，可以不放炮，炮的数量没有限制$N,M \\leq 100$ -主要思路分析一下可以发现，由于炮的攻击方法，任何一行或一列都最多只能有2个炮 先讲50分的做法吧50分的条件是$N,M$中有一个小于等于8那么就可以考虑状压DP了，用三进制数记录每一列的象棋个数状态定义$F[i][j]$表示放到第$i$行时象棋摆放状态为$j$的方案数转移时枚举$i$和$j$即可时间复杂度为$O(3^MN·M)$ 观察一哈，似乎我们其实并不需要知道每一列的具体状态？？！我们需要的只是有一个棋子和没有棋子的列数对，正解来了用$F[i][j][k]$记录放到第$i$行此时有$j$列有一个棋子，$k$列有两个棋子转移的时候利用组合数乘一下就可以了时间复杂度为$O(NM^2)$ 具体转移时考虑该行放几个棋子，以及放置在没有棋子的列和有一个棋子的列不同情况就可以了，具体在代码中注释了 代码1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;using namespace std;const int mod=9999973;long long f[110][110][110];int n,m;int main(int argc, char const *argv[])&#123; scanf(\"%d%d\",&amp;n,&amp;m); f[0][0][0]=1; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=m;j++) for(int k=0;k&lt;=m-j;k++)&#123; if(!f[i][j][k]) continue; f[i+1][j][k]=(f[i+1][j][k]+f[i][j][k])%mod; //不放棋子 if(j+k&lt;m) f[i+1][j+1][k]=(f[i+1][j+1][k]+f[i][j][k]*(m-j-k))%mod; //放一个在没有棋子的列上 if(j) f[i+1][j-1][k+1]=(f[i+1][j-1][k+1]+f[i][j][k]*j)%mod; //放一个在有一个棋子的列上 if(j+k+2&lt;=m) f[i+1][j+2][k]=(f[i+1][j+2][k]+f[i][j][k]*(m-j-k)*(m-j-k-1)/2)%mod; //放两个在没有棋子的列上 if(j+k&lt;m&amp;&amp;j) f[i+1][j][k+1]=(f[i+1][j][k+1]+f[i][j][k]*(m-j-k)*j)%mod; //放两个一个在没有棋子的列上，一个在有一个棋子的列上 if(j&gt;=2) f[i+1][j-2][k+2]=(f[i+1][j-2][k+2]+f[i][j][k]*j*(j-1)/2)%mod; //放两个在有一个棋子的列上 &#125; int ans=0; for(int i=0;i&lt;=m;i++) for(int j=0;j&lt;=m-i;j++) ans=(ans+f[n][i][j])%mod; printf(\"%d\\n\",ans); return 0;&#125;","tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://blog.southe3n.cf/tags/状压DP/"}]},{"title":"CF280C Game on Tree","date":"2018-06-21T05:48:24.000Z","path":"2018/06/21/cf280cgameontree/","text":"关键词：数学期望 相关题目：$Luogu$ $Codeforces$ Emmmm…数学期望渣渣，来看一波讲稿，就看到一道挺有意思的题，于是—— -一句话题意给定一个有根树，初始所有点为白色，每一次操作在白色点中随机选取一个将其和其子树全部染成黑色，求将整棵树染成黑色的次数的期望 -主要思路我们把每一个点染黑的过程当成一个独立的事件那么只有当我们选取了这个点，或者这个点的祖先时，这个点才会被染黑而将一个点染黑的操作中，选取到这个点自身的概率就是$\\frac{1}{祖先数+1}$ 即$\\frac{1}{dep[i]}$($dep$为深度)由于期望=$\\sum$概率$*$权，所以一个点的次数期望就是$\\frac{1}{dep[i]}$整棵树的次数期望就是$\\sum_{i=1}^{n}\\frac{1}{dep[i]}$ 好，那么问题就解决了（我怎么自己想不出来啊。。。数学渣渣） 代码12345678910111213141516171819202122232425#include &lt;cstdio&gt;using namespace std;int to[210000],nxt[2100000],head[110000],dep[110000],n,cnt;inline void add(int u,int v)&#123; to[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt;&#125;void dfs(int u,int ff)&#123; dep[u]=dep[ff]+1; for(int i=head[u];i;i=nxt[i]) if(to[i]!=ff) dfs(to[i],u);&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs(1,0); double ans=0; for(int i=1;i&lt;=n;i++) ans+=(double)1/dep[i]; printf(\"%.9lf\",ans); return 0;&#125;","tags":[{"name":"数学期望","slug":"数学期望","permalink":"http://blog.southe3n.cf/tags/数学期望/"}]},{"title":"[SDOI2009]学校食堂","date":"2018-06-21T02:10:23.000Z","path":"2018/06/21/sdoi2009xuexiaoshitang/","text":"关键词：状压DP 相关题目：$Luogu2157$ $BZOJ1226$ -N句话题意 感觉自己不太概括的出来。。。就把题面直接拉过来吧（逃逃逃逃逃~~） 小F 的学校在城市的一个偏僻角落，所有学生都只好在学校吃饭。学校有一个食堂，虽然简陋，但食堂大厨总能做出让同学们满意的菜肴。当然，不同的人口味也不一定相同，但每个人的口味都可以用一个非负整数表示。 由于人手不够，食堂每次只能为一个人做菜。做每道菜所需的时间是和前一道菜有关的，若前一道菜的对应的口味是$a$，这一道为$b$，则做这道菜所需的时间为(a|b-a&amp;b)，而做第一道菜是不需要计算时间的。 学生数目相对于这个学校还是比较多的，吃饭做菜往往就会花去不少时间。因此，学校食堂偶尔会不按照大家的排队顺序做菜，以缩短总的进餐时间。 虽然同学们能够理解学校食堂的这种做法，不过每个同学还是有一定容忍度的。也就是说，队伍中的第$i$个同学，最多允许紧跟他身后的$B[i]$ 个人先拿到饭菜。一旦在此之后的任意同学比当前同学先拿到饭，当前同学将会十分愤怒。因此，食堂做菜还得照顾到同学们的情绪。 现在，小F 想知道在满足所有人的容忍度这一前提下，自己的学校食堂做完这些菜最少需要多少时间。、 其中$1 \\leq N \\leq 1,000，0 \\leq Ti \\leq 1,000，0 \\leq Bi \\leq 7,1 \\leq C \\leq 5$。 -主要思路先观察一哈数据范围，欸？$Bi \\leq 7$？那是不是可以把这个状态压缩一波啊？那么我们定义$F[i][j][k]$表示第$i$个人以前都打完了饭（不包括$i$）,$j$用状压的思想记录在$i$及$i$以后打饭的状态，$k$记录该状态下最后一个打饭的人是第$i+k$个人那么我们可以发现因为人们最多允许后面第$7$个人先打饭，则$0\\leq j &lt; 2^8$,$-8\\leq k \\leq 7$ 状态的转移通过枚举$h$也就是现在让第$h+i$个人打饭来完成，可以发现$f[i][j∣(1&lt;&lt;h)][h]=min(f[i][j∣(1&lt;&lt;h)][h],f[i][j][k]+time(i+k,i+h))$ （time(i+k,i+h)表示第i+k个人做完饭后第i+h个人所需时间） 时间复杂度近似于$O(2^8·8·16N)$?? 我似乎不太会算。。。 需要注意的是枚举$h$时要记录所有未打饭的人能忍耐的最后一个人为$limit$ 若$h>limit$直接$break$ 还有当j&1==1时(第$i$个人已经打完饭了)$f[i+1][j>>1][k-1]$ 可以直接由$f[i][j][k]$转移 (原因其实还是比较清晰的，就自己思考一下吧) 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int T,n,a[1100],b[1100],limit,f[1100][300][20];inline int min(int x,int y)&#123;return x&lt;y?x:y;&#125;int main(int argc, char const *argv[])&#123; scanf(\"%d\",&amp;T); while(T--)&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;a[i],&amp;b[i]); memset(f,0x3f,sizeof f); f[1][0][7]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;(1&lt;&lt;8);j++)&#123; for(int k=-8;k&lt;=7;k++) if(f[i][j][k+8]&lt;=1e8)&#123; if(j&amp;1) f[i+1][j&gt;&gt;1][k+7] =min(f[i+1][j&gt;&gt;1][k+7],f[i][j][k+8]); else &#123; limit=1e9; for(int h=0;h&lt;=b[i];h++)&#123; if(j&amp;(1&lt;&lt;h)) continue; if(h&gt;limit) break; limit=min(limit,h+b[h+i]); f[i][j|(1&lt;&lt;h)][h+8]=min(f[i][j|(1&lt;&lt;h)][h+8], f[i][j][k+8]+((i+k)?(a[i+k]^a[i+h]):0)); &#125; &#125; &#125; &#125; &#125; int ans=21e8; for(int i=0;i&lt;=8;i++) ans=min(ans,f[n+1][0][i]); printf(\"%d\\n\",ans); &#125; return 0;&#125;","tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://blog.southe3n.cf/tags/状压DP/"}]},{"title":"yyy loves Maths VII","date":"2018-06-20T12:16:55.000Z","path":"2018/06/20/yyylovesmathsvii/","text":"关键词：状压DP 略微卡常 相关题目：$Luogu2396$ -写在前面算是我状压DP的入门题之一？之前也没怎么写过状压DP，话说卡常真的是原罪啊！ -N句话题意给定$n(n\\leq 24)$个“幸运数字”，$m(m\\leq 2)$个“厄运数字”求出使用完所有幸运数字的合法方案数，要求在任意时刻已使用的幸运数字的和不等于厄运数字输出方案数对$1000000007$取模的结果 -解决方案思路还是比较清晰的状压DP的思想是利用二进制将状态进行压缩一般来说是用第$i$位上的$1$表示第$i$件物品（之类的东西）已经用到了 对于这道题我们可以枚举每一个幸运数字使用的状态($1\\leq i\\leq 2^i-1$)对于每一个状态，枚举每一个该状态下使用了的幸运数字当前状态下的方案数就可以从除去其中某一个幸运数字的状态的方案数递推过来这样的时间复杂度就是$O(2^NN)$ 然后可能需要一些小小的卡常姿势，直接写似乎不太过得去。。。具体见代码 代码12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;using namespace std;const int mod=1000000007;int f[20000000],dis[20000000],low[20000000],bit[30];int main(int argc, char const *argv[])&#123; int a[30],b[10],n,m; b[1]=b[2]=-1000;f[0]=1; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++) bit[i+1]=1&lt;&lt;i,low[bit[i+1]]=i+1; for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;i++) scanf(\"%d\",&amp;b[i]); for(register int i=1;i&lt;=(1&lt;&lt;n)-1;i++)&#123; //枚举状态，第i位二进制位上的1表示使用第i张牌 int now=i,tmp=now&amp;-now,j=low[tmp]; dis[i]=dis[i^tmp]+a[j]; if(dis[i]==b[1]||dis[i]==b[2]) continue; for(;now;)&#123; //对每一个二进制位上的1（使用的牌），从没有这张牌的状态进行递推 tmp=now&amp;-now; f[i]=f[i]+f[i^tmp]; if(f[i]&gt;=mod) f[i]-=mod; now^=tmp; //相当于去除当前最低位的1 &#125; &#125; printf(\"%d\\n\",f[(1&lt;&lt;n)-1]); return 0;&#125;","tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://blog.southe3n.cf/tags/状压DP/"}]},{"title":"[国家集训队]Tree II","date":"2018-06-18T05:53:24.000Z","path":"2018/06/18/guojiajixunduitreeii/","text":"关键词：$LCT$,$Splay$处理区间问题 相关题目：$Luogu1501$ -题面信息一棵n个点的树，每个点的初始权值为$1$。对于这棵树有$q$个操作，每个操作为以下四种操作之一： 1. + $u~v~ c$：将$u$到$v$的路径上的点的权值都加上自然数$c$； 2. - $u1~v1~u2~v2$：将树中原有的边$(u1,v1)$删除，加入一条新边$(u2,v2)$，保证操作完之后仍然是一棵树； 3. * $u~v~c$：将$u$到$v$的路径上的点的权值都乘上自然数$c$； 4. / $u~ v$：询问$u$到$v$的路径上的点的权值和，求出答案对于$51061$的余数。 -解决方案有没有似曾相识的感觉？可以借鉴线段树2的做法，记录两个$lazytag$,分别记录乘法和加法修改和下方标记时，先做乘法再做加法，修改乘法标记时同时将加法标记进行修改，修改加法标记时直接修改即可那么为了资瓷动态删边加边的操作，很容易想到$LCT$所以将线段树2上的标记方法搬到$LCT$上就可以了 我们对每个点维护其值、子树和、子树大小、lazy值 由于对$51061$取模，我们可以用$unsigned~int$,也可以无脑$long~long$ 总之$int$会爆掉就是了（~~我斯波被坑了~~） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;memory&gt;#define int unsigned intconst int N=11e4,mod=51061;int n,q;using namespace std;struct LCT&#123; int fa[N],ch[N][2],st[N],lazy1[N],lazy2[N]； int val[N],top,sum[N],rev[N],size[N]; inline void init()&#123; memset(fa,0,sizeof(fa)); memset(ch,0,sizeof(ch)); memset(lazy2,0,sizeof(lazy2)); memset(sum,0,sizeof(sum)); for(register int i=1;i&lt;=n;i++) lazy1[i]=val[i]=size[i]=sum[i]=1; &#125; inline int isroot(int u)&#123; return ch[fa[u]][0]!=u&amp;&amp;ch[fa[u]][1]!=u; &#125; inline void update(int u)&#123; sum[u]=(sum[ch[u][0]]+sum[ch[u][1]]+val[u])%mod; size[u]=size[ch[u][0]]+size[ch[u][1]]+1; &#125; inline void _mult(int u,int c)&#123; val[u]=val[u]*c%mod; sum[u]=sum[u]*c%mod; lazy1[u]=lazy1[u]*c%mod; lazy2[u]=lazy2[u]*c%mod; &#125; inline void _add(int u,int c)&#123; val[u]=(val[u]+c)%mod; sum[u]=(sum[u]+c*size[u])%mod; lazy2[u]=(lazy2[u]+c)%mod; &#125; inline void pushdown(int u)&#123; //将三个标记下放，先下放乘法标记再加法 if(rev[u])&#123; rev[u]=0; rev[ch[u][1]]^=1; rev[ch[u][0]]^=1; swap(ch[u][1],ch[u][0]); &#125; if(lazy1[u]!=1)&#123; if(ch[u][0]) _mult(ch[u][0],lazy1[u]); if(ch[u][1]) _mult(ch[u][1],lazy1[u]); lazy1[u]=1; &#125; if(lazy2[u])&#123; if(ch[u][0]) _add(ch[u][0],lazy2[u]); if(ch[u][1]) _add(ch[u][1],lazy2[u]); lazy2[u]=0; &#125; &#125; inline void rotate(int u)&#123; int f=fa[u],grandf=fa[f],d=(ch[f][1]==u); if(!isroot(f)) ch[grandf][ch[grandf][1]==f]=u; fa[u]=grandf; ch[f][d]=ch[u][!d],fa[ch[u][!d]]=f; ch[u][!d]=f,fa[f]=u; update(f); &#125; inline void splay(int u)&#123; st[top=1]=u; for(int i=u;!isroot(i);i=fa[i]) st[++top]=fa[i]; while(top) pushdown(st[top]),top--; int f,grandf; while(!isroot(u))&#123; f=fa[u],grandf=fa[f]; if(!isroot(f)) (ch[f][1]==u)==(ch[grandf][1]==f)? rotate(f):rotate(u); rotate(u); &#125; update(u); &#125;// ===========================Splay部分结束================================= inline int access(int u)&#123; int now=0; while(u)&#123; splay(u); ch[u][1]=now; now=u; u=fa[u]; &#125; return now; &#125; inline void makeroot(int u)&#123; access(u);splay(u);rev[u]^=1; &#125; inline void link(int u,int v)&#123; makeroot(u); fa[u]=v; splay(v); &#125; inline void cut(int u,int v)&#123; makeroot(u); access(v); splay(v); fa[u]=ch[v][0]=0; &#125; inline void mul(int u,int v,int c)&#123; makeroot(u);access(v);splay(v); _mult(v,c); &#125; inline void add(int u,int v,int c)&#123; makeroot(u),access(v),splay(v); _add(v,c); &#125; inline int query(int u,int v)&#123; makeroot(u),access(v),splay(v); return sum[v]; &#125;&#125;LCT;signed main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); LCT.init(); //记得初始化。。 for(int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),LCT.link(x,y); char s[10]; while(q--)&#123; int a,b,c,d; scanf(\"%s\",s); switch(s[0])&#123; case '+':&#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); LCT.add(a,b,c); break; &#125; case '-':&#123; scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d); LCT.cut(a,b); LCT.link(c,d); break; &#125; case '*':&#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); LCT.mul(a,b,c); break; &#125; case '/':&#123; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",LCT.query(a,b)); break; &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"LCT","slug":"LCT","permalink":"http://blog.southe3n.cf/tags/LCT/"},{"name":"平衡树","slug":"平衡树","permalink":"http://blog.southe3n.cf/tags/平衡树/"}]},{"title":"【学习笔记】欧拉函数","date":"2018-06-04T05:16:22.000Z","path":"2018/06/04/xuexibijioulahanshu/","text":"浅浅浅析欧拉函数φ 感觉自己数论知识相当匮乏啊。。 最近可能要集中补一下数论姿势？ 因为还没怎么用过所以写的会比较简单请见谅。。。 -概念及定义欧拉函数 $\\phi(n)$ 表示有多少个数小于等于$n$并与$n$互质这个函数具有一些性质。。。 1. 若$n$为素数，$\\phi(n)=n-1$ 2. 若$(a,b)=1$（即$a,b$互质），$\\phi(ab)=\\phi(a)*\\phi(b)$（这个我们之后可以用计算通式来证明） 3. 扩展欧拉定理 a^b\\equiv \\begin{cases} a^{b\\%\\phi(p)}~~~~~~~~~~~~~~~~gcd(a,p)=1\\\\ a^b~~~~~~~~~~~~~~~~~~~~~~~gcd(a,p)\\neq1,b","tags":[{"name":"数论","slug":"数论","permalink":"http://blog.southe3n.cf/tags/数论/"}]},{"title":"HNOI2010-弹飞绵羊","date":"2018-06-02T03:36:24.000Z","path":"2018/06/02/hnoi2010danfeimianyang/","text":"关键词：$LCT$，分块 相关题目：$BZOJ2002$ $Luogu3203$ 题面信息-题目描述某天，$Lostmonkey$发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，$Lostmonkey$在地上沿着一条直线摆上$n$个装置，每个装置设定初始弹力系数$k_i$，当绵羊达到第i个装置时，它会往后弹$k_i$步，达到第$i+k_i$个装置，若不存在第$i+k_i$个装置，则绵羊被弹飞。绵羊想知道当它从第$i$个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，$Lostmonkey$可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 -输入输出格式输入格式：第一行包含一个整数$n$，表示地上有$n$个装置，装置的编号从$0$到$n-1$。接下来一行有$n$个正整数，依次为那$n$个装置的初始弹力系数。第三行有一个正整数$m$，接下来$m$行每行至少有两个数$i$、$j$，若$i=1$，你要输出从j出发被弹几次后被弹飞，若$i=2$则还会再输入一个正整数$k$，表示第$j$个弹力装置的系数被修改成$k$。 输出格式：对于每个$i=1$的情况，你都要输出一个需要的步数，占一行。 -数据范围对于$100\\%$的数据$n&lt;=200000$,$m&lt;=100000$ 解决方案-大力分块我们采用分块的思想，将数列分为$\\sqrt{n}$块先$O(N)$预处理出每一个点需要跳几次才能跳出当前块以及跳出当前块后所处的位置对于每次查询操作，逐块进行跳跃并记录跳跃的次数总和对于每次修改操作，对该块内的所有元素暴力修改即可 时间复杂度： 对于查询操作，时间复杂度为块的个数，即$O(\\sqrt{n})$ 对于修改操作，时间复杂度为单块内点的个数，也是$O(\\sqrt{n})$ 这样，我们就在$O(M\\sqrt{N})$的时间内解决了问题 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;ctype.h&gt;using namespace std;inline int read()&#123; int x=0,f=1; char ch; ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48;ch=getchar();&#125; return x*f;&#125;int a[210000],tail[210000],step[210000],nxt[210000];int n,m;int main()&#123; n=read(); int unit=floor(sqrt(n)); for(register int i=1;i&lt;=n;i++) a[i]=read(); int now=unit; for(register int i=1;i&lt;=n;i++)&#123; if(i&gt;now) now+=unit; tail[i]=now; &#125; //预处理出块 for(register int i=n;i&gt;=1;i--) if(a[i]+i&gt;tail[i]||a[i]+i&gt;n) step[i]=1,nxt[i]=a[i]+i; else step[i]=step[a[i]+i]+1,nxt[i]=nxt[a[i]+i]; //预处理出跳出块所需步数和到达的点 scanf(\"%d\",&amp;m); int x,y,z; while(m--)&#123; x=read(),y=read(); y++; if(x==1)&#123; int ans=0; while(y&lt;=n) ans+=step[y],y=nxt[y]; //逐块跳跃并记录步数 printf(\"%d\\n\",ans); &#125;else&#123; z=read(); a[y]=z; for(register int i=tail[y];i&gt;=tail[y]-unit+1;i--) //在块内从后往前修改信息 if(a[i]+i&gt;tail[i]) step[i]=1,nxt[i]=a[i]+i; else step[i]=step[a[i]+i]+1,nxt[i]=nxt[a[i]+i]; &#125; &#125; return 0;&#125; -LCT虽然分块能解决问题，但$O(m\\sqrt{n})$的时间复杂度并不十分让人满意有没有办法更快地解决问题呢？正解是LCT我们建立一个点$n+1$表示绵羊已经被弹飞对于每一次弹跳，相当于从点$i$到点$i+k[i]$连接一条边若被弹飞则将该点与$n+1$相连那么每次修改时只需要$Cut$旧目标点，$Link$新目标点即可每次查询时建立一颗只包含$x$到$n+1$的路径的$Splay$，该$Splay$的$size-1$即为答案具体操作：Makeroot(n+1),Access(x),Splay(x),答案为size[x]-1 这样，我们就在$O(M\\log{N})$的时间内解决了问题","tags":[{"name":"分块","slug":"分块","permalink":"http://blog.southe3n.cf/tags/分块/"},{"name":"LCT","slug":"LCT","permalink":"http://blog.southe3n.cf/tags/LCT/"}]},{"title":"【学习笔记】高斯消元","date":"2018-06-01T05:03:03.000Z","path":"2018/06/01/xuexibijigaosixiaoyuan/","text":"感性理解高斯消元模板题：洛谷 P3389 【模板】高斯消元法 -写在前面没错！今天又是BZOJ的错→_→BZOJ 1013:[JSOI2008]球形空间产生器 题目大意：给出$n$维空间上球面上的$n+1$个点的坐标，求出球心坐标距离公式：$dis=\\sqrt{\\sum_{i=1}^n(a_i-b_i)^2}$ 一看这不是高斯消元果题吗？然而——不会。。。。赶紧来感性理解一下吧 -概念及定义 高斯消元法用于求解多元一次方程组 本质是加减消元 利用计算机模拟手算解方程组的过程， 通过加减消元，使某一项化为$kx=y$的形式求出$x$的值， 再将$x$回代，继续求其他未知数，重复此过程$n$次即可求出全部$n$个未知数 -主要做法与姿势 首先将方程组以矩阵的形式保存$For Example~~$ \\begin{cases} 3x+y-z=-1\\\\ 2x+y+z=7\\\\ x+4y+3z=18 \\end{cases}\\Leftrightarrow \\left[\\begin{array}{ccc|c} 3 & 1 & -1 & 2\\\\ 2 & 1 & 1 & 7\\\\ 1 & 4 & 3 & 18 \\end{array}\\right]那么我们什么时候可以求出方程组的解呢？长成这样—— \\left[\\begin{array}{ccc|c} 1 & 0 & 0 & a\\\\ 0 & 1 & 0 & b\\\\ 0 & 0 & 1 & b \\end{array}\\right]此时 $(x,y,z)=(a,b,c)$我们所使用的方法是一列一列进行消元注意应将该列系数绝对值最大的一行放到作为减法单位的那一行来提高精度 先将第一列消为$(1,0,0)$的形式使当前行的该项系数变为$1$ \\Rightarrow \\left[\\begin{array}{ccc|c} 1 & \\frac{1}{3} & -\\frac{1}{3} & \\frac{2}{3}\\\\ 2 & 1 & 1 & 7\\\\ 1 & 4 & 3 & 18 \\end{array}\\right] 再用该行去处理其他行，消去该项系数$(2)-(1)\\times 2$以及$(3)-(1)$ \\Rightarrow \\left[\\begin{array}{ccc|cc} 1 & \\frac{1}{3} & -\\frac{1}{3} & \\frac{2}{3} &(1)\\\\ 0 & \\frac{1}{3} & \\frac{5}{3} & \\frac{17}{3} &(2)\\\\ 0 & \\frac{11}{3} & \\frac{10}{3} & \\frac{52}{3}&(3) \\end{array}\\right] 将第三行换到第二行（因为第三行是第二项系数绝对值最大的） \\Rightarrow \\left[\\begin{array}{ccc|c} 1 & \\frac{1}{3} & -\\frac{1}{3} & \\frac{2}{3}\\\\ 0 & \\frac{11}{3} & \\frac{10}{3} & \\frac{52}{3}\\\\ 0 & \\frac{1}{3} & \\frac{5}{3} & \\frac{17}{3} \\end{array}\\right] 同样的方法，将第二列变为$(0,1,0)$,将第三列变为$(0,0,1)$ \\Rightarrow \\left[\\begin{array}{ccc|c} 1 & 0 & -2 & -5\\\\ 0 & 1 & 5 & 17\\\\ 0 & 0 & -15 & -45 \\end{array}\\right] \\Rightarrow \\left[\\begin{array}{ccc|c} 1 & 0 & 0 & 1\\\\ 0 & 1 & 0 & 2\\\\ 0 & 0 & 1 & 3 \\end{array}\\right] 求解完成！$(x,y,z)=(1,2,3)$ 当原矩阵可化为单位矩阵时方程组有唯一解 1.那么什么时候方程组无解呢？ 在消元过程中若出现某一行系数均为0但常数项不为0时，方程无解 2.那什么时候方程有无限多解呢？ 在消元过程中出现某一行系数均为0且常数项也为0时，方程有无限多解 接下来就是代码实现（这是最基本的高斯消元，有时候需要处理自由元，那么就要对自由元进行枚举并分别回代求解） 时间复杂度$O(N^3)$ -代码实现123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cmath&gt; #include&lt;algorithm&gt;using namespace std;const double eps=1e-6;int n;double mat[110][110],ans[110];inline void swap(double &amp;a,double &amp;b)&#123;double t=a;a=b,b=t;&#125;inline int Gauss()&#123; for(int i=1;i&lt;=n;i++)&#123; //枚举第i列 int major=i; for(int j=i+1;j&lt;=n;j++) //寻找该列绝对值最大的一行 if(fabs(mat[major][i])&lt;fabs(mat[j][i])) major=j; if(fabs(mat[major][i])&lt;eps) return 0; //若存在一行数均为0则方程组无解 if(major!=i) //若绝对值最大的一行不是第i行，将该行换到第i行 swap(mat[major],mat[i]); for(int j=i+1;j&lt;=n+1;j++) mat[i][j]/=mat[i][i]; //将第i行的第i项系数变为1 mat[i][i]=1; for(int j=1;j&lt;=n;j++)&#123; //消去其他行的该项系数 if(i==j) continue; for(int k=i+1;k&lt;=n+1;k++) mat[j][k]-=mat[i][k]*mat[j][i]; mat[j][i]=0; &#125; &#125; //此时矩阵即为单位矩阵 for(int i=1;i&lt;=n;i++) ans[i]=mat[i][n+1]; return 1;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n+1;j++) scanf(\"%lf\",&amp;mat[i][j]); if(!Gauss()) return puts(\"No Solution\"),0; for(int i=1;i&lt;=n;i++) printf(\"%0.2lf\\n\",ans[i]); return 0;&#125; -解决方案让我们回到那道BZOJ题 设球心坐标为$b_1,b_2...b_n$ 展开距离公式$r=\\sqrt{\\sum_{i=1}^n(a_i-b_i)^2}$ 得$r^2=\\sum_{i=1}^n(a_i^2-2a_ib_i+b_i^2)$ 移项得$\\sum_{i=1}^n(-2a_ib_i)+\\sum_{i=1}^nb_i^2-r^2=\\sum_{i=1}^n(-a_i^2)$ 其中$sum_{i=1}^nb_i^2-r^2$可视为一个系数为1的变量，其余项的系数为$-2a_i$ 这样我们就得到了一个关于$b_i$的$n+1$项方程组 利用高斯消元求解即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int n;double pos[20][20],mat[20][20],ans[20];inline void Gauss()&#123; for(int i=1;i&lt;=n;i++)&#123; int major=i; for(int j=i+1;j&lt;=n;j++) if(fabs(mat[major][i])&lt;fabs(mat[j][i])) major=j; if(major!=i) swap(mat[i],mat[major]); for(int j=i+1;j&lt;=n+1;j++) mat[i][j]/=mat[i][i]; mat[i][i]=1; for(int j=1;j&lt;=n;j++)&#123; if(i==j) continue; for(int k=i+1;k&lt;=n+1;k++) mat[j][k]-=mat[i][k]*mat[j][i]; mat[j][i]=0; &#125; &#125; for(int i=1;i&lt;=n;i++) ans[i]=mat[i][n+1];&#125;int main()&#123; scanf(\"%d\",&amp;n); n++; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;n;j++)&#123; scanf(\"%lf\",&amp;pos[i][j]); mat[i][j]=-2*pos[i][j]; mat[i][n+1]-=pos[i][j]*pos[i][j]; mat[i][n]=1; &#125; Gauss(); for(int i=1;i&lt;=n-1;i++) printf(\"%.3lf \",ans[i]); return 0;&#125; PS：打$L^AT_EX$好累啊。。。。","tags":[{"name":"数论","slug":"数论","permalink":"http://blog.southe3n.cf/tags/数论/"}]},{"title":"【学习笔记】BSGS算法","date":"2018-05-31T12:51:47.000Z","path":"2018/05/31/xuexibijibsgssuanfa/","text":"慌张思考BSGS算法(模板题 POJ2417 Discrete Logging)-写在前面（大致是瞎扯，赶时间直接跳吧） 今天又愉(ku)快(bi)地在BZOJ写题，碰见介个—&gt;BZOJ 2242: [SDOI2011]计算器要求对于给定的 $y,z,p$ 满足三种操作: 求 $y^z \\bmod p$ 的值 $xy\\equiv z \\pmod p$ $ y^x\\equiv z \\pmod p $对于操作 2,3 求满足条件的最小$ x$ 操作1,2自然可以快速幂和费马小定理愉快的秒掉啦，但是操作3怎么办呢？求助了一波机房大佬$ Zqlwmatt$（%%%%%）,似乎需要一个叫做BSGS（拔山盖世）算法的东西？？？赶紧来学习一波~~~~ 我是不会说其实是因为太久没更新了强行更新一波才写的 -概念及定义 bsgs（baby step giant step）算法用于解决求满足 $y^x\\equiv z \\pmod p$ 最小的 $x$ 值 时间复杂度为 $O(\\sqrt{p})$ 实质是利用分块的思想，将枚举$x$的复杂度降低 这个算法只适用于 $p$ 为素数 且 $(y,p)$ 互质的情况 -主要思想令 $m=\\biggl\\lceil\\sqrt{p}\\biggr\\rceil$ ，即分块的大小所求 x=i*m-j则原式就可以转化为 y^{i*m-j}\\equiv z \\pmod p移项得 y^{i*m} \\equiv z*y^j \\pmod p我们先枚举 $j$ (范围 $0$ ~ $m$ ) 求得 z*y^j 存入一个 map 中再枚举 $i$（范围 $1$ ~ $m$ ）从 $map$ 中找出最小的 $i$ 满足 y^{i*m}\\equiv z*y^j \\pmod p 此时 $x=i*m-j$ 就是满足要求的最小 $x$ 若在 $1$ ~ $m$ 的范围内无法找到符合条件的 $x$ 则表明没有符合条件的 $x$ -代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;cmath&gt; using namespace std;inline long long fastpow(long long x,long long y,int p)&#123; long long res=1; while(y)&#123; if(y&amp;1) res=res*x%p; x=x*x%p; y&gt;&gt;=1; &#125; return res;&#125;long long p,a,b;map&lt;long long,int&gt;mp;int main()&#123; while(scanf(\"%lld%lld%lld\",&amp;p,&amp;a,&amp;b)!=EOF)&#123; mp.clear(); if(a%p==0)&#123; puts(\"no solution\"); continue; &#125; int flg=0,m=(int)sqrt((double)p)+1; long long now,t=fastpow(a,m,p); now=b%p; mp[now]=0; for(int j=1;j&lt;=m;j++)&#123; now=(now*a)%p; mp[now]=j; &#125; now=1; for(int i=1;i&lt;=m;i++)&#123; now=now*t%p; if(mp[now])&#123; flg=1; printf(\"%lld\\n\",((m*i-mp[now])%p+p)%p); break; &#125; &#125; if(!flg) puts(\"no solution\"); &#125; return 0;&#125; -扩展BSGS似乎还有可以处理 $p$ 不是整数的情况的扩展BSGS算法??学会了再更（逃逃逃逃逃）","tags":[{"name":"分块","slug":"分块","permalink":"http://blog.southe3n.cf/tags/分块/"},{"name":"数论","slug":"数论","permalink":"http://blog.southe3n.cf/tags/数论/"}]},{"title":"【学习计划】BZOJ","date":"2018-05-25T11:52:52.000Z","path":"2018/05/25/xuexijihuabzoj/","text":"没有权限号，怕是。。能把非权限题刷完就不错了已咕，捂脸 1192 1000 1002 1968 1008 2038 3289 2463 2456 3751 3680 2330 3436 1854 3211 3212 1051 10501015 2002 1452 3732 1832 1787 2763 1191 2151 2242 1013 2705 2654 1877 1053 2662 1588 15073224 1500 1036 2243 2049 1507 2002 1036 3669 3110 3196 3223 3295 2157 4325 1251 1552 35063038 1699 1636 3282 1180 1146 3276 1984 3110 1901 2738 2527 3524 2223 2527 2588 2683 11763262 1901 1861 1602 3239 1878 3339 3585 2141 3809 3236 3781 1103 3653 2560 2561 1001 18341059 4326 3514 3545 3551 1066 1355 3931 1562 1370 3306 1367 1455 2819 2208 1529 1589 36732286 3252 1922 1179 1654 3040 1086 3611 1041 3172 1212 2594 2565 2563 2564 3932 3207 26311483 2733 4034 3626 4196 2843 4066 2716 2648 1941 2716 2850 2626 3053 3123 3706 2179 21942815 3798 3758 1026 3122 1031 2190 1607 2818 3505 2326 1297 2721 2186 3450 3211 3261 31662741 4103 3439 3289 3744 2982 3782 3757 3052 4129 2639 2599 2152 3697 1758 1095 1468 37843365 4016 3648 2178 1845 1101 2820 2693 4174 2659 1683 1001 3667 3000 3040 3028 3771 36962685 2318 3589 2393 3509 2054 3815 1770 1914 1132 3265 3251 4311 2671 1430 1123 1145 32621005 1007 1012 1014 1027 1029 1038 1042 1043 1057 1069 1076 1085 1208 1415 1426 1441 15021503 1597 1660 1856 1913 1923 1951 2005 2006 2115 2120 2124 2154 2257 2301 2338 2346 24402460 2568 2595 2622 2753 2823 2875 3039 3065 3083 3170 3210 3309 3401 3529 2178 2738 17171692 2251 2432 3451 2049 4069 2296 3119 3257 3802 3136 4259 2770 3901 2679 3511 3283 22264515 4514 4516 4518 4517 2395 3456 4269 4538 4539 4542 4537 4540 4545 4519 4520 4521 45264519 3834 1662 4523 4524 4522 3131 4008 3696 3456 2618 2178 4196 3917 2908 3838 2839 20241249 4038 3894 4327 3209 1026 3329 2458 4513 3007 2780 1061 3265 2215 3498 2344 4421 44514435 4452 4436 4449 4404 3112 4425 4429 4428 4430 4426 4431 4427 4441 4439 4440 4438 36003682 3658 3659 3720 4456 2362 1835 2827 3779 1087 2064 2693 2480 3530 4651 1398 3956 39942126 2125 4662 4664 4665 4666 4669 4668 4524 2759 3637 3639 3224 4712 3832 4476 4475 44773932 4482 4481 4231 2739 2216 4652 4643 4644 4128 2844 3105 4004 3777 3778 3145 3902 34733694 3692 3693 3695 3696 4771 4770 4766 3946 4284 4285 4003 4533 1137 3667 3223 3689 42904816 4818 4817 4830 4861 4860 3667 4327 4878 3884 4286 2917 4813 3588 3589 4282 3197 45183223 4555 1455 1797 4518 2648 1477 2976 4128 4031 3667 1467 1051 1123 4500 3998 2882 10692215 1061 3238 4327","tags":[]},{"title":"【学习笔记】LinkCutTree","date":"2018-05-18T13:13:21.000Z","path":"2018/05/18/xuexibijilinkcuttree/","text":"洛谷 P3690 【模板】Link Cut Tree （动态树）还是那句话，先把代码贴上来，这种史诗级巨坑怕是填不动的（逃逃逃逃逃）等我哪天（一年后？）有空了再来填吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;using namespace std;const int N=300000;int ch[N][2],sum[N],rev[N],val[N],fa[N],st[N];int n,m,top;inline void swap(int &amp;y,int &amp;x)&#123;int t=x;x=y,y=t;&#125;inline int isroot(int u)&#123; return ch[fa[u]][0]!=u&amp;&amp;ch[fa[u]][1]!=u;&#125;inline void pushdown(int u)&#123; //下放反转标记 if(!rev[u]) return; rev[ch[u][0]]^=1; rev[ch[u][1]]^=1; swap(ch[u][0],ch[u][1]); rev[u]=0;&#125;inline void update(int u)&#123; //更新splay异或和 sum[u]=sum[ch[u][0]]^sum[ch[u][1]]^val[u];&#125;// ===========================Splay部分===================================== inline void rotate(int u)&#123; int f=fa[u],grandf=fa[f],d=(ch[f][1]==u); if(!isroot(f)) ch[grandf][ch[grandf][1]==f]=u; fa[u]=grandf; ch[f][d]=ch[u][!d],fa[ch[u][!d]]=f; ch[u][!d]=f,fa[f]=u; update(f);&#125;inline void splay(int u)&#123; st[top=1]=u; for(int i=u;!isroot(i);i=fa[i]) st[++top]=fa[i]; while(top) pushdown(st[top]),top--; int f,grandf; while(!isroot(u))&#123; f=fa[u],grandf=fa[f]; if(!isroot(f)) ((ch[grandf][0]==f)==(ch[f][0]==u))?rotate(f):rotate(u); rotate(u); &#125; update(u);//splay的过程中不断向splay的根更新信息 &#125;//============================LCT部分======================================== inline int access(int u)&#123; //先将当前结点splay到根，再切断其右儿子，不断向上开辟路径，直到当且结点为原树的根 int now=0; while(u) &#123; splay(u); ch[u][1]=now; now=u; u=fa[u]; &#125; return now;&#125;inline void makeroot(int u)&#123; //使u点成为原树的根，先与根连出路径，再将整棵splay翻转即可 access(u),splay(u),rev[u]^=1;&#125;inline int findroot(int u)&#123; //由于根节点一定比u点深度低，将u splay到根，再不断向左儿子寻找即可 access(u),splay(u); int now=u; while(ch[now][0]) now=ch[now][0]; return now;&#125;inline void link(int u,int v)&#123; //连接两棵树（注意不是指splay树！！！） if(findroot(u)==findroot(v)) return; makeroot(u); fa[u]=v;//只需要标记父结点，儿子结点不需要标记 splay(v);&#125;inline void cut(int u,int v)&#123; makeroot(u); access(v); splay(v); if (fa[u]!=v&amp;&amp;!ch[u][1]) return;//判断是否有边条件记牢。。 ch[v][0]=(fa[u]=0);&#125;inline void change(int u,int x)&#123; splay(u); sum[u]^=val[u]^x; val[u]=x;&#125;inline int query(int u,int v)&#123; //要查询一条链上的信息，先把这条链构建成一棵splay，再查询其根结点的信息就可以了 makeroot(u);access(v);splay(v); return sum[v];&#125;int main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(\"%d\",&amp;val[i]); int opt,x,y; while(m--) &#123; scanf(\"%d%d%d\",&amp;opt,&amp;x,&amp;y); if(opt==0) printf(\"%d\\n\",query(x,y)); if(opt==1) link(x,y); if(opt==2) cut(x,y); if(opt==3) change(x,y); &#125; return 0;&#125;","tags":[{"name":"LCT","slug":"LCT","permalink":"http://blog.southe3n.cf/tags/LCT/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://blog.southe3n.cf/tags/高级数据结构/"}]},{"title":"[ZJOI2013]K大数查询","date":"2018-05-09T11:05:17.000Z","path":"2018/05/09/zjoi2013kdashuchaxun/","text":"洛谷 P3332 [ZJOI2013]K大数查询BZOJ 3110刚刚在安利下，做了道树套树的近似模板题吧这是一道 权值线段树 套 区间线段树 的题，要求动态修改区间，动态查询区间第 $k$ 大数若外层区间为$（l,r）$，内层为$（a,b）$，则表示在$（a,b）$区间内，权值在$（l,r）$中的数有多少个。 感谢lyc的倾情讲解 时间复杂度：$O(N \\log^2 N)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;using namespace std;inline long long max(long long x,long long y)&#123;return x&gt;y?x:y;&#125;inline long long min(long long x,long long y)&#123;return x&lt;y?x:y;&#125;const int N=100000&lt;&lt;7;int a,x,y,z,n,m;int lazy[N],lson[N],rson[N],root[410000],cnt;long long sum[N];void add(int &amp;u,int l,int r)&#123; if(!u) u=++cnt; if(x&lt;=l&amp;&amp;y&gt;=r)&#123; sum[u]+=r-l+1; lazy[u]++; return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) add(lson[u],l,mid); if(y&gt;mid) add(rson[u],mid+1,r); sum[u]=sum[lson[u]]+sum[rson[u]]+lazy[u]*(r-l+1);&#125;void ins(int u,int l,int r)&#123; add(root[u],1,n); if(l==r) return; int mid=l+r&gt;&gt;1; if(z&lt;=mid) ins(u&lt;&lt;1,l,mid); else ins(u&lt;&lt;1|1,mid+1,r);&#125;long long ask(int u,int l,int r)&#123; if(x&lt;=l&amp;&amp;y&gt;=r) return sum[u]; int mid=l+r&gt;&gt;1; long long res=0; if(x&lt;=mid) res+=ask(lson[u],l,mid); if(y&gt;mid) res+=ask(rson[u],mid+1,r); res+=lazy[u]*(min(y,r)-max(x,l)+1); return res;&#125;int query(int u,int l,int r)&#123; if(l==r) return l; int mid=l+r&gt;&gt;1; long long rsize=ask(root[u&lt;&lt;1|1],1,n); //查询时判断右子区间有多少个数，若大于所求排名则 排名-=rsize并继续在左子区间中查询 //否则在右子区间中查询 if(z&gt;rsize)&#123; z-=rsize; return query(u&lt;&lt;1,l,mid); &#125;else return query(u&lt;&lt;1|1,mid+1,r);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); while(m--)&#123; scanf(\"%d%d%d%d\",&amp;a,&amp;x,&amp;y,&amp;z); if(a==1) ins(1,-50000,50000); else printf(\"%d\\n\",query(1,-50000,50000)); &#125; return 0;&#125;","tags":[{"name":"线段树","slug":"线段树","permalink":"http://blog.southe3n.cf/tags/线段树/"},{"name":"树套树","slug":"树套树","permalink":"http://blog.southe3n.cf/tags/树套树/"}]},{"title":"【学习笔记】树状数组","date":"2018-05-08T09:55:55.000Z","path":"2018/05/08/xuexibijishuzhuangshuzu/","text":"-概念与定义 树状数组(Binary Indexed Tree(B.I.T), Fenwick Tree)是一个查询和修改复杂度都为log(n)的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。 由图例可知，设i的二进制最高位为第 k 位，c[i]记录的是 a[i-2k+1] 到 a[i] 的和而这个 2k 可以通过 i&amp;-i 快速求出 -单点修改，区间查询123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int a,c[500010]= &#123;0&#125;,n,m,f,x,y;inline int lowbit(int x) &#123;return x&amp;-x;&#125;int getsum(int k) &#123; //查询1..k的和 int sum=0; for(int i=k; i&gt;0; i-=lowbit(i)) sum+=c[i]; return sum;&#125;void add(int k,int x) &#123; //将第k个数增加x for(int i=k; i&lt;=n; i+=lowbit(i)) c[i]+=x;&#125;int main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(\"%d\",&amp;a); add(i,a); &#125; for(int i=1; i&lt;=m; i++) &#123; scanf(\"%d%d%d\",&amp;f,&amp;x,&amp;y); if(f==1) add(x,y); else printf(\"%d\\n\",getsum(y)-getsum(x-1)); //求第X-Y区间内数的和 &#125; return 0;&#125; -区间修改，单点查询123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;inline int lowbit(int x) &#123;return x&amp;-x;&#125;using namespace std;long long c[500010];//与原版不同，这里的C[i]记录的是A[i]-A[i-1]（A:原数组）int n,m,q;void add(int k,long long x) &#123; for(int i=k; i&lt;=n; i+=lowbit(i)) c[i]+=x;&#125;long long getsum(int k) &#123; long long sum=0; for(int i=k; i&gt;0; i-=lowbit(i)) sum+=c[i]; return sum;&#125;int main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); long long last=0,now; for (int i=1; i&lt;=n; i++) &#123; scanf(\"%lld\",&amp;now); add(i,now-last); //差分数组 last=now; &#125; for(int i=1; i&lt;=m; i++) &#123; scanf(\"%d\",&amp;q); if (q==1) &#123; int x,y; long long k; scanf(\"%d%d%lld\",&amp;x,&amp;y,&amp;k); add(x,k); //区间修改时，c[x]加上k，c[y+1]减k即可 add(y+1,-k); &#125; else &#123; int x; scanf(\"%d\",&amp;x); printf(\"%lld\\n\",getsum(x)); //a[i]=c[1]+c[2]+c[3]+...+c[i] &#125; &#125; return 0;&#125; -区间修改，区间查询123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#define ll long longusing namespace std;ll n,m,c1[100005],c2[100005];inline void add(int x,int y)&#123; ll add1=y,add2=x*y; for (int i=x;i&lt;=n;i+=i&amp;-i) c1[i]+=add1,c2[i]+=add2;&#125;inline ll query(int x)&#123; ll sum1=0,sum2=0; for (int i=x;i&gt;0;i-=i&amp;-i) sum1+=c1[i],sum2+=c2[i]; return sum1*(x+1)-sum2;&#125;int main() &#123; scanf(\"%lld%lld\",&amp;n,&amp;m); long long x; for(int i=1; i&lt;=n; i++) scanf(\"%lld\",&amp;x),add(i,x),add(i+1,-x); for(int i=1; i&lt;=m; i++) &#123; int t,x,y,z; scanf(\"%d\",&amp;t); if(t==1) &#123; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); add(x,z),add(y+1,-z); &#125; else &#123; scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%lld\\n\",query(y)-query(x-1)); &#125; &#125; return 0;&#125;","tags":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://blog.southe3n.cf/tags/高级数据结构/"}]},{"title":"【学习笔记】树链剖分","date":"2018-05-08T02:34:07.000Z","path":"2018/05/08/xuexibijishulianpoufen/","text":"目前先把代码贴上来以后有时间再更？？？（逃逃逃逃逃）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt; using namespace std;int val[110000],dep[110000],fa[110000],size[110000],son[110000],id[110000],top[110000],newval[110000],dfn;int head[110000],to[210000],nxt[210000],cnt;int n,m,s,p;struct segtree&#123; //线段树 int lazy[410000],sum[410000],l[410000],r[410000]; inline void build(int k,int ll,int rr)&#123; l[k]=ll,r[k]=rr,lazy[k]=0; if(ll==rr)&#123; sum[k]=newval[ll]; if(sum[k]&gt;=p) sum[k]%=p; return; &#125; int mid=ll+rr&gt;&gt;1; build(k&lt;&lt;1,ll,mid); build(k&lt;&lt;1|1,mid+1,rr); sum[k]=sum[k&lt;&lt;1]+sum[k&lt;&lt;1|1]; if(sum[k]&gt;=p) sum[k]%=p; &#125; inline void pushdown(int k)&#123; if(!lazy[k]) return; sum[k&lt;&lt;1]+=lazy[k]*(r[k&lt;&lt;1]-l[k&lt;&lt;1]+1); sum[k&lt;&lt;1|1]+=lazy[k]*(r[k&lt;&lt;1|1]-l[k&lt;&lt;1|1]+1); if(sum[k&lt;&lt;1]&gt;=p) sum[k&lt;&lt;1]%=p; if(sum[k&lt;&lt;1|1]&gt;=p) sum[k&lt;&lt;1|1]%=p; lazy[k&lt;&lt;1]=(lazy[k&lt;&lt;1]+lazy[k])%p; lazy[k&lt;&lt;1|1]=(lazy[k&lt;&lt;1|1]+lazy[k])%p; lazy[k]=0; &#125; inline int query(int k,int x,int y)&#123; if(l[k]==x&amp;&amp;r[k]==y) return sum[k]; pushdown(k); int mid=l[k]+r[k]&gt;&gt;1; if(x&gt;mid) return query(k&lt;&lt;1|1,x,y); else if(y&gt;mid) return (query(k&lt;&lt;1,x,mid)+query(k&lt;&lt;1|1,mid+1,y))%p; else return query(k&lt;&lt;1,x,y); &#125; inline void update(int k,int x,int y,int val)&#123; if(l[k]&gt;=x&amp;&amp;r[k]&lt;=y)&#123; lazy[k]+=val; if(lazy[k]&gt;=p) lazy[k]%=p; sum[k]=sum[k]+val*(r[k]-l[k]+1); if(sum[k]&gt;=p) sum[k]%=p; return; &#125; pushdown(k); int mid=l[k]+r[k]&gt;&gt;1; if(x&gt;mid) update(k&lt;&lt;1|1,x,y,val); else if(y&gt;mid) update(k&lt;&lt;1,x,mid,val),update(k&lt;&lt;1|1,mid+1,y,val); else update(k&lt;&lt;1,x,y,val); sum[k]=sum[k&lt;&lt;1]+sum[k&lt;&lt;1|1]; if(sum[k]&gt;=p) sum[k]%=p; &#125;&#125;sgt;inline void add(int u,int v)&#123; to[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt;&#125;void dfs1(int u,int ff)&#123; dep[u]=dep[ff]+1; size[u]=1; fa[u]=ff; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==ff) continue; dfs1(v,u); size[u]+=size[v]; if(!son[u]||size[v]&gt;size[son[u]]) son[u]=v; &#125;&#125;void dfs2(int u,int topp)&#123; top[u]=topp; id[u]=++dfn; newval[dfn]=val[u]; if(son[u]) dfs2(son[u],topp); for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v!=fa[u]&amp;&amp;v!=son[u]) dfs2(v,v); &#125;&#125;inline void pathchange(int x,int y,int val)&#123;//路径修改 while(top[x]!=top[y]) if(dep[top[x]]&gt;=dep[top[y]]) sgt.update(1,id[top[x]],id[x],val),x=fa[top[x]]; else sgt.update(1,id[top[y]],id[y],val),y=fa[top[y]]; if(dep[x]&lt;=dep[y]) sgt.update(1,id[x],id[y],val); else sgt.update(1,id[y],id[x],val);&#125;inline int pathquery(int x,int y)&#123; //路径查询 int res=0; while(top[x]!=top[y])&#123; if(dep[top[x]]&gt;=dep[top[y]]) res+=sgt.query(1,id[top[x]],id[x]),x=fa[top[x]]; else res+=sgt.query(1,id[top[y]],id[y]),y=fa[top[y]]; if(res&gt;=p) res%=p; &#125; if(dep[x]&lt;=dep[y]) res+=sgt.query(1,id[x],id[y]); else res+=sgt.query(1,id[y],id[x]); if(res&gt;=p) res%=p; return res;&#125;inline void treechange(int u,int val)&#123; //子树修改 sgt.update(1,id[u],id[u]+size[u]-1,val);&#125;inline int treequery(int u)&#123; //子树查询 return sgt.query(1,id[u],id[u]+size[u]-1);&#125;int main()&#123; scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;s,&amp;p); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;val[i]); for(int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs1(s,s); dfs2(s,s); //两次dfs将树进行轻重链剖分 sgt.build(1,1,n); int type,x,y,z; while(m--)&#123; scanf(\"%d\",&amp;type); if(type==1) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),pathchange(x,y,z); if(type==2) scanf(\"%d%d\",&amp;x,&amp;y),printf(\"%d\\n\",pathquery(x,y)); if(type==3) scanf(\"%d%d\",&amp;x,&amp;y),treechange(x,y); if(type==4) scanf(\"%d\",&amp;x),printf(\"%d\\n\",treequery(x)); &#125; return 0;&#125;","tags":[{"name":"树剖","slug":"树剖","permalink":"http://blog.southe3n.cf/tags/树剖/"},{"name":"线段树","slug":"线段树","permalink":"http://blog.southe3n.cf/tags/线段树/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://blog.southe3n.cf/tags/高级数据结构/"}]},{"title":"【学习笔记】可并堆（左偏树）","date":"2018-05-06T10:54:39.000Z","path":"2018/05/06/xuexibijikebingduizuopianshu/","text":"洛谷 P3377 【模板】左偏树（可并堆）-概念及定义二叉堆是一种容器，支持O(logn)删除、插入，O(1)查询最小值的操作，可谓切题必备的数据结构之一，但是当我们需要进行堆的合并操作时，我们会惊喜地发现，需要O(n)的时间，这是我们就需要一个叫可并堆的东西了~~常用的可并堆有三种————左偏树，二项堆，斐波那契堆，这里我们介绍最简单易写的左偏树 左偏树是一棵二叉树，每个结点具有key值和dist值。key值满足堆的性质。dist值定义如下：若结点 u 的左子树或右子树为空，则 u 为外结点，节点i的dist值是节点i到它的后代中最近的外节点所经过的边数。外结点的dist为0，而空节点的dist为-1。 左偏树满足两条基本性质： 堆的性质，即父结点key值小于其子结点key值 结点的左子结点的dist不小于右子结点的dist（即左偏性质）。即dist(left(i))≥dist(right(i))。这条性质是为了使我们可以以更小的代价在堆的其它两个基本操作（插入节点、删除最小节点）进行后维持堆性质。在后面我们就会看到它的作用。 此外，还有一个重要的衍生性质：结点的dist等于它的右子结点的距离加1。 -Merge操作左偏树最主要的操作就是合并两个堆，下面是合并操作的主要过程。。。 在合并操作中，最简单的情况是其中一棵树为空。这时我们只须要返回另一棵树。 若A和B都非空，我们假设A的根节点小于等于B的根节点（否则交换A,B），把A的根节点作为新树的根节点，然后合并A的右子树right(A) 和B（即递归调用merge(right(A) , B )）。 right(A)和B合并后，right(A) 的dist可能会变大，若right(A)的dist 大于left(A) 的dist，左偏树的性质2就会被破坏，我们就需要交换left(A) 和right(A)。 最后，由于right(A) 的距离可能发生改变，我们必须更新A的距离： dist(A) ← dist(right(A)) + 1 其他的操作均可通过调用merge来完成 -代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;ctype.h&gt;using namespace std;inline int read()&#123; int x=0,f=1; char ch; ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48;ch=getchar();&#125; return x*f;&#125;int fa[110000],dist[110000],val[110000],l[110000],r[110000];int n,m;int getf(int x)&#123; while(fa[x]) x=fa[x]; //注意并查集不要路径压缩 return x;&#125; inline void swap(int &amp;x,int &amp;y)&#123;int t=x;x=y,y=t;&#125; int merge(int x,int y)&#123; if(x==0||y==0) return x+y; //当左/右子树为空时，返回另一子树即可 if(val[x]==val[y]?x&gt;y:val[x]&gt;val[y]) swap(x,y);//将根较小的放在左边，作为新的子树的根 r[x]=merge(r[x],y); //右边的子树将放在左边子树的右子树中，所以递归调用，将左边子树的右子树与右边子树合并 fa[r[x]]=x; //更新父节点 if(dist[r[x]]&gt;dist[l[x]]) swap(l[x],r[x]); //若此时新子树的左子树dist比右子树小，则将右子树与左子树调换 dist[x]=dist[r[x]]+1; //根据左偏树的性质，节点的dist值是它右子树dist+1 return x; &#125;inline void pop(int x)&#123; val[x]=-1; //删除后val标记为-1 fa[l[x]]=fa[r[x]]=0; merge(l[x],r[x]);&#125;int main()&#123; n=read(),m=read(); dist[0]=-1; //空结点dist值为-1（很重要！！！） for(int i=1;i&lt;=n;i++) val[i]=read(); int type,x,y; while(m--)&#123; type=read(); if(type==1)&#123; x=read(),y=read(); if(val[x]==-1||val[y]==-1) continue; int fx=getf(x),fy=getf(y); if(fx==fy) continue; merge(fx,fy); &#125;else&#123; x=read(); if(val[x]==-1) puts(\"-1\"); else&#123; int fx=getf(x); printf(\"%d\\n\",val[fx]); pop(fx); &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://blog.southe3n.cf/tags/高级数据结构/"}]},{"title":"【学习笔记】网络最大流","date":"2018-05-02T02:19:15.000Z","path":"2018/05/02/xuexibijiwangluozuidaliu/","text":"洛谷 P3376 【模板】网络最大流-概念及定义 设图G(V,E)为一个有向带权图，指定两个顶点分别为源点和汇点（s和t），边权即为每条边的容量，称为容量网络。求使 s -&gt; t 流量最大的方案，并满足f(u,v) &lt;= c(u,v) （f表示边(u,v)实际流量，c表示边（u,v)容量），s,t 外每个点的流出流量和流入流量相等 如下图即为一个容量网络与其最大流方案，（x,y） 表示边容量为 x，实际流量为 y。 -【Dinic 算法】时间复杂度: 上界$O(V^2E)$，实际使用中一般更快空间复杂度: $O(V+E)$主要思想： 输入零流图，建立残量网络。 用 BFS 将残量网络分层，其中源点为第 1 层。 用 DFS 在分层图中寻找增广路，确保路径上的点的层次递增。 若存在增广路，则在 DFS 回溯时用增流更新残量网络，退出后将其计入总流量。 重复过程2~4，直到在BFS中无法在残量网络中从源点到达汇点，则说明已经没有增广路。输出总流量，即为最大流。 优化：当前弧优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;ll cur[11000],to[210000],w[210000],nxt[210000],head[11000],dep[11000];ll n,m,s,t,cnt,maxflow;inline ll min(int x,int y) &#123;return x&lt;y?x:y;&#125;inline void add(int u,int v,int c) &#123; to[++cnt]=v,w[cnt]=c,nxt[cnt]=head[u],head[u]=cnt; to[++cnt]=u,w[cnt]=0,nxt[cnt]=head[v],head[v]=cnt; //建反向边，初始流为0&#125;queue&lt;ll&gt; q;inline ll bfs() &#123; //在残量网络上构造分层图 memset(dep,0,sizeof dep); while(q.size()) q.pop();//清空队列 q.push(s); dep[s]=1; //将源点入队 while(q.size()) &#123; int u=q.front(); q.pop(); for(int i=head[u]; i; i=nxt[i]) if(w[i]&amp;&amp;!dep[to[i]]) &#123; q.push(to[i]); dep[to[i]]=dep[u]+1; if(to[i]==t) return 1; //到汇点直接退出 &#125; &#125; return 0; //在当前残量网络下，无法从源点到达汇点了&#125;inline ll dinic(int u,int flow) &#123;//在当前分层图上增广 if(u==t) return flow; int k,rest=flow; for(int i=cur[u]; i&amp;&amp;rest; i=nxt[i])&#123; cur[u]=i; //当前弧优化 if(w[i]&amp;&amp;dep[to[i]]==dep[u]+1) &#123; k=dinic(to[i],min(rest,w[i])); if(!k) dep[to[i]]=0; //若当前节点无法继续增广，将其从分层图中删去 w[i]-=k; //在当前边减去流 w[i^1]+=k; //在反向边加上流 rest-=k; //残余容量减去流 &#125; &#125; cur[u]=head[u]; //注意在当前点跑完后将其当前弧标记重置 return flow-rest;&#125;int main() &#123; scanf(\"%lld%lld%lld%lld\",&amp;n,&amp;m,&amp;s,&amp;t); cnt=1; //cnt以1开始，使边的序号从2开始，方便之后的^运算找反向边序号 for(int i=1,x,y,z; i&lt;=m; i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(x,y,z); int flow=0; for(int i=1;i&lt;=n;i++) cur[i]=head[i]; while(bfs()) //运行到无法在残量网络上从源点到汇点为止 while(flow=dinic(s,2e9)) maxflow+=flow; printf(\"%lld\",maxflow); return 0;&#125; -【SAP算法】时间复杂度：上界$O(V^2E)$，大部分情况下比$Dinic$快 主要思想： $Dinic$中每次求分层图都要进行一次bfs，效率比较低下，因为每一次层次图的改动并不是非常大，我们可以考虑直接在dfs增广的时候修改分层图来优化求分层图的过程。 感谢zyh巨爷提供的模板和lyc巨魔的讲解！(略略略略略~） 优化： 若深度标号出现了断层，那么显然无法继续增广。我们用一个count数组记录每个层次的结点有多少个，如果当前修改了最后一个某个层次的结点的深度标号，那么就出现了断层，可以结束运行了。 当前弧优化：增广过程中，如果一个点的深度标号没有修改过，那么它已经遍历过的边不需要再遍历一次，用cur数组记录遍历到哪条边，下一次从这条边开始遍历。 经过每个点后直接将其深度标号+1即可更新分层图。 同Dinic中，如果实际流量已经达到残余容量了直接退出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;ll n,m,s,t,cnt,ans;ll head[11000],nxt[210000],to[210000],w[210000],dep[11000],cur[11000],count[11000];inline ll min(ll x,ll y)&#123;return x&lt;y?x:y;&#125;inline void add(ll u,ll v,ll c)&#123; to[++cnt]=v; nxt[cnt]=head[u]; w[cnt]=c; head[u]=cnt;&#125;ll dfs(ll u,ll maxflow)&#123; if (u==t) return maxflow; ll flow=0; //记录实际流量 for (int i=cur[u];i;i=nxt[i])&#123; cur[u]=i; //当前弧优化 if (w[i]&amp;&amp;dep[to[i]]+1==dep[u])&#123; //只有在分层图中处于点u下一层的点才会去尝试增广 ll now=dfs(to[i],min(w[i],maxflow-flow)); //进行增广 flow+=now; w[i]-=now; w[i^1]+=now; if (maxflow==flow) return flow; //若实际流已经到达当前点的最大流，说明流量不会再增大，直接退出 &#125; &#125; cur[u]=head[u]; //跑完该点后将其当前弧标记重置 if (--count[dep[u]]==0) dep[s]=n; //将该深度的点的数量-1，若分层图中出现断层，则标记退出 count[++dep[u]]++; //将该点深度+1并更新深度计数 return flow;&#125;int main()&#123; scanf(\"%lld%lld%lld%lld\",&amp;n,&amp;m,&amp;s,&amp;t); cnt=1; memset(dep,0,sizeof(dep)); count[0]=n; //初始化深度值，将深度为0的点的数量记为n for(ll i=1,x,y,z;i&lt;=m;i++)&#123; scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,0); //建立反向图 &#125; while(dep[s]&lt;n) //直到获得退出标记 ans+=dfs(s,2e9); printf(\"%lld\",ans); return 0;&#125; -二分图最大匹配用最大流算法解决主要思想： 在原二分图中增加一个源点s和一个汇点t 源点s向集合X每个点连一条有向边，集合Y每个点向汇点t连一条有向边 将原图的每条边改为从集合X向集合Y的有向边 赋每条边的容量为1 求源点到汇点的最大流即为最大匹配 优点：完了，不知道，无脑一点？","tags":[{"name":"图论","slug":"图论","permalink":"http://blog.southe3n.cf/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://blog.southe3n.cf/tags/网络流/"}]},{"title":"【学习笔记】二分图最大匹配(匈牙利算法)","date":"2018-05-01T11:52:54.000Z","path":"2018/05/01/xuexibijierfentuzuidapipeixiongyalisuanfa/","text":"洛谷 P3386 【模板】二分图匹配匈牙利算法$O(nm)$-二分图概念与定义 二分图是图论中的一种特殊模型。设G=(V,E)是一个无向图，如果顶点集V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图无向图G为二分图的充分必要条件是，G至少有两个顶点，且其所有回路的长度均为偶数。 二分图匹配：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。如下图的每一个红线都是二分图的一个匹配： (以上内容均摘自百度百科（略略略略略略）) -算法思想 由增广路的性质，增广路中的匹配边总是比未匹配边多一条，所以如果我们放弃一条增广路中的匹配边，选取未匹配边作为匹配边，则匹配的数量就会增加。匈牙利算法就是在不断寻找增广路，如果找不到增广路，就说明达到了最大匹配。牢记： match[i]数组记录的是右子集中点i的在左子集中的匹配点。 -代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,m,e,to[1100000],nxt[1100000],head[1100],cnt=0,match[1100],vis[1100];inline void add(int u,int v)&#123;to[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt;&#125;inline int augmentable(int u)&#123; //增广 for(int i=head[u];i;i=nxt[i])&#123; //枚举右子集的每个与改点有边的点 if(vis[to[i]]) continue; //若该点已经被增广过，则跳过 vis[to[i]]=1; if(!match[to[i]]||augmentable(match[to[i]])) return match[to[i]]=u; //若该右子集点未被匹配或者该点匹配的左子集点有其他的点可以匹配，则将该右子集点与点u匹配 &#125; return 0;&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;e); for(int i=1,x,y;i&lt;=e;i++)&#123; scanf(\"%d%d\",&amp;x,&amp;y); if(y&lt;=m) add(x,y); &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; 对左子集的每个点枚举其是否可以进行增广 memset(vis,0,sizeof vis); if(augmentable(i)) ans++; &#125; printf(\"%d\",ans); return 0;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"http://blog.southe3n.cf/tags/图论/"}]},{"title":"【学习笔记】乘法逆元","date":"2018-05-01T10:20:27.000Z","path":"2018/05/01/xuexibijichengfaniyuan/","text":"洛谷 P3811 【模板】乘法逆元-概念及定义 若 $ a∗x≡1 \\pmod b $ ，且 a 与 b 互质，那么我们就能定义: x 为 a 的逆元，记为 $ a^{-1} $,所以我们也可以称 x 为 a 的倒数， $ \\frac{a}{b} \\bmod p = a \\times b^{-1} \\bmod p $ 常用的求解方法有两种。 ①应用费马(Fermat)小定理 ②扩展欧几里得(Ευκλειδης) -费马小定理 由费马小定理知，若p为素数且a,p互质，$ a^{p-1}≡1 \\pmod p $ 则: $ a \\times x≡1 \\pmod p $ $ a \\times x≡a^{p-1} \\pmod p $ $ x≡a^{p-2} \\pmod p $ 所以我们可以用快速幂来算出 $ a^{p-2} \\pmod p $ 的值，这个数就是它的逆元了 代码$ O(\\log p) $12345678910ll fastpow(ll a,ll power,ll mod)&#123; a%=mod; ll ans=1,now=a; while(power)&#123; if(power&amp;1) ans=ans*now%mod; now=now*now%mod; power&gt;&gt;=1; &#125; return ans;&#125; -拓展欧几里得大部分情况下效率比快速幂高(尤其对于 p 比较大的时候)。这个就是利用拓欧求解 线性同余方程 $ a \\times x≡1 \\pmod p $我们就可以转化为 $ a \\times x + b \\times y = 1 $求解这个方程的解。 代码$ O(\\log N) $12345678910111213141516ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll gcd=exgcd(b,a%b,x,y); ll tmp=x; x=y; y=tmp-a/b*y; return gcd;&#125;ll inv(ll a,ll mod)&#123; //扩欧求法 ll x,y,d=exgcd(a,mod,x,y); if(d==1) return (x%mod+mod)%mod; //若a和mod互质，将x调整为1~mod-1之间即是逆元 return -1; //若不互质，则不存在逆元 &#125; -线性求法求1~n对于mod p的逆元 $ i^{-1} $即为i的逆元代码$ O(N) $1234inv[1]=1;for(int i=2;i&lt;=n;i++) inv[i] = - (p / i) * inv[p % i], inv[i] = (inv[i] % p + p) % p; //将inv值调整为0~p-1","tags":[{"name":"数论","slug":"数论","permalink":"http://blog.southe3n.cf/tags/数论/"}]},{"title":"【学习笔记】最近公共祖先(LCA)","date":"2018-05-01T07:30:06.000Z","path":"2018/05/01/xuexibijizuijingonggongzuxianlca/","text":"洛谷 P3379 【模板】最近公共祖先（LCA）-概念及定义 最近公共祖先简称LCA（Lowest Common Ancestor），所谓LCA，是当给定一个有根树T时，对于任意两个结点u、v，找到一个离根最远的结点x，使得x同时是u和v的祖先，x 便是u、v的最近公共祖先。 -离线算法Tarjan利用并查集，我们可以实现LCA问题的O(n+q)算法(q:询问次数)。Tarjan算法基于DFS，对于第一次搜索到的结点，先创建由这个结点构成的集合，再对该结点的每一个子树进行搜索，对于搜索完的子树，保证子树内的LCA询问都已解决。其他的LCA询问的结果必然在这个子树之外，这时把子树所形成的集合与该结点的集合合并，并将当前结点设为这个集合的祖先。重复搜索子树的过程，直到当前结点的所有子树搜索完,将当前结点也设为已被搜索过的，查询所有和该结点有询问关系的结点 v，若 v 已被搜索过，由于进行的是深度优先搜索，所以这个最近公共祖先的包含 v 的子树一定已经搜索过了，那么这个最近公共祖先一定是 v 所在集合的祖先。 tarjan部分伪代码123456789101112Tarjan(u)//marge和find为并查集合并和查找操作&#123; for each(u,v)&#123; //访问所有u子节点v Tarjan(v); //继续往下遍历 marge(u,v); //合并v到u上 标记v被访问过; &#125; for each(u,e)&#123; //访问所有和u有询问关系的e 如果e被访问过： u,e的最近公共祖先为find(e); &#125;&#125; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;using namespace std;int n,m,s,fa[510000];struct node &#123; int to,next,no;&#125; e[1110000],q[1100000];int cnt=0,cntq=0,head[510000],headq[510000],ans[510000];bool vis[510000]=&#123;0&#125;;int getf(int x) &#123; return fa[x] == x ? x : fa[x] = getf(fa[x]);&#125;inline void add(int u,int v) &#123; e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;&#125;inline void add_q(int u,int v,int i) &#123; q[++cntq].to=v; q[cntq].next=headq[u]; q[cntq].no=i; headq[u]=cntq;&#125;void tarjan(int u,int f)&#123; vis[u]=1; for(int i=headq[u];i;i=q[i].next) if(vis[q[i].to]) ans[q[i].no]=getf(q[i].to); for(int i=head[u];i;i=e[i].next) if(!vis[e[i].to]) tarjan(e[i].to,u); fa[u]=f;&#125;int main() &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s); for(int i=1,x,y; i&lt;n; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y),add(y,x); &#125; for(int i=1,x,y; i&lt;=m; i++) &#123;//读入查询关系并添加至邻接表中 scanf(\"%d%d\",&amp;x,&amp;y); add_q(x,y,i),add_q(y,x,i); &#125; for(int i=1;i&lt;=n;i++) fa[i]=i; tarjan(s,s); for(int i=1; i&lt;=m; i++) printf(\"%d\\n\",ans[i]); return 0;&#125; -在线算法 倍增时间复杂度O(nlogn)主要思想：每次将向上跳跃的层数折半，以达到求离根最远的公共祖先的目的，查找最近公共祖先时，先使两结点深度相同，再枚举跳跃层数，判断跳跃后是否处于同一结点，若是，则说明若跳该层数就会跳过最近公共祖先，将跳跃层数折半后继续尝试，直到两结点分处于同一结点的左右儿子，则该结点就是最近公共祖先 预处理：通过dfs遍历，标记每个节点到根节点的深度deep[u]，DP求出树上每个节点u的第1&lt;&lt;层祖先f[u][i] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;memory&gt;using namespace std;int n,m,s;int cnt=0,head[510000],deep[510000],f[510000][20],to[1100000],nxt[1100000];inline void add(int u,int v) &#123; to[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt;&#125;void lca_pre()&#123; //预处理出每个节点的向上第1&lt;&lt;i层的祖先 for(int i=1;i&lt;=18;i++) for(int j=1;j&lt;=n;j++) f[j][i]=f[f[j][i-1]][i-1]; //先向上跳1&lt;&lt;(i-1)层，再向上跳到1&lt;&lt;i层 &#125;void dfs(int u)&#123; //标记深度，并将向上跳一层设为其父节点 for(int i=head[u];i;i=nxt[i]) if(!deep[to[i]])&#123; deep[to[i]]=deep[u]+1; f[to[i]][0]=u; dfs(to[i]); &#125;&#125;int lca(int u,int v)&#123; if(deep[u]&lt;deep[v]) swap(u,v);//保证u比v深度大 for(int i=17;i&gt;=0;i--) if(deep[f[u][i]]&gt;=deep[v]) u=f[u][i]; //将两点跳至同一深度 if(u==v) return v; //若此时两点已相同，说明v是u的祖先 for(int i=17;i&gt;=0;i--) if(f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i]; //两节点一起向上跳，直到处于他们公共祖先的左右儿子上 return f[u][0]; //返回两节点的上一层 &#125;int main() &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s); for(int i=1,x,y; i&lt;n; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); add(x,y),add(y,x); &#125; deep[s]=1; dfs(s); lca_pre(); for(int i=1,x,y; i&lt;=m; i++) &#123; scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%d\\n\",lca(x,y)); &#125; return 0;&#125; -在线算法 树剖时间复杂度O(2n+mlogn)，且常数较小，似乎比倍增快好多 主要思想：两次dfs进行预处理，将树分为若干条不相交的轻重链，每次求LCA（x,y）时判断两点是否在同一链上若是则我们只要找到这两点中深度较小的点输出如果两点不在同一条链上那就找到深度较大的点令它等于它所在的重链链端的父节点即为x=f[top[x]]直到两点到达同一条链上，输出两点中深度较小的点 各数组意义： size[u] 保存以u为根的子树节点个数 top[u] 保存当前节点所在链的顶端节点（轻儿子的 top 为他自己） son[u] 保存重儿子（重儿子：对于每个结点 u，其重儿子为其子结点中 size 值最大的结点，其余子结点为轻儿子） dep[u] 保存结点u的深度值 fa[u] 保存结点u的父亲节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;ctype.h&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int x=0,f=1; char ch; ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48;ch=getchar();&#125; return x*f;&#125;int to[1100000],nxt[1100000],head[510000],cnt;int n,m,s,dep[500005],size[500005],son[500005],top[500005],fa[500005];inline void add(int u,int v)&#123; to[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt;&#125;void dfs1(int u,int ff)&#123; //第一次dfs求出各点dep,fa,size,son dep[u]=dep[ff]+1; fa[u]=ff; size[u]=1; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v==ff) continue; dfs1(v,u); size[u]+=size[v]; if(!son[u]||size[v]&gt;size[son[u]]) son[u]=v; &#125;&#125;void dfs2(int u,int topp)&#123; //第二次dfs求出各点top top[u]=topp; if(son[u]) dfs2(son[u],topp); for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v!=son[u]&amp;&amp;v!=fa[u]) dfs2(v,v); &#125;&#125;inline int lca(int x,int y)&#123; //求LCA时，不断将top较深的点跳至其 top 的父节点，直到两个结点在同一条重链上 while(top[x]!=top[y]) if(dep[top[x]]&gt;=dep[top[y]]) x=fa[top[x]]; else y=fa[top[y]]; return dep[x]&lt;dep[y]?x:y;&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s); for(int i=1,x,y;i&lt;n;i++) x=read(),y=read(),add(x,y),add(y,x); dfs1(s,s); dfs2(s,s); int a,b; while(m--)&#123; a=read(),b=read(); printf(\"%d\\n\",lca(a,b)); &#125; return 0;&#125;","tags":[{"name":"LCA，树剖","slug":"LCA，树剖","permalink":"http://blog.southe3n.cf/tags/LCA，树剖/"}]},{"title":"【学习笔记】非旋Treap","date":"2018-05-01T05:53:05.000Z","path":"2018/05/01/xuexibijifeixuantreap/","text":"洛谷 P3369 【模板】普通平衡树（Treap/SBT）-概念与定义 Treap=Tree+Heap Treap是一颗同时拥有二叉搜索树和堆性质的一颗二叉树 Treap有两个关键字，在这里定义为： 1.key，满足二叉搜索树性质，即中序遍历按照key值有序 2.heap，满足小根堆性质 为了满足期望，heap值是一个随机的权值，用来保证树高期望为logn 剩下的key值则是用来维护我们想要维护的一个权值，此为一个二叉搜索树的基本要素 简单来说，通过加入一个随机生成的值，并在建树过程中保证该值满足堆（小根堆）的形式，使得二叉搜索树的深度近似于logN来加快各种操作的速度资瓷的操作： 插入xx数 删除xx数(若有多个相同的数，只删除一个) 查询xx数的排名(排名定义为比当前数小的数的个数+1。若有多个相同的数，输出最小的排名) 查询排名为xx的数 求xx的前驱(前驱定义为小于xx，且最大的数) 求xx的后继(后继定义为大于xx，且最小的数) -实现方法为保证堆的性质，需要在建树时对树进行旋转或切割为代替原来的旋转操作，我们引入两个神奇的函数来保持树的平衡： split(u, k)，将以 u 为根节点的 Treap 在第 k 个元素后分裂，并返回分裂出来的两个根。 merge(u, v)，将元素相对有序的两棵 Treap 合并为一棵，维护堆性质，并返回合并后的根。 每一个split和merge都是O(logn)复杂度 对于各操作： 插入：insert = split + merge + merge ⇒ O(logn) 删除：erase = split + split + merge ⇒ O(logn) 数-&gt;排名/排名-&gt;数：通过二叉排序树的性质进行查找 前驱：将所有比x小的数切下，找到其中最大的数后，再合并 后继：将所有比x小的数以及x切下，在剩下的树中找出最小的数后，再合并 这样就能够完美地处理名次问题了，虽然常数较传统 Treap 略大。而利用 split 和 merge 操作，可以 O(logn) 将区间分离出来，进行区间处理。 Any interval = split + split + merge + merge ⇒ O(logn) 非旋 Treap 还可以进行可持久化操作（Emmmm….不会（逃逃逃））。 -代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;struct Tnode &#123; int l,r,num,size,heap;&#125; t[100100];struct xx &#123; int l,r;&#125;;int n,type,x,cnt=0,Root;void update(int u) &#123; //更新以u为根的子树的size t[u].size=t[t[u].l].size+t[t[u].r].size+1;&#125;xx split(int u,int k) &#123; //从以u为根的子树上割下k个点 xx result= &#123;0,0&#125;; //记录切割后左子树的根节点和右子树的根节点 if(!u) return result; int lsize=t[t[u].l].size+1; if(k&gt;=lsize) &#123; //若需要切下的点比整个左子树多，从右子树继续割 result=split(t[u].r,k-lsize); t[u].r=result.l; result.l=u; &#125; else &#123; result=split(t[u].l,k); t[u].l=result.r; result.r=u; &#125; update(u); //更新以u为根节点的子树的size return result; //返回左右子树根节点&#125;int merge(int l,int r) &#123; //将两棵TREAP合并（严格按照heap值大小合并（小根堆））返回根节点 if(!l) return r; //若左子树为空，返回右子树 if(!r) return l; if(t[l].heap&lt;t[r].heap) &#123; //若左子树heap比右子树小，将右子树接在左子树的右儿子中 t[l].r=merge(t[l].r,r); update(l); return l; &#125; else &#123; //否则将左子树接在右子树左儿子中 t[r].l=merge(l,t[r].l); update(r); return r; &#125;&#125;int rank(int x) &#123; //根据数值查有多少个数严格比x小 int now=Root,result=0; while(now) &#123; if(x&gt;t[now].num) &#123; result+=t[t[now].l].size+1; now=t[now].r; &#125; else now=t[now].l; &#125; return result;&#125; int No_k(int u,int x)&#123; //在以u为根节点的树中，找第x小的数 int now=u; while(1)&#123; int num=t[t[now].l].size+1; if(x==num) return t[now].num; if(x&lt;num) now=t[now].l; else x-=num,now=t[now].r; &#125; &#125;void insert(int x) &#123; //插入一个数值为x的数 t[++cnt].num=x; t[cnt].heap=rand(); //随机生成heap值，使树保持相对平衡 t[cnt].size=1; xx p=split(Root,rank(x)); //查找x在树中的rank，将比x小的数从树中切下 Root=merge(merge(p.l,cnt),p.r); //先将x与左子树合并，再将左子树和右子树合并，并更新根节点Root &#125;void del(int x)&#123; xx p1=split(Root,rank(x)); xx p2=split(p1.r,1); Root=merge(p1.l,p2.r); &#125; int pre(int x)&#123; //查找第一个比x小的数 xx p=split(Root,rank(x)); //将所有比x小的数（不包括x）切下 int result=No_k(p.l,t[p.l].size); //找到切下的树中最大的 Root=merge(p.l,p.r); //将两子树重新合并 return result; &#125;int suc(int x)&#123; //查找第一个比x大的数 xx p=split(Root,rank(x+1)); //将所有比x小的数（包括x）切下 int result=No_k(p.r,1); //查找剩下的数中最小的 Root=merge(p.l,p.r); return result;&#125; int main() &#123; scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(\"%d%d\",&amp;type,&amp;x); if(type==1) insert(x); if(type==2) del(x); if(type==3) printf(\"%d\\n\",rank(x)+1); //rank是比x小的数的个数，不包括x，所以要+1 if(type==4) printf(\"%d\\n\",No_k(Root,x)); if(type==5) printf(\"%d\\n\",pre(x)); if(type==6) printf(\"%d\\n\",suc(x)); &#125; return 0;&#125;","tags":[{"name":"平衡树","slug":"平衡树","permalink":"http://blog.southe3n.cf/tags/平衡树/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://blog.southe3n.cf/tags/高级数据结构/"}]},{"title":"【学习笔记】线段树","date":"2018-05-01T04:43:38.000Z","path":"2018/05/01/xuexibijixianduanshu/","text":"洛谷 P3373 【模板】线段树 2-概念及定义线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。 支持的操作： 1.将某区间每一个数乘上x 2.将某区间每一个数加上x 3.求出某区间每一个数的和 区间修改：不断向下层寻找完全包含在需修改区间中的区间，并在修改后将值向上传递区间查询：与修改同理，自顶向下寻找，自底向上传递数据并处理（求和/求GCD/求最大值…) 可以用线段树解决的问题必须满足区间加法，例如求区间GCD=gcd(左区间GCD，右区间GCD），区间和，区间最大值… -重要优化-lazytag我们会发现，如果每次修改/查询都从底层向上层逐层修改/查询，效率将会非常低下，这时我们就需要引入一个叫lazytag的骚东西。原理：只计算出确实需要访问的区间的真实值，其他的保存在lazytag里面，这样可以做到近似O(NlogN)。每当当前区间的一致性将会遭到破坏（当前区间不完全包含在区间修改/查询的区间，需要进入下一层）时，将lazytag下放到下一层，需要同时修改子区间的sum和lazy。面对需要同时支持区间乘和区间加的情况，我们需要使用两个lazytag分别记录乘法和加法。需要采用乘法优先的策略，即规定好t[root2].sum=(t[root2].sumt[root].mul_tag+t[root].add_tag(本区间长度))%p，改变add的数值就只改变add_tag，改变mul的时候把add_tag也对应的乘一下就可以了 -代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;typedef long long ll;using namespace std;ll n,m,p,a[101000];struct segtree &#123; struct &#123; ll sum,lazy1,lazy2; //lazy1乘法tag，lazy2加法tag int l,r; &#125; t[10001000]; inline void build(int k,int l,int r) &#123; //建树 t[k].l=l,t[k].r=r,t[k].lazy1=1,t[k].lazy2=0; if(l==r) &#123; t[k].sum=a[l]%p; return; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build((k&lt;&lt;1)+1,mid+1,r); t[k].sum=(t[k&lt;&lt;1].sum+t[(k&lt;&lt;1)+1].sum)%p; //将子段和上传 &#125; inline void pushdown(int k) &#123; //将lazy值下放，先下放乘法，再下放加法 int k1=k&lt;&lt;1; if(t[k].lazy1!=1) &#123; t[k1].lazy2=t[k1].lazy2*t[k].lazy1%p; t[k1+1].lazy2=t[k1+1].lazy2*t[k].lazy1%p; t[k1].lazy1=t[k1].lazy1*t[k].lazy1%p; t[k1+1].lazy1=t[k1+1].lazy1*t[k].lazy1%p; t[k1].sum=t[k1].sum*t[k].lazy1%p; t[k1+1].sum=t[k1+1].sum*t[k].lazy1%p; t[k].lazy1=1; &#125; if(t[k].lazy2) &#123; t[k1].lazy2=(t[k1].lazy2+t[k].lazy2)%p; t[k1+1].lazy2=(t[k1+1].lazy2+t[k].lazy2)%p; t[k1].sum=(t[k1].sum+t[k].lazy2*(t[k1].r-t[k1].l+1))%p; t[k1+1].sum=(t[k1+1].sum+t[k].lazy2*(t[k1+1].r-t[k1+1].l+1))%p; t[k].lazy2=0; &#125; &#125; ll query(int k,int x,int y) &#123; //x，y标记需要修改的区间，k为当前区间序号 if(t[k].l==x&amp;&amp;t[k].r==y)//查找的区间与当前区间完全重合，直接返回当前区间的和 return t[k].sum; pushdown(k); //将lazy值下放 int mid=(t[k].l+t[k].r)&gt;&gt;1; if(x&gt;mid) return query((k&lt;&lt;1)+1,x,y);//若需修改区间完全在右子段 else if(y&gt;mid) return (query(k&lt;&lt;1,x,mid)+query((k&lt;&lt;1)+1,mid+1,y))%p;//需修改区间同时在左右子段 else return query(k&lt;&lt;1,x,y); //需修改区间完全在左子段 &#125; void update1(int k,int x,int y,int val) &#123; //区间乘 if(t[k].l&gt;=x&amp;&amp;t[k].r&lt;=y) &#123;//若当前线段包含在需修改线段中，直接修改 t[k].lazy1=t[k].lazy1*val%p; t[k].lazy2=t[k].lazy2*val%p; t[k].sum=t[k].sum*val%p; return; &#125; pushdown(k); //将lazy值下放 int mid=(t[k].l+t[k].r)&gt;&gt;1; if(x&gt;mid) update1((k&lt;&lt;1)+1,x,y,val); else if(y&gt;mid) &#123; update1(k&lt;&lt;1,x,mid,val); update1((k&lt;&lt;1)+1,mid+1,y,val); &#125; else update1(k&lt;&lt;1,x,y,val); t[k].sum=(t[k&lt;&lt;1].sum+t[k&lt;&lt;1|1].sum)%p;//将左右子段和上传 &#125; void update2(int k,int x,int y,int val) &#123; //区间加 if(t[k].l&gt;=x&amp;&amp;t[k].r&lt;=y) &#123;//若当前线段包含在需修改线段中，直接修改 t[k].lazy2=(t[k].lazy2+val)%p; t[k].sum=(t[k].sum+val*(t[k].r-t[k].l+1))%p; return; &#125; pushdown(k); //将lazy值下放 int mid=(t[k].l+t[k].r)&gt;&gt;1; if(x&gt;mid) update2((k&lt;&lt;1)+1,x,y,val); else if(y&gt;mid) &#123; update2(k&lt;&lt;1,x,mid,val); update2((k&lt;&lt;1)+1,mid+1,y,val); &#125; else update2(k&lt;&lt;1,x,y,val); t[k].sum=(t[k&lt;&lt;1].sum+t[k&lt;&lt;1|1].sum)%p;//将左右子段和上传 &#125;&#125; sgt;int main() &#123; scanf(\"%lld%lld%lld\",&amp;n,&amp;m,&amp;p); for(int i=1; i&lt;=n; i++) scanf(\"%lld\",&amp;a[i]); sgt.build(1,1,n); while(m--) &#123; int type; scanf(\"%d\",&amp;type); if(type==1) &#123; ll x,y,k; scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;k); sgt.update1(1,x,y,k); &#125; if(type==2) &#123; ll x,y,k; scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;k); sgt.update2(1,x,y,k); &#125; if(type==3) &#123; ll x,y; scanf(\"%lld%lld\",&amp;x,&amp;y); printf(\"%lld\\n\",sgt.query(1,x,y)); &#125; &#125; return 0;&#125;","tags":[{"name":"线段树","slug":"线段树","permalink":"http://blog.southe3n.cf/tags/线段树/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"http://blog.southe3n.cf/tags/高级数据结构/"}]},{"title":"【学习笔记】SPFA","date":"2018-05-01T02:08:12.000Z","path":"2018/05/01/xuexibijispfa/","text":"洛谷 P3371 【模板】单源最短路径主要思想：设立一个队列q保存待优化的结点，每次取出队首结点u，并且用u点当前的dis值对所有u的边指向的点v进行松弛操作，如果v点的dis值被松驰，且v点不在当前的队列中，就将v点入队。不断从队列中取出结点进行松弛操作，直至队列空为止。松弛操作：“三角形两边之和大于第三边”。是判定是否dis[j]&gt;dis[i]+w[i,j]，若成立，则松驰成功，将dis[j]赋为dis[i]+w[i,j]12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,m,s,dis[10010],q[100010],head[10100],cnt,to[510000],nxt[510000],w[510000],vis[10010];void addedge(int a,int b,int c) &#123; to[++cnt]=b, nxt[cnt]=head[a]; w[cnt]=c; head[a]=cnt;&#125;void SPFA(int s) &#123; int l=0,r=1; memset(dis,0x7f,sizeof(dis)); dis[s]=0; //初始化 memset(vis,0,sizeof(vis)); vis[s]=1; //标记是否在队列中 q[r]=s; //将起点入队 while(l&lt;r) &#123; int u=q[++l];vis[u]=0; //队头出队 for(int i=head[u]; i; i=nxt[i]) //遍历所有与当前点的边指向的点是否可以松驰 if(dis[u]+w[i]&lt;dis[to[i]]) &#123; dis[to[i]]=dis[u]+w[i]; if(!vis[to[i]]) q[++r]=to[i],vis[to[i]]=1; //若该点不在队列中，将该点入队 &#125; &#125;&#125;int main() &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s); for(int i=1,a,b,c; i&lt;=m; i++) &#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); addedge(a,b,c); &#125; SPFA(s); for(int i=1; i&lt;=n; i++) if(dis[i]&lt;2e9)printf(\"%d \",dis[i]); else printf(\"2147483647 \");&#125;","tags":[{"name":"图论","slug":"图论","permalink":"http://blog.southe3n.cf/tags/图论/"},{"name":"最短路","slug":"最短路","permalink":"http://blog.southe3n.cf/tags/最短路/"}]},{"title":"【学习笔记】AC自动机","date":"2018-05-01T01:00:00.000Z","path":"2018/05/01/xuexibijiaczidongji/","text":"Aho-Corasick AutomatonAC 自动机可以理解为 Trie + KMP，即用多个模式串建立 Trie，然后用 BFS 求出失配指针 fail。可以解决多个模式串在一个文本串中是否出现的问题。如下图，黑边为 Trie 树边，红边和蓝边为 fail 指针。建立Trie-&gt;BFS建立Fail指针-&gt;文本串进行匹配Fail指针的建立：初始将根的子节点fail指向根并加入bfs队列，后续每个节点的fail都指向其父节点的fail的相同字母的子节点当某一字母不存在时，将其位置上的fail指针指向其父节点的fail的该字母的子节点 洛谷 P3808 【模板】AC自动机（简单版）要求：给定 n 个模式串和 1 个文本串，求有多少个模式串在文本串里出现过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int MAXLEN = 1000002;int n;char p[MAXLEN];struct Aho_Corasick_Automaton&#123; int trie[MAXLEN][26],cnt[MAXLEN],fail[MAXLEN],cntt; queue&lt;int&gt; q; inline void insert(char *s)&#123; int len=strlen(s),now=0; for(register int i=0;i&lt;len;i++)&#123; int id=s[i]-'a'; if(!trie[now][id]) trie[now][id]=++cntt; now=trie[now][id]; &#125; cnt[now]++; &#125; //建立 Trie inline void getfail()&#123; for(register int i=0;i&lt;26;i++) if(trie[0][i]) fail[trie[0][i]]=0,q.push(trie[0][i]); //将根的子结点fail指向根 while(!q.empty())&#123; int u=q.front();q.pop(); for(register int i=0;i&lt;26;i++) if(trie[u][i]) fail[trie[u][i]]=trie[fail[u]][i],q.push(trie[u][i]); // 子结点的fail指向当前结点的fail的当前位字母相同的子结点 else trie[u][i] = trie[fail[u]][i]; //若后续无所寻找字母，则将其指向当前结点的fail的所寻找字母的子结点 &#125; &#125; inline int query(char *s)&#123; int len=strlen(s),now=0,res=0; for(register int i=0;i&lt;len;i++)&#123; now=trie[now][s[i]-'a']; for(register int u=now;u&amp;&amp;cnt[u]!=-1;u=fail[u]) res+=cnt[u],cnt[u]=-1; //每个模式串仅统计一次 &#125; return res; &#125;&#125;AC;int main()&#123; scanf(\"%d\",&amp;n); for(register int i=1;i&lt;=n;i++) scanf(\"%s\",p),AC.insert(p); AC.getfail(); scanf(\"%s\",p), printf(\"%d\\n\",AC.query(p)); return 0;&#125; 洛谷 P3796 【模板】AC自动机（加强版)与简单版不同的是，需要找出出现次数最多的模式串只需在匹配后不将模式串结尾指针赋-1即可对每个模式串出现次数进行计数，最后找出最大次数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int MAXLEN = 1000002;int n,ans[200];char p[MAXLEN],s[200][80];struct Aho_Corasick_Automaton&#123; int trie[MAXLEN][26],num[MAXLEN],fail[MAXLEN],cntt; queue&lt;int&gt; q; inline void clean()&#123; //初始化 memset(trie,0,sizeof trie); memset(num,0,sizeof num); memset(fail,0,sizeof fail); cntt=0; while(!q.empty()) q.pop(); &#125; inline void insert(char *s,int x)&#123; //建立 Trie int len=strlen(s),now=0; for(register int i=0;i&lt;len;i++)&#123; int id=s[i]-'a'; if(!trie[now][id]) trie[now][id]=++cntt; now=trie[now][id]; &#125; num[now]=x; &#125; inline void getfail()&#123; for(register int i=0;i&lt;26;i++) if(trie[0][i]) fail[trie[0][i]]=0,q.push(trie[0][i]); //将根的子结点fail指向根 while(!q.empty())&#123; int u=q.front();q.pop(); for(register int i=0;i&lt;26;i++) if(trie[u][i]) fail[trie[u][i]]=trie[fail[u]][i],q.push(trie[u][i]); // 子结点的fail指向当前结点的fail的当前位字母相同的子结点 else trie[u][i] = trie[fail[u]][i]; //若后续无所寻找字母，则将其指向当前结点的fail的所寻找字母的子结点 &#125; &#125; inline void query(char *s)&#123; int len=strlen(s),now=0; for(register int i=0;i&lt;len;i++)&#123; now=trie[now][s[i]-'a']; for(register int u=now;u;u=fail[u]) ans[num[u]]++; //与简单版不同的是，相同字符串要重复计数 &#125; &#125;&#125;AC;int main()&#123; scanf(\"%d\",&amp;n); while(n)&#123; memset(ans,0,sizeof ans); AC.clean(); for(register int i=1;i&lt;=n;i++) scanf(\"%s\",s[i]),AC.insert(s[i],i); AC.getfail(); scanf(\"%s\",p); AC.query(p); int anss=0; for(int i=1;i&lt;=n;i++) anss=max(anss,ans[i]); //找出出现最多的模式串的次数 printf(\"%d\\n\",anss); for(int i=1;i&lt;=n;i++) if(ans[i]==anss) printf(\"%s\\n\",s[i]); scanf(\"%d\",&amp;n); &#125; return 0;&#125;","tags":[{"name":"Trie树","slug":"Trie树","permalink":"http://blog.southe3n.cf/tags/Trie树/"},{"name":"字符串","slug":"字符串","permalink":"http://blog.southe3n.cf/tags/字符串/"}]}]