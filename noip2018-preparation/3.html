<!DOCTYPE html>
<html>
<head>
    

    

    



    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    
    
    <link rel="canonical" href="true/noip2018-preparation/3.html">
    
    
    <title>NOIP2018赛前集训（联考篇二） | 北咸&#39;s Blog | There is an Artificial Idiot...  &lt;/br&gt; 现已兹瓷新域名 blog.southe3n.cf</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="@card{ NOIP五校联烤咕咕记（二）作者：北咸冥鱼 支持：杭州二中 成都七中 长郡中学 南京外国语学校 衡阳市八中 ......  }  联烤题整合第二弹——（10.22~ ）（似乎第一弹并不存在…）  @card{ 折射时间限制：1s空间限制：128MB  Description 小 $Y$ 十分喜爱光学相关的问题, 一天他正在研究折射。 他在平面上放置了 $n$ 个折射装置, 希望利用这">
<meta property="og:type" content="website">
<meta property="og:title" content="NOIP2018赛前集训（联考篇二）">
<meta property="og:url" content="http://blog.southe3n.cf/noip2018-preparation/3.html">
<meta property="og:site_name" content="北咸&#39;s Blog">
<meta property="og:description" content="@card{ NOIP五校联烤咕咕记（二）作者：北咸冥鱼 支持：杭州二中 成都七中 长郡中学 南京外国语学校 衡阳市八中 ......  }  联烤题整合第二弹——（10.22~ ）（似乎第一弹并不存在…）  @card{ 折射时间限制：1s空间限制：128MB  Description 小 $Y$ 十分喜爱光学相关的问题, 一天他正在研究折射。 他在平面上放置了 $n$ 个折射装置, 希望利用这">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://blog.southe3n.cf/img/refract.png">
<meta property="og:image" content="http://blog.southe3n.cf/img/sequence.jpg">
<meta property="og:updated_time" content="2018-10-30T00:08:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NOIP2018赛前集训（联考篇二）">
<meta name="twitter:description" content="@card{ NOIP五校联烤咕咕记（二）作者：北咸冥鱼 支持：杭州二中 成都七中 长郡中学 南京外国语学校 衡阳市八中 ......  }  联烤题整合第二弹——（10.22~ ）（似乎第一弹并不存在…）  @card{ 折射时间限制：1s空间限制：128MB  Description 小 $Y$ 十分喜爱光学相关的问题, 一天他正在研究折射。 他在平面上放置了 $n$ 个折射装置, 希望利用这">
<meta name="twitter:image" content="http://blog.southe3n.cf/img/refract.png">
    
        <link rel="alternate" type="application/atom+xml" title="北咸&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/ACU.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">北咸</h5>
          <a href="mailto:qxq22255090@hotmail.com" title="qxq22255090@hotmail.com" class="mail">qxq22255090@hotmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends"  >
                <i class="icon icon-lg icon-users"></i>
                友链
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                关于
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">NOIP2018赛前集训（联考篇二）</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header page-header">

    <div class="container fade-scale">
        <h1 class="title">NOIP2018赛前集训（联考篇二）</h1>
        <h5 class="subtitle">
            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    <article class="page-article fade" itemprop="blogPage">
        <div class="post-content page-content" id="page-content" itemprop="pageContent">
            <div class="card">
<h2 id="NOIP五校联烤咕咕记（二）"><a href="#NOIP五校联烤咕咕记（二）" class="headerlink" title="NOIP五校联烤咕咕记（二）"></a>NOIP五校联烤咕咕记（二）</h2><center>作者：<strong>北咸冥鱼</strong></center>
<center>支持：<strong>杭州二中 成都七中 长郡中学 南京外国语学校 衡阳市八中</strong></center>
<center><strong>......</strong></center>

</div>
<blockquote>
<p><strong>联烤题整合第二弹——（10.22~ ）</strong><br>（似乎第一弹并不存在…）</p>
</blockquote>
<div class="card">
<h2 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h2><center><span id="inline-blue">时间限制：1s</span><span id="inline-yellow">空间限制：128MB</span></center>

<p><strong>Description</strong></p>
<p>小 $Y$ 十分喜爱光学相关的问题, 一天他正在研究折射。</p>
<p>他在平面上放置了 $n$ 个折射装置, 希望利用这些装置画出美丽的折线.</p>
<p>折线将从某个装置出发, 并且在经过一处装置时可以转向, 若经过的装置坐标依次为 $(x_1, y_1),(x_2, y_2),…,(x_k, y_k)$ , 则必须满足:</p>
<ul>
<li><p><strong>$∀j ∈ (1,k], y_j&lt;y_j−1$</strong></p>
</li>
<li><p><strong>$∀j∈(2, k], (x_j−2 &lt; x_j &lt; x_j−1)~or~(x_j−1 &lt; x_j &lt; x_j−2)$</strong></p>
</li>
</ul>
<p>现在他希望你能告诉他, 一共有多少种不同的光线能被他画出来, <strong>两种光线不同当且仅当经过的折射装置的集合不同</strong>. 你只需要告诉他<strong>答案对$10^9 + 7$ 取模</strong>后的结果。</p>
<p><strong>Input</strong></p>
<p>第一行一个正整数 $n$ , 表示折射装置的数量。接下来 $n$ 行, 每行两个整数 $x_i,y_i$ 表示折射装置的坐标。</p>
<p><strong>Output</strong></p>
<p>输出一行一个整数, 表示答案对 $10^9+7$ 取模后的结果。</p>
<div class="column-2">
<div class="card">
<p><strong>Sample Input</strong></p>
<pre>4
2 2
3 1
1 4
4 3</pre>

</div>
<div class="card">
<p><strong>Sample Output</strong></p>
<pre>14</pre>

</div>
</div>
<p><strong>数据范围</strong></p>
<p>对于 $10\%$ 的数据: $n \le 700,1 \le x_i,y_i \le n$</p>
<p>对于 $20\%$ 的数据: $n \le 1000,1 \le x_i, y_i \le n$</p>
<p>对于 $50\%$ 的数据: $n \le 4000,|x_i|,|y_i| \le 10^9$</p>
<p>对于 $100\%$ 的数据: $n \le 6000,|x_i|,|y_i|\le 10^9$</p>
<p>所有数据满足 $∀i ≠ j, x_i ≠ x_j~and~y_i ≠ y_j$ 。</p>
<p><strong>Solution</strong></p>
<p>首先根据题目限制，一条合法的折线显然长成<strong>这样</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/refract.png" alt="1" title="">
                </div>
                <div class="image-caption">1</div>
            </figure>
<p><strong>先将所有点按照 $x$ 轴排序</strong></p>
<p>我们定义 <strong>$f[i][j][0/1]$</strong> 表示：</p>
<p>按 $x$ 轴排序做到第 $i$ 个点，最上面那个点是 $j$ ，$j$ 这个点是向左折还是向右折 的方案数</p>
<p>首先因为第 $i$ 个点是当前最右边的点，所以一定是一条折线的最上面两个点之一，枚举一个 $j$ 。</p>
<p><strong>- $y_i&gt;y_j$ , 则将 $i$ 作为折线最高的点，将 $j$ 接在 $i$ 下方 $f[i][i][0]+=f[i][j][1]$</strong><br><strong>- $y_i&lt;y_j$ , 则将 $j$ 作为折线最高的点，将 $i$ 接在 $j$ 下面 $f[i][j][1]+=f[i][i][0]$</strong></p>
<p>这样就是一个 <strong>$O(n^2)$</strong></p>
<p>等等，算一下<strong>空间 $128MB$似乎 $f[6000][6000]$ 开不下</strong>？！</p>
<p>别慌，第一维好像在转移过程中都用不到？直接删了就好了</p>
<blockquote>
<p>初始值将每个点都当成一条折线， $f[i][0]=f[i][1]=1$ ，最后统计答案的时候删掉多算的 $n$ 个点就好了</p>
</blockquote>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> p &amp;a)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">6100</span>];</span><br><span class="line"><span class="keyword">int</span> n,f[<span class="number">6100</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//本来是三维，分别表示：按x轴排序做到第i个点，最上面那个点是j，j这个点是向左折还是向右折 的方案数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">        f[i][<span class="number">0</span>]=f[i][<span class="number">1</span>]=<span class="number">1</span>;  <span class="comment">//初始值每个点都当作一条折线</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j;j--)</span><br><span class="line">            <span class="keyword">if</span>(a[i].y&lt;a[j].y) f[j][<span class="number">1</span>]=(f[j][<span class="number">1</span>]+f[i][<span class="number">0</span>])%mod;</span><br><span class="line">                <span class="keyword">else</span> f[i][<span class="number">0</span>]=(f[i][<span class="number">0</span>]+f[j][<span class="number">1</span>])%mod;</span><br><span class="line">    <span class="keyword">int</span> ans=-n;            <span class="comment">//统计答案时将单个点的折线减去</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=(<span class="number">0l</span>l+ans+f[i][<span class="number">0</span>]+f[i][<span class="number">1</span>])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
<div class="card">
<h2 id="画作"><a href="#画作" class="headerlink" title="画作"></a>画作</h2><center><span id="inline-blue">时间限制：1s</span><span id="inline-yellow">空间限制：256MB</span></center>

<p><strong>Description</strong></p>
<p>小 $G$ 的喜欢作画, 尤其喜欢仅使用黑白两色作画。</p>
<p>画作可以抽象成一个$ n \times m$ 大小的 $01$ 矩阵。现在小 $G$ 构思好了了他的画作, 准备动笔开始作画。 初始时画布是全白的, 他每一次下笔可以将一个<strong>四联通</strong>的部分涂成黑色或白色。</p>
<p>你需要告诉他, 在给出的构思下, 他最少需要下笔多少次才能完成画作。</p>
<p><strong>Input</strong></p>
<p>第一行两个正整数 $n, m$ 。</p>
<p>接下来 $n$ 行, 每行 $m$ 个字符, 表示目标画作。</p>
<p><strong>Output</strong></p>
<p>输出一行一个正整数, 表示最少需要的下笔步数。</p>
<div class="column-2">
<div class="card">
<p><strong>Sample Input</strong></p>
<pre>3 3
010
101
010</pre>

</div>
<div class="card">
<p><strong>Sample Output</strong></p>
<pre>2</pre>

</div>
</div>
<p><strong>数据范围</strong></p>
<p>Subtask 1 (19pts): $n \times m \le 15$.</p>
<p>Subtask 2 (7pts)  : $n=1$.</p>
<p>Subtask 3 (25pts): $n,m \le 30$.</p>
<p>Subtask 4 (49pts): $n,m \le 50$.</p>
<p><strong>Solution</strong></p>
<p><code>首先解释一下四联通块，指的是每个块与其上下左右联通，在此条件下的联通块</code></p>
<p>有这么一个结论：<strong>每次染色的联通块所用的颜色是交替的</strong></p>
<p>即：这次染黑色，下次就染白色</p>
<blockquote>
<p>这里拉一下题解的证明：</p>
<p>考虑归纳证明, 记 $S$ 为当前所有操作区域的并, $T$ 为接下来一步的操作区域, 我们有:</p>
<ol>
<li><p>$T$ 与 $S$ 有交的情况一定可以转化成 $T$ 被 $S$ 包含的情况.</p>
</li>
<li><p>$T$ 与 $S$ 交集为空时, 可以找一个连接 $S$ 和 $T$ 的集合 $M$ 并操作 $S∪T∪M$, 并将之前的所有操作连接到更外的层以及外层的连接部分同时操作, 特殊处理最外层和第二层的情况.</p>
</li>
<li><p>$T$ 被 $S$ 包含时, $T$ 落在某个完整区域内时等价于情况二, 否则一定连接若干个同色块, 这些块可以同时处理, 步数一定不会更劣。</p>
</li>
</ol>
<p><del>理性</del>感性理解一下…</p>
</blockquote>
<p>有了这个结论之后，我们<strong>枚举一个格子作为最后被染色的点</strong>（显然这个点黑白都有可能）</p>
<p>先找到这个点所在的同色联通块，那么与该同色联通块相连的所有外侧另一个颜色的联通块就是倒数第二次被染色的点，写个 $BFS$ 向外层层拓展就好了，同时记录当前处于哪一层。找同色联通块用 $DFS$ 来完成。</p>
<p>答案就是枚举的所有起点中<strong>层数的最小值</strong></p>
<p>要注意只有是 <code>&#39;1&#39;</code> 的黑块才有可能是最外层，也就是第一次被染色的块 </p>
<p>$DFS$ 和 $BFS$ 只会走每个点一次，所以整体复杂度是 <strong>$O(n^4)$</strong></p>
<blockquote>
<p>代码写的时候脑子比较乱…写的丑死了，凑合着看吧</p>
</blockquote>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1e9</span>,n,m,vis[<span class="number">3000</span>],f[<span class="number">55</span>][<span class="number">55</span>],tmp;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x*m-m+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">xx</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x/m+(x%m&gt;<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">yy</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x%m?x%m:m;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> col,<span class="keyword">int</span> mark,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=xx(u), y=yy(u);</span><br><span class="line">    <span class="keyword">if</span>(vis[id(x,y)]==mark&amp;&amp;u!=fa) <span class="keyword">return</span>;</span><br><span class="line">    vis[id(x,y)]=mark;</span><br><span class="line">    <span class="keyword">int</span> fx=xx(fa), fy=yy(fa);</span><br><span class="line">    <span class="keyword">if</span>(s[x][y]!=col)&#123; <span class="comment">//找到一个与当前圈相连的异色块</span></span><br><span class="line">        q.push(id(x,y));</span><br><span class="line">        f[x][y]=f[fx][fy]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[x][y]==<span class="string">'1'</span>) tmp=max(tmp,f[x][y]+<span class="number">1</span>); </span><br><span class="line">            <span class="comment">//只有'1'才有可能是最外圈</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][y]=f[fx][fy]; </span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) dfs(id(x<span class="number">-1</span>,y),col,mark,u);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;n) dfs(id(x+<span class="number">1</span>,y),col,mark,u);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;<span class="number">1</span>) dfs(id(x,y<span class="number">-1</span>),col,mark,u);</span><br><span class="line">    <span class="keyword">if</span>(y&lt;m) dfs(id(x,y+<span class="number">1</span>),col,mark,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            tmp=<span class="number">0</span>;</span><br><span class="line">            dfs(id(i,j),s[i][j],id(i,j),<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123; <span class="comment">//bfs向外逐层拓展</span></span><br><span class="line">                u=q.front(); q.pop();</span><br><span class="line">                dfs(u,s[xx(u)][yy(u)],id(i,j),u);</span><br><span class="line">            &#125;           </span><br><span class="line">            ans=min(ans,tmp); <span class="comment">//找所有起点的最小层数</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
<div class="card">
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><center><span id="inline-blue">时间限制：1s</span><span id="inline-yellow">空间限制：256MB</span></center>

<p><strong>Description</strong></p>
<p>对于一个长度为偶数的序列 <script type="math/tex">a_1,a_2, a_3, . . . , a_n</script> ，定义这个序列为好的序列，<br>当且仅当 <script type="math/tex">a_1 + a_n=a_2+a_{n−1}=a_3+a_{n−2}=...=a_\frac{n}{2}+a_{\frac{n}{2}+1}</script></p>
<p>定义一个对序列的翻滚操作，使所有元素向前移一个位置，第一个元素移到最后的位置。</p>
<p>现在小 $A$ 有一个长度为偶数的序列 $b_1, b_2, b_3, . . . , b_n$，他想知道至少需要翻滚多少次才能使这个序列成为好的序列。</p>
<p><strong>Input</strong></p>
<p>第一行一个整数 $n$ 表示序列的长度，保证 $n$ 为一个偶数。</p>
<p>第二行 $n$ 个正整数，第 $i$ 个数表示 $b_i$。</p>
<p><strong>Output</strong></p>
<p>如果有解，输出一个正整数，表示最少需要翻滚多少次才能使这个序列成为好的序列。</p>
<p>如果没有解，输出 <code>IMPOSSIBLE</code>。</p>
<div class="column-2">
<div class="card">
<p><strong>Sample Input</strong></p>
<pre>6
2 8 7 9 1 3</pre>

</div>
<div class="card">
<p><strong>Sample Output</strong></p>
<pre>1</pre>

</div>
</div>
<p><strong>数据范围</strong></p>
<p>对于 $30\%$ 的数据，$n \le 1000$。</p>
<p>对于 $60\%$ 的数据，$n \le 200000$。</p>
<p>对于 $100\%$ 的数据，$n \le 1000000，b_i ≤ 1000000$ 。</p>
<p><strong>Solution</strong></p>
<p><strong>做法一</strong></p>
<p><code>Manachar</code>算法，把马拉车算法中判断回文的条件改成题目要求的条件</p>
<p><strong>做法二</strong></p>
<p>首先两数的和是可以直接算出来的: $Sum/(n/2)$  </p>
<p>那么就可以算出每个数需要匹配的数，发现题中的翻滚实际就是将原数列变成一个环，我们将原数列复制一遍<strong>破环成链</strong>，再构造出那个需匹配的数列，两数列长度均为 $2n$ 。区间长度固定为 $n$，枚举区间起点，用哈希判断一下两数列是不是恰好顺序相反就好了。</p>
<p>大概长成这样子↓↓</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/sequence.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>Code</strong></p>
<blockquote>
<p> <del>代码是方法二的，双哈希，写的比较丑…</del><br>似乎单哈希也能过？惊了。单哈希看着舒服多了</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod=<span class="number">1932356437</span>,base=<span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> hash1[N&lt;&lt;<span class="number">1</span>],hash2[N&lt;&lt;<span class="number">1</span>],<span class="built_in">pow</span>[N&lt;&lt;<span class="number">1</span>],sum;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x,y;</span><br><span class="line">    x=(hash1[r]-hash1[l<span class="number">-1</span>]*<span class="built_in">pow</span>[r-l+<span class="number">1</span>]%mod+mod)%mod;</span><br><span class="line">    y=(hash2[l]-hash2[r+<span class="number">1</span>]*<span class="built_in">pow</span>[r-l+<span class="number">1</span>]%mod+mod)%mod;</span><br><span class="line">        <span class="comment">//注意构造出来的数列是反着算的</span></span><br><span class="line">    <span class="keyword">return</span> x==y;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"sequence.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"sequence.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">pow</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">pow</span>[i]=<span class="built_in">pow</span>[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">        a[i]=a[i+n]=read();</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sum/=n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        hash1[i]=(hash1[i<span class="number">-1</span>]*base+a[i])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n*<span class="number">2</span>;i;i--)</span><br><span class="line">        hash2[i]=(hash2[i+<span class="number">1</span>]*base+(sum-a[i]))%mod;</span><br><span class="line">    <span class="comment">// 构造出来的数列反着算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(judge(i,i+n<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
<div class="card">
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><center><span id="inline-blue">时间限制：1s</span><span id="inline-yellow">空间限制：512MB</span></center>

<p><strong>Description</strong></p>
<p>给出一个包含 $n$ 个点，$m$ 条有向边的图。对于每条边做一次询问，询问将该条边的<strong>方向取反，长度不变，其他边都保持不变</strong>是否会使得<strong>从 $1$ 号点到 $2$ 号点</strong>的最短路径长度相比原始的图变长，变短或者不变。可能存在重边，即两条边的起点和终点都对应相同；但不存在自环。保证原图中存在从 $1$ 号点到 $2$ 号点的路径。</p>
<p>注意，每次只做询问，不对原图产生任何影响。</p>
<p><strong>Input</strong></p>
<p>第一行包括 $2$ 个用空格隔开的整数，$n,m$ ，表示图中有 $n(n \geq 2)$个 点，$m$  条边。</p>
<p>接下来有 $m$ 行，描述了原始图中的每条边。</p>
<p>每行有 $3$ 个用空格隔开的正整数，$a_i,b_i,c_i(1\le i\le m)$ 。表示原始的图中有一条从 $a_i$ 号点到 $b_i$ 号点的有向边，长度为 $c_i$ 。（保证 $a_i$ 不等于 $b_i$ ）</p>
<p><strong>Output</strong></p>
<p>共 $m$ 行，每行 $1$ 个整数，其中第 $i$ 行的整数 $ans_i$ 表示如果将第 i 条边的方向变成相反的方向，长度不变，其他边都保持不变使得从 $1$ 号点到 $2$ 号点的最短距离相对于原图变化的结果。$ans_i$ 的含义如下：</p>
<ol>
<li>$ans_i$ 为 $1$ 时表示最短距离相对于原图变长或者不存在从 $1$ 号点到 $2$ 号点的路径；</li>
<li>$ans_i$ 为 $0$ 时表示最短距离相对于原图不变;</li>
<li>$ans_i$ 为 $-1$ 时表示最短距离相对于原图变短；</li>
</ol>
<div class="column-2">
<div class="card">
<p><strong>Sample Input</strong></p>
<pre>4 5
4 2 7
3 4 6
1 3 5
2 1 18
2 3 12</pre>

</div>
<div class="card">
<p><strong>Sample Output</strong></p>
<pre>1
1
1
0
-1
</pre>

</div>
</div>
<p><strong>数据范围</strong></p>
<p>有 $20\%$ 的数据，$2\le n\le 100,m\le10^3,1\le c_i\le 10^5$</p>
<p>有 $20\%$ 的数据，$2\le n\le 10^5,m\le 10^5, 1\le c_i\le 10^5$ ,且出度大于 $2$ 的点不超过 $15$ 个</p>
<p>其他 $60\%$ 的数据，$2\le n\le 10^5,m\le 10^5, 1\le c_i\le 10^5$, 且无其他限制</p>
<p><strong>Solution</strong></p>
<p>首先考虑一条边取反会对从 $1$ 到 $2$ 的路径产生哪些影响</p>
<p>会少一些路径，会多一些路径 <del>（这不是废话吗？！）</del></p>
<p>少的路径要分成两种情况：在最短路上和不在最短路上，如果不在除去这条边还有别的最短路径连通，显然不会有影响。而如果在最短路上，且是所有最短路的必经之路，即<strong>桥</strong>，新的最短路就会变长</p>
<p>再考虑多的路径，如果这条边在最短路上，新的路径不可能比原最短路更短</p>
<blockquote>
<p>这是可以证明的，请自行思考</p>
<p><del>（其实就是我懒得写了）</del></p>
</blockquote>
<p>若不在最短路上，就直接算出新路径中的最短路径，再和原最短路比较一下就好了</p>
<p>等等，如何算<strong>新路径中的最短路径</strong>？</p>
<p>预处理出 $1$ 到每个点的最短路，以及每个点到点 $2$ 的最短路（建反图），设其分别为 $dis1[i],dis2[i]$</p>
<p>对于一条边 $a-&gt;b$ ，长度为 $w$ ，新边中的最短路就是 $dis1[b]+dis2[a]+w$ </p>
<p>然后关于如何判断一条边是否在最短路上以及是不是桥，有两种做法</p>
<p><strong>做法一</strong>：在预处理最短路的时候同时记录方案数，若边两端点的方案数相乘，就是“桥”，否则不是</p>
<p><strong>做法二</strong>：建立一个模型，只有在最短路上的边才通，从点  $1$ 开始“流水”，算出每条边的流量，如果一条边的流量恰等于总流量，就是“桥”<br><code>一开始这个写的是 dfs ，递归层数最大可达 n 层，就爆栈了，改写 bfs</code></p>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//做法二</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>,ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> &amp;z)</span></span>&#123;read(x);read(y);read(z);&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">1000</span>,maxflow=<span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Dis;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">p</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dis;</span><br><span class="line">        <span class="keyword">int</span> u;</span><br><span class="line">        <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> p &amp;a)<span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dis&gt;a.dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;p&gt;q;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> to[N],nxt[N],w[N],head[N],cnt,vis[N],id[N];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dis[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val,<span class="keyword">int</span> Id)</span></span>&#123;</span><br><span class="line">        to[++cnt]=v,nxt[cnt]=head[u],</span><br><span class="line">        w[cnt]=val,id[cnt]=Id,head[u]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis); dis[s]=<span class="number">0</span>;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            u=q.top().u; q.pop();</span><br><span class="line">            <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[u]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">                v=to[i];</span><br><span class="line">                <span class="keyword">if</span>(dis[v]&gt;dis[u]+w[i])&#123;</span><br><span class="line">                    dis[v]=dis[u]+w[i];</span><br><span class="line">                    q.push(&#123;dis[v],v&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;g[<span class="number">2</span>];  <span class="comment">//g[0]原图， g[1]反向图，分别处理 1 到每个点的最短路和每个点到 2 的最短路</span></span><br><span class="line"><span class="keyword">int</span> n,m,a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">double</span> flow[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void dfs(int u,double nowflow)&#123;</span></span><br><span class="line"><span class="comment">    if(u==2) return;</span></span><br><span class="line"><span class="comment">    int tot=0;</span></span><br><span class="line"><span class="comment">    for(int i=g[0].head[u];i;i=g[0].nxt[i])</span></span><br><span class="line"><span class="comment">        if(g[0].dis[u]+g[0].w[i]+g[1].dis[g[0].to[i]]==Dis)</span></span><br><span class="line"><span class="comment">            tot++;</span></span><br><span class="line"><span class="comment">    nowflow/=tot;</span></span><br><span class="line"><span class="comment">    for(int i=g[0].head[u];i;i=g[0].nxt[i])</span></span><br><span class="line"><span class="comment">        if(g[0].dis[u]+g[1].dis[g[0].to[i]]+g[0].w[i]==Dis)&#123;</span></span><br><span class="line"><span class="comment">            flow[g[0].id[i]]+=nowflow;</span></span><br><span class="line"><span class="comment">            dfs(g[0].to[i],nowflow);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment"> dfs的遗骸，好像层数是 n 层，就爆栈了..改写bfs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p</span>&#123;</span><span class="keyword">int</span> u;<span class="keyword">double</span> flow;&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;p&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">double</span> maxflow)</span></span>&#123;</span><br><span class="line">    q.push(&#123;s,maxflow&#125;);</span><br><span class="line">    <span class="keyword">int</span> u,v,id,tot;</span><br><span class="line">    <span class="keyword">double</span> nowflow;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        u=q.front().u;</span><br><span class="line">        nowflow=q.front().flow;</span><br><span class="line">        q.pop();    </span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=g[<span class="number">0</span>].head[u];i;i=g[<span class="number">0</span>].nxt[i])</span><br><span class="line">            <span class="keyword">if</span>(g[<span class="number">0</span>].dis[u]+g[<span class="number">0</span>].w[i]+g[<span class="number">1</span>].dis[g[<span class="number">0</span>].to[i]]==Dis)</span><br><span class="line">                tot++;</span><br><span class="line">        nowflow/=tot;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=g[<span class="number">0</span>].head[u];i;i=g[<span class="number">0</span>].nxt[i])&#123;</span><br><span class="line">            v=g[<span class="number">0</span>].to[i];</span><br><span class="line">            id=g[<span class="number">0</span>].id[i];</span><br><span class="line">            <span class="keyword">if</span>(g[<span class="number">0</span>].dis[u]+g[<span class="number">0</span>].w[i]+g[<span class="number">1</span>].dis[v]==Dis)&#123;</span><br><span class="line">                flow[id]+=nowflow;</span><br><span class="line">                q.push(&#123;v,nowflow&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"route.in"</span> ,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"route.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        read(a[i],b[i],c[i]);</span><br><span class="line">        g[<span class="number">0</span>].add(a[i],b[i],c[i],i);</span><br><span class="line">        g[<span class="number">1</span>].add(b[i],a[i],c[i],i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g[<span class="number">0</span>].dijstra(<span class="number">1</span>);</span><br><span class="line">    g[<span class="number">1</span>].dijstra(<span class="number">2</span>);</span><br><span class="line">    Dis=g[<span class="number">0</span>].dis[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// dfs(1,maxflow);</span></span><br><span class="line">    bfs(<span class="number">1</span>,maxflow);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flow[i]&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span>(flow[i]&lt;maxflow) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(g[<span class="number">0</span>].dis[b[i]]+g[<span class="number">1</span>].dis[a[i]]+c[i]&lt;Dis) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
<div class="card">
<h2 id="地理课"><a href="#地理课" class="headerlink" title="地理课"></a>地理课</h2><center><span id="inline-blue">时间限制：2s</span><span id="inline-yellow">空间限制：512MB</span></center>

<p><strong>Description</strong></p>
<p>地理课上，老师给出了一个巨大的地图，由于世界日新月异，会有一些道路在某一时刻被删除，也会有一些道路在某一时刻被修建。这里的道路均为双向的。老师认为，有一些城市被分在了一个连通块中可以相互到达，而有一些城市不能够相互到达。而他想知道，<strong>每个时刻所有连通块大小的乘积</strong>是多少？</p>
<p>$wzy$ 看到这个地图的时候就蒙了，还好那只上天的喵及时帮助了他。现在他把这个毒瘤的地图拿过来给你，想试试看你能不能求出来。由于答案可能很大，输出乘积<strong>$mod~10^9 + 7$</strong>即可。</p>
<p><strong>Input</strong></p>
<p>第一行两个数 $𝑛, 𝑚$ ，表示有 $𝑛$ 个点，$𝑚$ 个时刻。</p>
<p>接下来 $𝑚$ 行每行三个数，要么是 $1~𝑢~𝑣$ ，要么是 $2~𝑢~𝑣$，分别表示添加一条无向边和删除一条无向边。</p>
<p><strong>Output</strong></p>
<p>共 $𝑚$ 行，每行一个数表示连通块大小乘积 $𝑚𝑜𝑑~1,000,000,007$ 。</p>
<div class="column-2">
<div class="card">
<p><strong>Sample Input</strong></p>
<pre>5 6
1 1 3
1 2 3
1 1 2
1 4 5
1 3 4
2 3 4</pre>

</div>
<div class="card">
<p><strong>Sample Output</strong></p>
<pre>2
3
3
6
5
6
</pre>

</div>
</div>
<p><strong>数据范围</strong></p>
<p>$subtask~1$：$30pts$，$𝑛 ≤ 1,000, 𝑚 ≤ 2,000$.</p>
<p>$subtask~2$：$20pts$，满足没有删除操作。</p>
<p>$subtask~3$：$50pts$，$𝑛, 𝑚 ≤ 100,000$ .保证没有重边自环，不会删除不存在的边。</p>
<p><strong>Solution</strong></p>
<p>这题在线似乎没有什么比较科学的数据结构可以维护，考虑<strong>离线</strong>算法</p>
<p>先来介绍一下一个叫<strong>线段树分治</strong>的神奇算法，一般是一个离线算法，用于维护<strong>操作的作用时段</strong>，也就是说，我们建立一颗线段树，每个结点对应一段时间，存储哪些操作会作用于这段时间。</p>
<p>然后<strong>遍历整颗线段树</strong>，到每个节点便实施这个节点上的操作，统计其对答案的影响，当到达一个叶节点时，此时的答案就是这一时刻的答案，在<strong>回溯时把这些操作还原</strong>。</p>
<p>那么回到这道题，联通块大小可以用<strong>并查集</strong>维护，(记录一下 $size$ ) , 这里的并查集<strong>不能路径压缩</strong>，因为我们要对合并操作进行还原。那么如何进行这个还原呢？</p>
<p>对于每一个结点上的操作我们进行之后记录一下是哪两个集合进行了合并，回溯时根据这个将 $size$ 和 $fa$ 进行还原。按照上面线段树分治的方法去做即可解决此题。</p>
<blockquote>
<p>这题细节可能还是有点多的，这里提几个我遇到的问题</p>
<ul>
<li><p><strong>按秩合并：</strong>并查集合并时要将 $size$ 小的挂到 $size$ 大的集合下面，这样可以保证复杂度</p>
</li>
<li><p>回溯还原并查集的时候，要<strong>与合并顺序相反</strong>，否则可能导致 $size$ 还原错</p>
</li>
<li><p>统计每条边所作用的时间段我是用 <strong>$map$</strong> 实现的，在加边时压入 $map$ 并记录加入时刻，删边时就加入线段树，最后再把没有被删掉的边加进线段树中</p>
</li>
</ul>
<p>其他的细节具体看代码吧。。</p>
</blockquote>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">101000</span>, mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N],n,m,ans,size[N],inv[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">int</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> e &amp;a)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x==a.x?y&lt;a.y:x&lt;a.x;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;e&gt; p[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;e,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x!=fa[x]) x=fa[x];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line"><span class="comment">//为了能够回溯,不能路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,e ed)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">		p[u].push_back(ed);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) update(u&lt;&lt;<span class="number">1</span>,l,mid,x,y,ed);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;mid) update(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y,ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;e&gt; &amp;a,<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	u=getf(u), v=getf(v);</span><br><span class="line">	<span class="keyword">if</span>(u==v) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(size[u]&lt;size[v]) swap(u,v);</span><br><span class="line">	fa[v]=u;</span><br><span class="line">	ans=<span class="number">1l</span>l*ans*inv[size[u]]%mod*inv[size[v]]%mod;</span><br><span class="line">	size[u]+=size[v];</span><br><span class="line">	ans=<span class="number">1l</span>l*ans*size[u]%mod;</span><br><span class="line">	a.push_back(&#123;u,v&#125;);</span><br><span class="line"><span class="comment">//并查集合并集合时一定要将size小的挂到size大的下面,保证复杂度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,nowans=ans;</span><br><span class="line">	<span class="built_in">vector</span>&lt;e&gt; a; <span class="comment">//存储哪些集合被合并,用于回溯</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p[u].size();i++)</span><br><span class="line">		merge(a,p[u][i].x,p[u][i].y);</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		work(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">		work(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">	ans=nowans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		fa[a[i].y]=a[i].y, size[a[i].x]-=size[a[i].y];</span><br><span class="line"><span class="comment">//一定要反着回溯,否则减size可能出错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		inv[i]=<span class="number">1l</span>l*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,opt,u,v;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;opt,&amp;u,&amp;v);</span><br><span class="line">		<span class="keyword">if</span>(u&gt;v) swap(u,v);</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>) mp[(e)&#123;u,v&#125;]=i;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			update(<span class="number">1</span>,<span class="number">1</span>,m,mp[(e)&#123;u,v&#125;],i<span class="number">-1</span>,&#123;u,v&#125;);</span><br><span class="line">			mp[(e)&#123;u,v&#125;]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">map</span>&lt;e,<span class="keyword">int</span>&gt;::iterator it=mp.begin();it!=mp.end();it++)</span><br><span class="line">		<span class="keyword">if</span>(it-&gt;second!=<span class="number">0</span>) update(<span class="number">1</span>,<span class="number">1</span>,m,it-&gt;second,m,it-&gt;first);</span><br><span class="line"><span class="comment">//将没被删掉的边加入线段树</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		fa[i]=i, size[i]=<span class="number">1</span>;</span><br><span class="line">	ans=<span class="number">1</span>;</span><br><span class="line">	work(<span class="number">1</span>,<span class="number">1</span>,m); <span class="comment">//对线段树上的信息进行分治</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
<div class="card">
<h2 id="数学课"><a href="#数学课" class="headerlink" title="数学课"></a>数学课</h2><center><span id="inline-blue">时间限制：2s</span><span id="inline-yellow">空间限制：512MB</span></center>

<p><strong>Description</strong></p>
<p>$wzy$ 又来上数学课了…… 虽然他很菜，但是数学还是懂一丢丢的。老师出了一道题，给定一个包含 $𝑛$ 个元素的集合 $𝑃={1,2,3, . . . , 𝑛}$ ，<strong>求有多少个集合 $𝐴\subseteq 𝑃$，满足任意 $𝑥 \in 𝐴$ 有 $2𝑥 \notin 𝐴$ ，且对于 $𝐴$ 在 $𝑃$  中的补集 $𝐵$ ，也满足任意 $𝑥\in 𝐵$ 有 $2𝑥\notin 𝐵$ </strong>。 $wzy$ 花费了 $1E100$ 天终于算出来了这个答案，但是可恶的 $caoxia$ 居然又加了一个条件！他要求 $𝐴$ 的大小恰好为 $𝑚$ ，这样又有多少个 $𝐴$ 呢？</p>
<p>这回 $wzy$ 真的不会了，他找到了你，希望能够得到帮助。由于答案太大，你只需要输出答案 $mod~10000019$ 即可。</p>
<p><strong>Input</strong></p>
<p>第一行两个数，为 $𝑛, 𝑞$ 。接下来 $𝑞$ 行每行一个数 $𝑚$ ，询问大小为 $𝑚$ 的 $𝐴$ 一共有多少个。</p>
<p><strong>Output</strong></p>
<p>共 $𝑞$ 行，每行一个数，表示方案数 $mod~10000019$ 。</p>
<div class="column-2">
<div class="card">
<p><strong>Sample Input</strong></p>
<pre>3 3
0
1
2</pre>

<pre>100 4
45
50
60
70
</pre>

</div>
<div class="card">
<p><strong>Sample Output</strong></p>
<pre>0
2
2</pre>

<pre>2085406
6657572
7844331
0</pre>

</div>
</div>
<p><strong>数据范围</strong></p>
<p>$subtask1$：$20pts$，$𝑛, 𝑚, 𝑞 \le 20$</p>
<p>$subtask2$：$30pts$，$𝑛, 𝑚, 𝑞 \le 5,000$</p>
<p>$subtask3$：$30pts$，$𝑛, 𝑚 \le 10,000,000, 𝑞 \le 100,000$</p>
<p>$subtask4$：$20pts$，$𝑛, 𝑚 \le 10^{18}, 𝑞 \le 100,000$</p>
<p><strong>Solution</strong></p>
<p>发现$1…n$的集合可以拆成一些形如 ${1,2,4,8,16····} {3,6,12,24····}$ 的子集，显然根据题目要求<strong>些子集中任意两个相邻的数都不能同时属于 $A$ 或 $B$</strong> ，因此，对于一个有 $2p$ 个元素的子集，其中 $p$ 个属于 $A$ ，$p$ 个属于 $B$  。对于一个有 $2p+1$ 个集合的子集，有一个元素可以选择是否属于 $A$ 。</p>
<p>因此我们<strong>预处理出元素数为奇数和偶数的子集个数 $odd$ 和 $even$，以及这些集合中必定要属于 $A$ 的元素个数 $sum$ </strong>。如何处理？显然<strong>对于任意奇数，以其为最小元素所构成的子集的元素个数是单调不升的</strong>。因此我们枚举元素个数 $t$ ，满足条件的奇数 $x$ 是一个区间，且满足 <strong>$2^{t-1}x\le n$且$2^tx＞n$</strong>，所以满足条件的 $x$ 所处的区间就是</p>
<script type="math/tex; mode=display">\frac{n}{2^t}＜x \le \frac{n}{2^{t-1}}</script><p>这段区间中的奇数个数即为长度为 $t$ 的子集个数。</p>
<p>有了预处理的信息，对于每个 $m$ ，首先必定有 $sum$ 个元素是必定的，这部分的方案数是 $2^{even}$ ，然后还剩余 $m-sum$ 个元素要从 $odd$ 个可选择是否属于 $A$ 的元素中任选。所以最终的答案就是</p>
<script type="math/tex; mode=display">\binom{m-sum}{odd}·2^{evem}</script><p><span id="inline-blue">一点小事： <script type="math/tex">ans_m=ans_{n-m}</script> ，算 <script type="math/tex">m-sum</script> 的时候要保证 <script type="math/tex">m≥\frac{n}{2}</script> </span></p>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">10000019</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,q,m,num,sum,odd,even,ans;</span><br><span class="line"><span class="keyword">int</span> inv[p+<span class="number">10</span>],fac[p+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lucas</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;p&amp;&amp;y&lt;p) <span class="keyword">return</span> <span class="number">1l</span>l*fac[y]*inv[x]%p*inv[y-x]%p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l*lucas(x%p,y%p)*lucas(x/p,y/p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1l</span>l*res*x%p;</span><br><span class="line">        x=<span class="number">1l</span>l*x*x%p;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;p;i++) fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    inv[p<span class="number">-1</span>]=<span class="built_in">pow</span>(fac[p<span class="number">-1</span>],p<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=p<span class="number">-1</span>;i;i--) inv[i<span class="number">-1</span>]=<span class="number">1l</span>l*inv[i]*i%p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l,r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">61</span>;i++)&#123;</span><br><span class="line">        l=n/(<span class="number">1l</span>l&lt;&lt;i)+<span class="number">1</span>, r=n/(<span class="number">1l</span>l&lt;&lt;i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&lt;l) <span class="keyword">continue</span>;</span><br><span class="line">        num=(r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>)-(l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        sum+=i/<span class="number">2</span>*num;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>) odd+=num;</span><br><span class="line">            <span class="keyword">else</span> even+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> less;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=n/<span class="number">2</span>) m=n-m;</span><br><span class="line">        less=m-sum;</span><br><span class="line">        ans=<span class="number">1l</span>l*<span class="built_in">pow</span>(<span class="number">2</span>,even)*lucas(less,odd)%p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

        </div>

        

        


        











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "1Ya3GFYLfUGzgL7S113cABvD-gzGzoHsz",
            appKey: "UiTLEJsU3isv39WUo2JGxqtz",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







    </article>
    

</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>北咸 &copy; 2018 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.southe3n.cf/noip2018-preparation/3.html&title=《NOIP2018赛前集训（联考篇二）》 — 北咸's Blog&pic=http://blog.southe3n.cf/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.southe3n.cf/noip2018-preparation/3.html&title=《NOIP2018赛前集训（联考篇二）》 — 北咸's Blog&source=found on 2018-4-30" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.southe3n.cf/noip2018-preparation/3.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《NOIP2018赛前集训（联考篇二）》 — 北咸's Blog&url=http://blog.southe3n.cf/noip2018-preparation/3.html&via=http://blog.southe3n.cf" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.southe3n.cf/noip2018-preparation/3.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLElEQVR42u3awW6EMAxFUf7/p6nU1UhT4D4bpOLcrFAHQk4WrmOzbXjsv+P879/Xn+Po2aOntieGDBkyXsvYT8c5gy+IL/F8Ow7nkSFDxgKM2nRpsE6pZG0yZMiQkaaAJMjy4C5DhgwZnYAbp24hTIYMGTJqh9jz15MX84148CwuQ4aMFzL6B9Hnrh/sb8iQIeMljD0cJHFM35s2A/5YlQwZMkYzjgJcegTlaSK/J009ZciQMZtBGor9w21tm+IjqwwZMsYx7m09pu3JWoqJ6oUyZMgYx4ibhWHc6/9PuGimypAhYzSDp4lpkyBNOtPPMorZrgwZMl7IIDelJXseXtNnD69lyJCxJIMHu3SG9DCMnpIhQ8ZoBglnpPjFZ0hn461QGTJkzGbwF9Tur21HcYtlyJAxmlHrCfKjbLrQ2vbJkCFjHqPWAOjX5NNC3kXAlSFDxgIMXriv/Vr7OCO4X4YMGaMZd427SnIk7D44ZMiQ8Y8ZtdCZBtlaAkrSRBkyZMxm9BedNhp5GA0CrgwZMhZg8AYACYK1ENzZUBkyZMxmkCNlLWmrBejOKVWGDBlTGXs47iq38YQSNURlyJAxmlEr/ccfQ4R4PqcMGTLWYaSfZPGCPg+vtZ6GDBkyVmN0ymE8fne+/kCdWBkyZCzP4C0EXtAnARclnTJkyJDR/jCic/SN+7EyZMgYyuBhjiyCzJCW5C6ekiFDxmhG7fDZaS6SpLOWaMqQIWMc4weGSiLg4h0YtAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(っ·Д·)っ页面崩溃了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>
